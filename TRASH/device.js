function Z0(e, t) {
    for (var n = 0; n < t.length; n++) {
        const r = t[n];
        if (typeof r != "string" && !Array.isArray(r)) {
            for (const i in r)
                if (i !== "default" && !(i in e)) {
                    const s = Object.getOwnPropertyDescriptor(r, i);
                    s && Object.defineProperty(e, i, s.get ? s : {
                        enumerable: !0,
                        get: ()=>r[i]
                    })
                }
        }f
    }
    return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
    }))
}
function Pa(e, t) {
    const n = Object.create(null)
        , r = e.split(",");
    for (let i = 0; i < r.length; i++)
        n[r[i]] = !0;
    return t ? i=>!!n[i.toLowerCase()] : i=>!!n[i]
}
const Ye = {}
    , _i = []
    , Sn = ()=>{}
    , Q0 = ()=>!1
    , ew = /^on[^a-z]/
    , Ks = e=>ew.test(e)
    , gu = e=>e.startsWith("onUpdate:")
    , Ze = Object.assign
    , vu = (e,t)=>{
        const n = e.indexOf(t);
        n > -1 && e.splice(n, 1)
    }
    , tw = Object.prototype.hasOwnProperty
    , He = (e,t)=>tw.call(e, t)
    , be = Array.isArray
    , Ei = e=>Bi(e) === "[object Map]"
    , Yr = e=>Bi(e) === "[object Set]"
    , Kf = e=>Bi(e) === "[object Date]"
    , nw = e=>Bi(e) === "[object RegExp]"
    , Le = e=>typeof e == "function"
    , rt = e=>typeof e == "string"
    , xs = e=>typeof e == "symbol"
    , qe = e=>e !== null && typeof e == "object"
    , yu = e=>qe(e) && Le(e.then) && Le(e.catch)
    , Pm = Object.prototype.toString
    , Bi = e=>Pm.call(e)
    , rw = e=>Bi(e).slice(8, -1)
    , km = e=>Bi(e) === "[object Object]"
    , bu = e=>rt(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e
    , hs = Pa(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted")
    , ka = e=>{
        const t = Object.create(null);
        return n=>t[n] || (t[n] = e(n))
    }
    , iw = /-(\w)/g
    , Gt = ka(e=>e.replace(iw, (t,n)=>n ? n.toUpperCase() : ""))
    , sw = /\B([A-Z])/g
    , cn = ka(e=>e.replace(sw, "-$1").toLowerCase())
    , Ys = ka(e=>e.charAt(0).toUpperCase() + e.slice(1))
    , ms = ka(e=>e ? `on ${Ys(e)}` : "")
    , ki = (e,t)=>!Object.is(e, t)
    , Ci = (e,t)=>{
        for (let n = 0; n < e.length; n++)
            e[n](t)
    }
    , Zo = (e,t,n)=>{
        Object.defineProperty(e, t, {
            configurable: !0,
            enumerable: !1,
            value: n
        })
    }
    , Qo = e=>{
        const t = parseFloat(e);
        return isNaN(t) ? e : t
    }
    , ea = e=>{
        const t = rt(e) ? Number(e) : NaN;
        return isNaN(t) ? e : t
    }
;
let Yf;
const Zl = ()=>Yf || (Yf = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {})
    , ow = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console"
    , aw = Pa(ow);
function Br(e) {
    if (be(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
            const r = e[n]
                , i = rt(r) ? fw(r) : Br(r);
            if (i)
                for (const s in i)
                    t[s] = i[s]
        }
        return t
    } else {
        if (rt(e))
            return e;
        if (qe(e))
            return e
    }
}
const lw = /;(?![^(]*\))/g
    , cw = /:([^]+)/
    , uw = /\/\*[^]*?\*\//g;
function fw(e) {
    const t = {};
    return e.replace(uw, "").split(lw).forEach(n=>{
            if (n) {
                const r = n.split(cw);
                r.length > 1 && (t[r[0].trim()] = r[1].trim())
            }
        }
    ),
        t
}
function Pt(e) {
    let t = "";
    if (rt(e))
        t = e;
    else if (be(e))
        for (let n = 0; n < e.length; n++) {
            const r = Pt(e[n]);
            r && (t += r + " ")
        }
    else if (qe(e))
        for (const n in e)
            e[n] && (t += n + " ");
    return t.trim()
}
function dw(e) {
    if (!e)
        return null;
    let {class: t, style: n} = e;
    return t && !rt(t) && (e.class = Pt(t)),
    n && (e.style = Br(n)),
        e
}
const pw = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly"
    , hw = Pa(pw);
function Rm(e) {
    return !!e || e === ""
}
function mw(e, t) {
    if (e.length !== t.length)
        return !1;
    let n = !0;
    for (let r = 0; n && r < e.length; r++)
        n = pr(e[r], t[r]);
    return n
}
function pr(e, t) {
    if (e === t)
        return !0;
    let n = Kf(e)
        , r = Kf(t);
    if (n || r)
        return n && r ? e.getTime() === t.getTime() : !1;
    if (n = xs(e),
        r = xs(t),
    n || r)
        return e === t;
    if (n = be(e),
        r = be(t),
    n || r)
        return n && r ? mw(e, t) : !1;
    if (n = qe(e),
        r = qe(t),
    n || r) {
        if (!n || !r)
            return !1;
        const i = Object.keys(e).length
            , s = Object.keys(t).length;
        if (i !== s)
            return !1;
        for (const o in e) {
            const a = e.hasOwnProperty(o)
                , l = t.hasOwnProperty(o);
            if (a && !l || !a && l || !pr(e[o], t[o]))
                return !1
        }
    }
    return String(e) === String(t)
}
function Ra(e, t) {
    return e.findIndex(n=>pr(n, t))
}
const _n = e=>rt(e) ? e : e == null ? "" : be(e) || qe(e) && (e.toString === Pm || !Le(e.toString)) ? JSON.stringify(e, Lm, 2) : String(e)
    , Lm = (e,t)=>t && t.__v_isRef ? Lm(e, t.value) : Ei(t) ? {
    [`Map(${t.size})`]: [...t.entries()].reduce((n,[r,i])=>(n[`${r} =>`] = i,
        n), {})
} : Yr(t) ? {
    [`Set(${t.size})`]: [...t.values()]
} : qe(t) && !be(t) && !km(t) ? String(t) : t;
let qt;
class wu {
    constructor(t=!1) {
        this.detached = t,
            this._active = !0,
            this.effects = [],
            this.cleanups = [],
            this.parent = qt,
        !t && qt && (this.index = (qt.scopes || (qt.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    run(t) {
        if (this._active) {
            const n = qt;
            try {
                return qt = this,
                    t()
            } finally {
                qt = n
            }
        }
    }
    on() {
        qt = this
    }
    off() {
        qt = this.parent
    }
    stop(t) {
        if (this._active) {
            let n, r;
            for (n = 0,
                     r = this.effects.length; n < r; n++)
                this.effects[n].stop();
            for (n = 0,
                     r = this.cleanups.length; n < r; n++)
                this.cleanups[n]();
            if (this.scopes)
                for (n = 0,
                         r = this.scopes.length; n < r; n++)
                    this.scopes[n].stop(!0);
            if (!this.detached && this.parent && !t) {
                const i = this.parent.scopes.pop();
                i && i !== this && (this.parent.scopes[this.index] = i,
                    i.index = this.index)
            }
            this.parent = void 0,
                this._active = !1
        }
    }
}
function La(e) {
    return new wu(e)
}
function Om(e, t=qt) {
    t && t.active && t.effects.push(e)
}
function Su() {
    return qt
}
function Am(e) {
    qt && qt.cleanups.push(e)
}
const _u = e=>{
    const t = new Set(e);
    return t.w = 0,
        t.n = 0,
        t
}
    , Im = e=>(e.w & hr) > 0
    , Mm = e=>(e.n & hr) > 0
    , gw = ({deps: e})=>{
    if (e.length)
        for (let t = 0; t < e.length; t++)
            e[t].w |= hr
}
    , vw = e=>{
    const {deps: t} = e;
    if (t.length) {
        let n = 0;
        for (let r = 0; r < t.length; r++) {
            const i = t[r];
            Im(i) && !Mm(i) ? i.delete(e) : t[n++] = i,
                i.w &= ~hr,
                i.n &= ~hr
        }
        t.length = n
    }
}
    , ta = new WeakMap;
let ls = 0
    , hr = 1;
const Ql = 30;
let yn;
const Dr = Symbol("")
    , ec = Symbol("");
class qs {
    constructor(t, n=null, r) {
        this.fn = t,
            this.scheduler = n,
            this.active = !0,
            this.deps = [],
            this.parent = void 0,
            Om(this, r)
    }
    run() {
        if (!this.active)
            return this.fn();
        let t = yn
            , n = fr;
        for (; t; ) {
            if (t === this)
                return;
            t = t.parent
        }
        try {
            return this.parent = yn,
                yn = this,
                fr = !0,
                hr = 1 << ++ls,
                ls <= Ql ? gw(this) : qf(this),
                this.fn()
        } finally {
            ls <= Ql && vw(this),
                hr = 1 << --ls,
                yn = this.parent,
                fr = n,
                this.parent = void 0,
            this.deferStop && this.stop()
        }
    }
    stop() {
        yn === this ? this.deferStop = !0 : this.active && (qf(this),
        this.onStop && this.onStop(),
            this.active = !1)
    }
}
function qf(e) {
    const {deps: t} = e;
    if (t.length) {
        for (let n = 0; n < t.length; n++)
            t[n].delete(e);
        t.length = 0
    }
}
function yw(e, t) {
    e.effect && (e = e.effect.fn);
    const n = new qs(e);
    t && (Ze(n, t),
    t.scope && Om(n, t.scope)),
    (!t || !t.lazy) && n.run();
    const r = n.run.bind(n);
    return r.effect = n,
        r
}
function bw(e) {
    e.effect.stop()
}
let fr = !0;
const Dm = [];
function Vi() {
    Dm.push(fr),
        fr = !1
}
function zi() {
    const e = Dm.pop();
    fr = e === void 0 ? !0 : e
}
function Xt(e, t, n) {
    if (fr && yn) {
        let r = ta.get(e);
        r || ta.set(e, r = new Map);
        let i = r.get(n);
        i || r.set(n, i = _u()),
            Nm(i)
    }
}
function Nm(e, t) {
    let n = !1;
    ls <= Ql ? Mm(e) || (e.n |= hr,
        n = !Im(e)) : n = !e.has(yn),
    n && (e.add(yn),
        yn.deps.push(e))
}
function Yn(e, t, n, r, i, s) {
    const o = ta.get(e);
    if (!o)
        return;
    let a = [];
    if (t === "clear")
        a = [...o.values()];
    else if (n === "length" && be(e)) {
        const l = Number(r);
        o.forEach((c,u)=>{
                (u === "length" || u >= l) && a.push(c)
            }
        )
    } else
        switch (n !== void 0 && a.push(o.get(n)),
            t) {
            case "add":
                be(e) ? bu(n) && a.push(o.get("length")) : (a.push(o.get(Dr)),
                Ei(e) && a.push(o.get(ec)));
                break;
            case "delete":
                be(e) || (a.push(o.get(Dr)),
                Ei(e) && a.push(o.get(ec)));
                break;
            case "set":
                Ei(e) && a.push(o.get(Dr));
                break
        }
    if (a.length === 1)
        a[0] && tc(a[0]);
    else {
        const l = [];
        for (const c of a)
            c && l.push(...c);
        tc(_u(l))
    }
}
function tc(e, t) {
    const n = be(e) ? e : [...e];
    for (const r of n)
        r.computed && Jf(r);
    for (const r of n)
        r.computed || Jf(r)
}
function Jf(e, t) {
    (e !== yn || e.allowRecurse) && (e.scheduler ? e.scheduler() : e.run())
}
function ww(e, t) {
    var n;
    return (n = ta.get(e)) == null ? void 0 : n.get(t)
}
const Sw = Pa("__proto__,__v_isRef,__isVue")
    , $m = new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e !== "arguments" && e !== "caller").map(e=>Symbol[e]).filter(xs))
    , _w = Oa()
    , Ew = Oa(!1, !0)
    , Cw = Oa(!0)
    , Tw = Oa(!0, !0)
    , Zf = xw();
function xw() {
    const e = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(t=>{
            e[t] = function(...n) {
                const r = ke(this);
                for (let s = 0, o = this.length; s < o; s++)
                    Xt(r, "get", s + "");
                const i = r[t](...n);
                return i === -1 || i === !1 ? r[t](...n.map(ke)) : i
            }
        }
    ),
        ["push", "pop", "shift", "unshift", "splice"].forEach(t=>{
                e[t] = function(...n) {
                    Vi();
                    const r = ke(this)[t].apply(this, n);
                    return zi(),
                        r
                }
            }
        ),
        e
}
function Pw(e) {
    const t = ke(this);
    return Xt(t, "has", e),
        t.hasOwnProperty(e)
}
function Oa(e=!1, t=!1) {
    return function(r, i, s) {
        if (i === "__v_isReactive")
            return !e;
        if (i === "__v_isReadonly")
            return e;
        if (i === "__v_isShallow")
            return t;
        if (i === "__v_raw" && s === (e ? t ? Um : zm : t ? Vm : Bm).get(r))
            return r;
        const o = be(r);
        if (!e) {
            if (o && He(Zf, i))
                return Reflect.get(Zf, i, s);
            if (i === "hasOwnProperty")
                return Pw
        }
        const a = Reflect.get(r, i, s);
        return (xs(i) ? $m.has(i) : Sw(i)) || (e || Xt(r, "get", i),
            t) ? a : Je(a) ? o && bu(i) ? a : a.value : qe(a) ? e ? _r(a) : nn(a) : a
    }
}
const kw = Fm()
    , Rw = Fm(!0);
function Fm(e=!1) {
    return function(n, r, i, s) {
        let o = n[r];
        if (mr(o) && Je(o) && !Je(i))
            return !1;
        if (!e && (!Ps(i) && !mr(i) && (o = ke(o),
            i = ke(i)),
        !be(n) && Je(o) && !Je(i)))
            return o.value = i,
                !0;
        const a = be(n) && bu(r) ? Number(r) < n.length : He(n, r)
            , l = Reflect.set(n, r, i, s);
        return n === ke(s) && (a ? ki(i, o) && Yn(n, "set", r, i) : Yn(n, "add", r, i)),
            l
    }
}
function Lw(e, t) {
    const n = He(e, t);
    e[t];
    const r = Reflect.deleteProperty(e, t);
    return r && n && Yn(e, "delete", t, void 0),
        r
}
function Ow(e, t) {
    const n = Reflect.has(e, t);
    return (!xs(t) || !$m.has(t)) && Xt(e, "has", t),
        n
}
function Aw(e) {
    return Xt(e, "iterate", be(e) ? "length" : Dr),
        Reflect.ownKeys(e)
}
const jm = {
    get: _w,
    set: kw,
    deleteProperty: Lw,
    has: Ow,
    ownKeys: Aw
}
    , Hm = {
    get: Cw,
    set(e, t) {
        return !0
    },
    deleteProperty(e, t) {
        return !0
    }
}
    , Iw = Ze({}, jm, {
    get: Ew,
    set: Rw
})
    , Mw = Ze({}, Hm, {
    get: Tw
})
    , Eu = e=>e
    , Aa = e=>Reflect.getPrototypeOf(e);
function lo(e, t, n=!1, r=!1) {
    e = e.__v_raw;
    const i = ke(e)
        , s = ke(t);
    n || (t !== s && Xt(i, "get", t),
        Xt(i, "get", s));
    const {has: o} = Aa(i)
        , a = r ? Eu : n ? xu : ks;
    if (o.call(i, t))
        return a(e.get(t));
    if (o.call(i, s))
        return a(e.get(s));
    e !== i && e.get(t)
}
function co(e, t=!1) {
    const n = this.__v_raw
        , r = ke(n)
        , i = ke(e);
    return t || (e !== i && Xt(r, "has", e),
        Xt(r, "has", i)),
        e === i ? n.has(e) : n.has(e) || n.has(i)
}
function uo(e, t=!1) {
    return e = e.__v_raw,
    !t && Xt(ke(e), "iterate", Dr),
        Reflect.get(e, "size", e)
}
function Qf(e) {
    e = ke(e);
    const t = ke(this);
    return Aa(t).has.call(t, e) || (t.add(e),
        Yn(t, "add", e, e)),
        this
}
function ed(e, t) {
    t = ke(t);
    const n = ke(this)
        , {has: r, get: i} = Aa(n);
    let s = r.call(n, e);
    s || (e = ke(e),
        s = r.call(n, e));
    const o = i.call(n, e);
    return n.set(e, t),
        s ? ki(t, o) && Yn(n, "set", e, t) : Yn(n, "add", e, t),
        this
}
function td(e) {
    const t = ke(this)
        , {has: n, get: r} = Aa(t);
    let i = n.call(t, e);
    i || (e = ke(e),
        i = n.call(t, e)),
    r && r.call(t, e);
    const s = t.delete(e);
    return i && Yn(t, "delete", e, void 0),
        s
}
function nd() {
    const e = ke(this)
        , t = e.size !== 0
        , n = e.clear();
    return t && Yn(e, "clear", void 0, void 0),
        n
}
function fo(e, t) {
    return function(r, i) {
        const s = this
            , o = s.__v_raw
            , a = ke(o)
            , l = t ? Eu : e ? xu : ks;
        return !e && Xt(a, "iterate", Dr),
            o.forEach((c,u)=>r.call(i, l(c), l(u), s))
    }
}
function po(e, t, n) {
    return function(...r) {
        const i = this.__v_raw
            , s = ke(i)
            , o = Ei(s)
            , a = e === "entries" || e === Symbol.iterator && o
            , l = e === "keys" && o
            , c = i[e](...r)
            , u = n ? Eu : t ? xu : ks;
        return !t && Xt(s, "iterate", l ? ec : Dr),
            {
                next() {
                    const {value: f, done: d} = c.next();
                    return d ? {
                        value: f,
                        done: d
                    } : {
                        value: a ? [u(f[0]), u(f[1])] : u(f),
                        done: d
                    }
                },
                [Symbol.iterator]() {
                    return this
                }
            }
    }
}
function tr(e) {
    return function(...t) {
        return e === "delete" ? !1 : this
    }
}
function Dw() {
    const e = {
        get(s) {
            return lo(this, s)
        },
        get size() {
            return uo(this)
        },
        has: co,
        add: Qf,
        set: ed,
        delete: td,
        clear: nd,
        forEach: fo(!1, !1)
    }
        , t = {
        get(s) {
            return lo(this, s, !1, !0)
        },
        get size() {
            return uo(this)
        },
        has: co,
        add: Qf,
        set: ed,
        delete: td,
        clear: nd,
        forEach: fo(!1, !0)
    }
        , n = {
        get(s) {
            return lo(this, s, !0)
        },
        get size() {
            return uo(this, !0)
        },
        has(s) {
            return co.call(this, s, !0)
        },
        add: tr("add"),
        set: tr("set"),
        delete: tr("delete"),
        clear: tr("clear"),
        forEach: fo(!0, !1)
    }
        , r = {
        get(s) {
            return lo(this, s, !0, !0)
        },
        get size() {
            return uo(this, !0)
        },
        has(s) {
            return co.call(this, s, !0)
        },
        add: tr("add"),
        set: tr("set"),
        delete: tr("delete"),
        clear: tr("clear"),
        forEach: fo(!0, !0)
    };
    return ["keys", "values", "entries", Symbol.iterator].forEach(s=>{
            e[s] = po(s, !1, !1),
                n[s] = po(s, !0, !1),
                t[s] = po(s, !1, !0),
                r[s] = po(s, !0, !0)
        }
    ),
        [e, n, t, r]
}
const [Nw,$w,Fw,jw] = Dw();
function Ia(e, t) {
    const n = t ? e ? jw : Fw : e ? $w : Nw;
    return (r,i,s)=>i === "__v_isReactive" ? !e : i === "__v_isReadonly" ? e : i === "__v_raw" ? r : Reflect.get(He(n, i) && i in r ? n : r, i, s)
}
const Hw = {
    get: Ia(!1, !1)
}
    , Bw = {
    get: Ia(!1, !0)
}
    , Vw = {
    get: Ia(!0, !1)
}
    , zw = {
    get: Ia(!0, !0)
}
    , Bm = new WeakMap
    , Vm = new WeakMap
    , zm = new WeakMap
    , Um = new WeakMap;
function Uw(e) {
    switch (e) {
        case "Object":
        case "Array":
            return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2;
        default:
            return 0
    }
}
function Ww(e) {
    return e.__v_skip || !Object.isExtensible(e) ? 0 : Uw(rw(e))
}
function nn(e) {
    return mr(e) ? e : Ma(e, !1, jm, Hw, Bm)
}
function Ui(e) {
    return Ma(e, !1, Iw, Bw, Vm)
}
function _r(e) {
    return Ma(e, !0, Hm, Vw, zm)
}
function Gw(e) {
    return Ma(e, !0, Mw, zw, Um)
}
function Ma(e, t, n, r, i) {
    if (!qe(e) || e.__v_raw && !(t && e.__v_isReactive))
        return e;
    const s = i.get(e);
    if (s)
        return s;
    const o = Ww(e);
    if (o === 0)
        return e;
    const a = new Proxy(e,o === 2 ? r : n);
    return i.set(e, a),
        a
}
function Nr(e) {
    return mr(e) ? Nr(e.__v_raw) : !!(e && e.__v_isReactive)
}
function mr(e) {
    return !!(e && e.__v_isReadonly)
}
function Ps(e) {
    return !!(e && e.__v_isShallow)
}
function Cu(e) {
    return Nr(e) || mr(e)
}
function ke(e) {
    const t = e && e.__v_raw;
    return t ? ke(t) : e
}
function Tu(e) {
    return Zo(e, "__v_skip", !0),
        e
}
const ks = e=>qe(e) ? nn(e) : e
    , xu = e=>qe(e) ? _r(e) : e;
function Pu(e) {
    fr && yn && (e = ke(e),
        Nm(e.dep || (e.dep = _u())))
}
function Da(e, t) {
    e = ke(e);
    const n = e.dep;
    n && tc(n)
}
function Je(e) {
    return !!(e && e.__v_isRef === !0)
}
function X(e) {
    return Wm(e, !1)
}
function gr(e) {
    return Wm(e, !0)
}
function Wm(e, t) {
    return Je(e) ? e : new Xw(e,t)
}
class Xw {
    constructor(t, n) {
        this.__v_isShallow = n,
            this.dep = void 0,
            this.__v_isRef = !0,
            this._rawValue = n ? t : ke(t),
            this._value = n ? t : ks(t)
    }
    get value() {
        return Pu(this),
            this._value
    }
    set value(t) {
        const n = this.__v_isShallow || Ps(t) || mr(t);
        t = n ? t : ke(t),
        ki(t, this._rawValue) && (this._rawValue = t,
            this._value = n ? t : ks(t),
            Da(this))
    }
}
function Kw(e) {
    Da(e)
}
function we(e) {
    return Je(e) ? e.value : e
}
function Yw(e) {
    return Le(e) ? e() : we(e)
}
const qw = {
    get: (e,t,n)=>we(Reflect.get(e, t, n)),
    set: (e,t,n,r)=>{
        const i = e[t];
        return Je(i) && !Je(n) ? (i.value = n,
            !0) : Reflect.set(e, t, n, r)
    }
};
function ku(e) {
    return Nr(e) ? e : new Proxy(e,qw)
}
class Jw {
    constructor(t) {
        this.dep = void 0,
            this.__v_isRef = !0;
        const {get: n, set: r} = t(()=>Pu(this), ()=>Da(this));
        this._get = n,
            this._set = r
    }
    get value() {
        return this._get()
    }
    set value(t) {
        this._set(t)
    }
}
function Gm(e) {
    return new Jw(e)
}
function Zw(e) {
    const t = be(e) ? new Array(e.length) : {};
    for (const n in e)
        t[n] = Xm(e, n);
    return t
}
class Qw {
    constructor(t, n, r) {
        this._object = t,
            this._key = n,
            this._defaultValue = r,
            this.__v_isRef = !0
    }
    get value() {
        const t = this._object[this._key];
        return t === void 0 ? this._defaultValue : t
    }
    set value(t) {
        this._object[this._key] = t
    }
    get dep() {
        return ww(ke(this._object), this._key)
    }
}
class eS {
    constructor(t) {
        this._getter = t,
            this.__v_isRef = !0,
            this.__v_isReadonly = !0
    }
    get value() {
        return this._getter()
    }
}
function Ri(e, t, n) {
    return Je(e) ? e : Le(e) ? new eS(e) : qe(e) && arguments.length > 1 ? Xm(e, t, n) : X(e)
}
function Xm(e, t, n) {
    const r = e[t];
    return Je(r) ? r : new Qw(e,t,n)
}
class tS {
    constructor(t, n, r, i) {
        this._setter = n,
            this.dep = void 0,
            this.__v_isRef = !0,
            this.__v_isReadonly = !1,
            this._dirty = !0,
            this.effect = new qs(t,()=>{
                    this._dirty || (this._dirty = !0,
                        Da(this))
                }
            ),
            this.effect.computed = this,
            this.effect.active = this._cacheable = !i,
            this.__v_isReadonly = r
    }
    get value() {
        const t = ke(this);
        return Pu(t),
        (t._dirty || !t._cacheable) && (t._dirty = !1,
            t._value = t.effect.run()),
            t._value
    }
    set value(t) {
        this._setter(t)
    }
}
function nS(e, t, n=!1) {
    let r, i;
    const s = Le(e);
    return s ? (r = e,
        i = Sn) : (r = e.get,
        i = e.set),
        new tS(r,i,s || !i,n)
}
function rS(e, ...t) {}
function iS(e, t) {}
function Kn(e, t, n, r) {
    let i;
    try {
        i = r ? e(...r) : e()
    } catch (s) {
        qr(s, t, n)
    }
    return i
}
function tn(e, t, n, r) {
    if (Le(e)) {
        const s = Kn(e, t, n, r);
        return s && yu(s) && s.catch(o=>{
                qr(o, t, n)
            }
        ),
            s
    }
    const i = [];
    for (let s = 0; s < e.length; s++)
        i.push(tn(e[s], t, n, r));
    return i
}
function qr(e, t, n, r=!0) {
    const i = t ? t.vnode : null;
    if (t) {
        let s = t.parent;
        const o = t.proxy
            , a = n;
        for (; s; ) {
            const c = s.ec;
            if (c) {
                for (let u = 0; u < c.length; u++)
                    if (c[u](e, o, a) === !1)
                        return
            }
            s = s.parent
        }
        const l = t.appContext.config.errorHandler;
        if (l) {
            Kn(l, null, 10, [e, o, a]);
            return
        }
    }
    sS(e, n, i, r)
}
function sS(e, t, n, r=!0) {
    console.error(e)
}
let Rs = !1
    , nc = !1;
const Tt = [];
let Mn = 0;
const Ti = [];
let Un = null
    , Lr = 0;
const Km = Promise.resolve();
let Ru = null;
function ct(e) {
    const t = Ru || Km;
    return e ? t.then(this ? e.bind(this) : e) : t
}
function oS(e) {
    let t = Mn + 1
        , n = Tt.length;
    for (; t < n; ) {
        const r = t + n >>> 1;
        Ls(Tt[r]) < e ? t = r + 1 : n = r
    }
    return t
}
function Na(e) {
    (!Tt.length || !Tt.includes(e, Rs && e.allowRecurse ? Mn + 1 : Mn)) && (e.id == null ? Tt.push(e) : Tt.splice(oS(e.id), 0, e),
        Ym())
}
function Ym() {
    !Rs && !nc && (nc = !0,
        Ru = Km.then(qm))
}
function aS(e) {
    const t = Tt.indexOf(e);
    t > Mn && Tt.splice(t, 1)
}
function Lu(e) {
    be(e) ? Ti.push(...e) : (!Un || !Un.includes(e, e.allowRecurse ? Lr + 1 : Lr)) && Ti.push(e),
        Ym()
}
function rd(e, t=Rs ? Mn + 1 : 0) {
    for (; t < Tt.length; t++) {
        const n = Tt[t];
        n && n.pre && (Tt.splice(t, 1),
            t--,
            n())
    }
}
function na(e) {
    if (Ti.length) {
        const t = [...new Set(Ti)];
        if (Ti.length = 0,
            Un) {
            Un.push(...t);
            return
        }
        for (Un = t,
                 Un.sort((n,r)=>Ls(n) - Ls(r)),
                 Lr = 0; Lr < Un.length; Lr++)
            Un[Lr]();
        Un = null,
            Lr = 0
    }
}
const Ls = e=>e.id == null ? 1 / 0 : e.id
    , lS = (e,t)=>{
        const n = Ls(e) - Ls(t);
        if (n === 0) {
            if (e.pre && !t.pre)
                return -1;
            if (t.pre && !e.pre)
                return 1
        }
        return n
    }
;
function qm(e) {
    nc = !1,
        Rs = !0,
        Tt.sort(lS);
    const t = Sn;
    try {
        for (Mn = 0; Mn < Tt.length; Mn++) {
            const n = Tt[Mn];
            n && n.active !== !1 && Kn(n, null, 14)
        }
    } finally {
        Mn = 0,
            Tt.length = 0,
            na(),
            Rs = !1,
            Ru = null,
        (Tt.length || Ti.length) && qm()
    }
}
let hi, ho = [];
function Jm(e, t) {
    var n, r;
    hi = e,
        hi ? (hi.enabled = !0,
            ho.forEach(({event: i, args: s})=>hi.emit(i, ...s)),
            ho = []) : typeof window < "u" && window.HTMLElement && !((r = (n = window.navigator) == null ? void 0 : n.userAgent) != null && r.includes("jsdom")) ? ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push(s=>{
                Jm(s, t)
            }
        ),
            setTimeout(()=>{
                    hi || (t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null,
                        ho = [])
                }
                , 3e3)) : ho = []
}
function cS(e, t, ...n) {
    if (e.isUnmounted)
        return;
    const r = e.vnode.props || Ye;
    let i = n;
    const s = t.startsWith("update:")
        , o = s && t.slice(7);
    if (o && o in r) {
        const u = `${o === "modelValue" ? "model" : o}Modifiers`
            , {number: f, trim: d} = r[u] || Ye;
        d && (i = n.map(h=>rt(h) ? h.trim() : h)),
        f && (i = n.map(Qo))
    }
    let a, l = r[a = ms(t)] || r[a = ms(Gt(t))];
    !l && s && (l = r[a = ms(cn(t))]),
    l && tn(l, e, 6, i);
    const c = r[a + "Once"];
    if (c) {
        if (!e.emitted)
            e.emitted = {};
        else if (e.emitted[a])
            return;
        e.emitted[a] = !0,
            tn(c, e, 6, i)
    }
}
function Zm(e, t, n=!1) {
    const r = t.emitsCache
        , i = r.get(e);
    if (i !== void 0)
        return i;
    const s = e.emits;
    let o = {}
        , a = !1;
    if (!Le(e)) {
        const l = c=>{
                const u = Zm(c, t, !0);
                u && (a = !0,
                    Ze(o, u))
            }
        ;
        !n && t.mixins.length && t.mixins.forEach(l),
        e.extends && l(e.extends),
        e.mixins && e.mixins.forEach(l)
    }
    return !s && !a ? (qe(e) && r.set(e, null),
        null) : (be(s) ? s.forEach(l=>o[l] = null) : Ze(o, s),
    qe(e) && r.set(e, o),
        o)
}
function $a(e, t) {
    return !e || !Ks(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""),
    He(e, t[0].toLowerCase() + t.slice(1)) || He(e, cn(t)) || He(e, t))
}
let St = null
    , Fa = null;
function Os(e) {
    const t = St;
    return St = e,
        Fa = e && e.type.__scopeId || null,
        t
}
function uS(e) {
    Fa = e
}
function fS() {
    Fa = null
}
const dS = e=>mt;
function mt(e, t=St, n) {
    if (!t || e._n)
        return e;
    const r = (...i)=>{
            r._d && uc(-1);
            const s = Os(t);
            let o;
            try {
                o = e(...i)
            } finally {
                Os(s),
                r._d && uc(1)
            }
            return o
        }
    ;
    return r._n = !0,
        r._c = !0,
        r._d = !0,
        r
}
function $o(e) {
    const {type: t, vnode: n, proxy: r, withProxy: i, props: s, propsOptions: [o], slots: a, attrs: l, emit: c, render: u, renderCache: f, data: d, setupState: h, ctx: y, inheritAttrs: p} = e;
    let w, m;
    const g = Os(e);
    try {
        if (n.shapeFlag & 4) {
            const v = i || r;
            w = Qt(u.call(v, v, f, s, h, d, y)),
                m = l
        } else {
            const v = t;
            w = Qt(v.length > 1 ? v(s, {
                attrs: l,
                slots: a,
                emit: c
            }) : v(s, null)),
                m = t.props ? l : hS(l)
        }
    } catch (v) {
        ys.length = 0,
            qr(v, e, 1),
            w = Re(kt)
    }
    let b = w;
    if (m && p !== !1) {
        const v = Object.keys(m)
            , {shapeFlag: S} = b;
        v.length && S & 7 && (o && v.some(gu) && (m = mS(m, o)),
            b = Tn(b, m))
    }
    return n.dirs && (b = Tn(b),
        b.dirs = b.dirs ? b.dirs.concat(n.dirs) : n.dirs),
    n.transition && (b.transition = n.transition),
        w = b,
        Os(g),
        w
}
function pS(e) {
    let t;
    for (let n = 0; n < e.length; n++) {
        const r = e[n];
        if (yr(r)) {
            if (r.type !== kt || r.children === "v-if") {
                if (t)
                    return;
                t = r
            }
        } else
            return
    }
    return t
}
const hS = e=>{
        let t;
        for (const n in e)
            (n === "class" || n === "style" || Ks(n)) && ((t || (t = {}))[n] = e[n]);
        return t
    }
    , mS = (e,t)=>{
        const n = {};
        for (const r in e)
            (!gu(r) || !(r.slice(9)in t)) && (n[r] = e[r]);
        return n
    }
;
function gS(e, t, n) {
    const {props: r, children: i, component: s} = e
        , {props: o, children: a, patchFlag: l} = t
        , c = s.emitsOptions;
    if (t.dirs || t.transition)
        return !0;
    if (n && l >= 0) {
        if (l & 1024)
            return !0;
        if (l & 16)
            return r ? id(r, o, c) : !!o;
        if (l & 8) {
            const u = t.dynamicProps;
            for (let f = 0; f < u.length; f++) {
                const d = u[f];
                if (o[d] !== r[d] && !$a(c, d))
                    return !0
            }
        }
    } else
        return (i || a) && (!a || !a.$stable) ? !0 : r === o ? !1 : r ? o ? id(r, o, c) : !0 : !!o;
    return !1
}
function id(e, t, n) {
    const r = Object.keys(t);
    if (r.length !== Object.keys(e).length)
        return !0;
    for (let i = 0; i < r.length; i++) {
        const s = r[i];
        if (t[s] !== e[s] && !$a(n, s))
            return !0
    }
    return !1
}
function Ou({vnode: e, parent: t}, n) {
    for (; t && t.subTree === e; )
        (e = t.vnode).el = n,
            t = t.parent
}
const Qm = e=>e.__isSuspense
    , vS = {
    name: "Suspense",
    __isSuspense: !0,
    process(e, t, n, r, i, s, o, a, l, c) {
        e == null ? yS(t, n, r, i, s, o, a, l, c) : bS(e, t, n, r, i, o, a, l, c)
    },
    hydrate: wS,
    create: Au,
    normalize: SS
}
    , ja = vS;
function As(e, t) {
    const n = e.props && e.props[t];
    Le(n) && n()
}
function yS(e, t, n, r, i, s, o, a, l) {
    const {p: c, o: {createElement: u}} = l
        , f = u("div")
        , d = e.suspense = Au(e, i, r, t, f, n, s, o, a, l);
    c(null, d.pendingBranch = e.ssContent, f, null, r, d, s, o),
        d.deps > 0 ? (As(e, "onPending"),
            As(e, "onFallback"),
            c(null, e.ssFallback, t, n, r, null, s, o),
            xi(d, e.ssFallback)) : d.resolve(!1, !0)
}
function bS(e, t, n, r, i, s, o, a, {p: l, um: c, o: {createElement: u}}) {
    const f = t.suspense = e.suspense;
    f.vnode = t,
        t.el = e.el;
    const d = t.ssContent
        , h = t.ssFallback
        , {activeBranch: y, pendingBranch: p, isInFallback: w, isHydrating: m} = f;
    if (p)
        f.pendingBranch = d,
            bn(d, p) ? (l(p, d, f.hiddenContainer, null, i, f, s, o, a),
                f.deps <= 0 ? f.resolve() : w && (l(y, h, n, r, i, null, s, o, a),
                    xi(f, h))) : (f.pendingId++,
                m ? (f.isHydrating = !1,
                    f.activeBranch = p) : c(p, i, f),
                f.deps = 0,
                f.effects.length = 0,
                f.hiddenContainer = u("div"),
                w ? (l(null, d, f.hiddenContainer, null, i, f, s, o, a),
                    f.deps <= 0 ? f.resolve() : (l(y, h, n, r, i, null, s, o, a),
                        xi(f, h))) : y && bn(d, y) ? (l(y, d, n, r, i, f, s, o, a),
                    f.resolve(!0)) : (l(null, d, f.hiddenContainer, null, i, f, s, o, a),
                f.deps <= 0 && f.resolve()));
    else if (y && bn(d, y))
        l(y, d, n, r, i, f, s, o, a),
            xi(f, d);
    else if (As(t, "onPending"),
        f.pendingBranch = d,
        f.pendingId++,
        l(null, d, f.hiddenContainer, null, i, f, s, o, a),
    f.deps <= 0)
        f.resolve();
    else {
        const {timeout: g, pendingId: b} = f;
        g > 0 ? setTimeout(()=>{
                f.pendingId === b && f.fallback(h)
            }
            , g) : g === 0 && f.fallback(h)
    }
}
function Au(e, t, n, r, i, s, o, a, l, c, u=!1) {
    const {p: f, m: d, um: h, n: y, o: {parentNode: p, remove: w}} = c;
    let m;
    const g = _S(e);
    g && t != null && t.pendingBranch && (m = t.pendingId,
        t.deps++);
    const b = e.props ? ea(e.props.timeout) : void 0
        , v = {
        vnode: e,
        parent: t,
        parentComponent: n,
        isSVG: o,
        container: r,
        hiddenContainer: i,
        anchor: s,
        deps: 0,
        pendingId: 0,
        timeout: typeof b == "number" ? b : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: !0,
        isHydrating: u,
        isUnmounted: !1,
        effects: [],
        resolve(S=!1, _=!1) {
            const {vnode: E, activeBranch: T, pendingBranch: P, pendingId: I, effects: L, parentComponent: x, container: A} = v;
            if (v.isHydrating)
                v.isHydrating = !1;
            else if (!S) {
                const N = T && P.transition && P.transition.mode === "out-in";
                N && (T.transition.afterLeave = ()=>{
                        I === v.pendingId && d(P, A, D, 0)
                    }
                );
                let {anchor: D} = v;
                T && (D = y(T),
                    h(T, x, v, !0)),
                N || d(P, A, D, 0)
            }
            xi(v, P),
                v.pendingBranch = null,
                v.isInFallback = !1;
            let k = v.parent
                , O = !1;
            for (; k; ) {
                if (k.pendingBranch) {
                    k.effects.push(...L),
                        O = !0;
                    break
                }
                k = k.parent
            }
            O || Lu(L),
                v.effects = [],
            g && t && t.pendingBranch && m === t.pendingId && (t.deps--,
            t.deps === 0 && !_ && t.resolve()),
                As(E, "onResolve")
        },
        fallback(S) {
            if (!v.pendingBranch)
                return;
            const {vnode: _, activeBranch: E, parentComponent: T, container: P, isSVG: I} = v;
            As(_, "onFallback");
            const L = y(E)
                , x = ()=>{
                v.isInFallback && (f(null, S, P, L, T, null, I, a, l),
                    xi(v, S))
            }
                , A = S.transition && S.transition.mode === "out-in";
            A && (E.transition.afterLeave = x),
                v.isInFallback = !0,
                h(E, T, null, !0),
            A || x()
        },
        move(S, _, E) {
            v.activeBranch && d(v.activeBranch, S, _, E),
                v.container = S
        },
        next() {
            return v.activeBranch && y(v.activeBranch)
        },
        registerDep(S, _) {
            const E = !!v.pendingBranch;
            E && v.deps++;
            const T = S.vnode.el;
            S.asyncDep.catch(P=>{
                    qr(P, S, 0)
                }
            ).then(P=>{
                    if (S.isUnmounted || v.isUnmounted || v.pendingId !== S.suspenseId)
                        return;
                    S.asyncResolved = !0;
                    const {vnode: I} = S;
                    fc(S, P, !1),
                    T && (I.el = T);
                    const L = !T && S.subTree.el;
                    _(S, I, p(T || S.subTree.el), T ? null : y(S.subTree), v, o, l),
                    L && w(L),
                        Ou(S, I.el),
                    E && --v.deps === 0 && v.resolve()
                }
            )
        },
        unmount(S, _) {
            v.isUnmounted = !0,
            v.activeBranch && h(v.activeBranch, n, S, _),
            v.pendingBranch && h(v.pendingBranch, n, S, _)
        }
    };
    return v
}
function wS(e, t, n, r, i, s, o, a, l) {
    const c = t.suspense = Au(t, r, n, e.parentNode, document.createElement("div"), null, i, s, o, a, !0)
        , u = l(e, c.pendingBranch = t.ssContent, n, c, s, o);
    return c.deps === 0 && c.resolve(!1, !0),
        u
}
function SS(e) {
    const {shapeFlag: t, children: n} = e
        , r = t & 32;
    e.ssContent = sd(r ? n.default : n),
        e.ssFallback = r ? sd(n.fallback) : Re(kt)
}
function sd(e) {
    let t;
    if (Le(e)) {
        const n = zr && e._c;
        n && (e._d = !1,
            Ae()),
            e = e(),
        n && (e._d = !0,
            t = Ut,
            Rg())
    }
    return be(e) && (e = pS(e)),
        e = Qt(e),
    t && !e.dynamicChildren && (e.dynamicChildren = t.filter(n=>n !== e)),
        e
}
function eg(e, t) {
    t && t.pendingBranch ? be(e) ? t.effects.push(...e) : t.effects.push(e) : Lu(e)
}
function xi(e, t) {
    e.activeBranch = t;
    const {vnode: n, parentComponent: r} = e
        , i = n.el = t.el;
    r && r.subTree === n && (r.vnode.el = i,
        Ou(r, i))
}
function _S(e) {
    var t;
    return ((t = e.props) == null ? void 0 : t.suspensible) != null && e.props.suspensible !== !1
}
function Er(e, t) {
    return Js(e, null, t)
}
function tg(e, t) {
    return Js(e, null, {
        flush: "post"
    })
}
function ES(e, t) {
    return Js(e, null, {
        flush: "sync"
    })
}
const mo = {};
function Se(e, t, n) {
    return Js(e, t, n)
}
function Js(e, t, {immediate: n, deep: r, flush: i, onTrack: s, onTrigger: o}=Ye) {
    var a;
    const l = Su() === ((a = ft) == null ? void 0 : a.scope) ? ft : null;
    let c, u = !1, f = !1;
    if (Je(e) ? (c = ()=>e.value,
        u = Ps(e)) : Nr(e) ? (c = ()=>e,
        r = !0) : be(e) ? (f = !0,
        u = e.some(v=>Nr(v) || Ps(v)),
        c = ()=>e.map(v=>{
                if (Je(v))
                    return v.value;
                if (Nr(v))
                    return Ir(v);
                if (Le(v))
                    return Kn(v, l, 2)
            }
        )) : Le(e) ? t ? c = ()=>Kn(e, l, 2) : c = ()=>{
            if (!(l && l.isUnmounted))
                return d && d(),
                    tn(e, l, 3, [h])
        }
        : c = Sn,
    t && r) {
        const v = c;
        c = ()=>Ir(v())
    }
    let d, h = v=>{
        d = g.onStop = ()=>{
            Kn(v, l, 4)
        }
    }
        , y;
    if (Oi)
        if (h = Sn,
            t ? n && tn(t, l, 3, [c(), f ? [] : void 0, h]) : c(),
        i === "sync") {
            const v = jg();
            y = v.__watcherHandles || (v.__watcherHandles = [])
        } else
            return Sn;
    let p = f ? new Array(e.length).fill(mo) : mo;
    const w = ()=>{
            if (g.active)
                if (t) {
                    const v = g.run();
                    (r || u || (f ? v.some((S,_)=>ki(S, p[_])) : ki(v, p))) && (d && d(),
                        tn(t, l, 3, [v, p === mo ? void 0 : f && p[0] === mo ? [] : p, h]),
                        p = v)
                } else
                    g.run()
        }
    ;
    w.allowRecurse = !!t;
    let m;
    i === "sync" ? m = w : i === "post" ? m = ()=>_t(w, l && l.suspense) : (w.pre = !0,
    l && (w.id = l.uid),
        m = ()=>Na(w));
    const g = new qs(c,m);
    t ? n ? w() : p = g.run() : i === "post" ? _t(g.run.bind(g), l && l.suspense) : g.run();
    const b = ()=>{
            g.stop(),
            l && l.scope && vu(l.scope.effects, g)
        }
    ;
    return y && y.push(b),
        b
}
function CS(e, t, n) {
    const r = this.proxy
        , i = rt(e) ? e.includes(".") ? ng(r, e) : ()=>r[e] : e.bind(r, r);
    let s;
    Le(t) ? s = t : (s = t.handler,
        n = t);
    const o = ft;
    br(this);
    const a = Js(i, s.bind(r), n);
    return o ? br(o) : dr(),
        a
}
function ng(e, t) {
    const n = t.split(".");
    return ()=>{
        let r = e;
        for (let i = 0; i < n.length && r; i++)
            r = r[n[i]];
        return r
    }
}
function Ir(e, t) {
    if (!qe(e) || e.__v_skip || (t = t || new Set,
        t.has(e)))
        return e;
    if (t.add(e),
        Je(e))
        Ir(e.value, t);
    else if (be(e))
        for (let n = 0; n < e.length; n++)
            Ir(e[n], t);
    else if (Yr(e) || Ei(e))
        e.forEach(n=>{
                Ir(n, t)
            }
        );
    else if (km(e))
        for (const n in e)
            Ir(e[n], t);
    return e
}
function TS(e, t) {
    const n = St;
    if (n === null)
        return e;
    const r = Ga(n) || n.proxy
        , i = e.dirs || (e.dirs = []);
    for (let s = 0; s < t.length; s++) {
        let[o,a,l,c=Ye] = t[s];
        o && (Le(o) && (o = {
            mounted: o,
            updated: o
        }),
        o.deep && Ir(a),
            i.push({
                dir: o,
                instance: r,
                value: a,
                oldValue: void 0,
                arg: l,
                modifiers: c
            }))
    }
    return e
}
function An(e, t, n, r) {
    const i = e.dirs
        , s = t && t.dirs;
    for (let o = 0; o < i.length; o++) {
        const a = i[o];
        s && (a.oldValue = s[o].value);
        let l = a.dir[r];
        l && (Vi(),
            tn(l, n, 8, [e.el, a, e, t]),
            zi())
    }
}
function Iu() {
    const e = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return Ve(()=>{
            e.isMounted = !0
        }
    ),
        za(()=>{
                e.isUnmounting = !0
            }
        ),
        e
}
const on = [Function, Array]
    , Mu = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: on,
    onEnter: on,
    onAfterEnter: on,
    onEnterCancelled: on,
    onBeforeLeave: on,
    onLeave: on,
    onAfterLeave: on,
    onLeaveCancelled: on,
    onBeforeAppear: on,
    onAppear: on,
    onAfterAppear: on,
    onAppearCancelled: on
}
    , xS = {
    name: "BaseTransition",
    props: Mu,
    setup(e, {slots: t}) {
        const n = Ot()
            , r = Iu();
        let i;
        return ()=>{
            const s = t.default && Ha(t.default(), !0);
            if (!s || !s.length)
                return;
            let o = s[0];
            if (s.length > 1) {
                for (const p of s)
                    if (p.type !== kt) {
                        o = p;
                        break
                    }
            }
            const a = ke(e)
                , {mode: l} = a;
            if (r.isLeaving)
                return gl(o);
            const c = od(o);
            if (!c)
                return gl(o);
            const u = Li(c, a, r, n);
            Vr(c, u);
            const f = n.subTree
                , d = f && od(f);
            let h = !1;
            const {getTransitionKey: y} = c.type;
            if (y) {
                const p = y();
                i === void 0 ? i = p : p !== i && (i = p,
                    h = !0)
            }
            if (d && d.type !== kt && (!bn(c, d) || h)) {
                const p = Li(d, a, r, n);
                if (Vr(d, p),
                l === "out-in")
                    return r.isLeaving = !0,
                        p.afterLeave = ()=>{
                            r.isLeaving = !1,
                            n.update.active !== !1 && n.update()
                        }
                        ,
                        gl(o);
                l === "in-out" && c.type !== kt && (p.delayLeave = (w,m,g)=>{
                        const b = ig(r, d);
                        b[String(d.key)] = d,
                            w._leaveCb = ()=>{
                                m(),
                                    w._leaveCb = void 0,
                                    delete u.delayedLeave
                            }
                            ,
                            u.delayedLeave = g
                    }
                )
            }
            return o
        }
    }
}
    , rg = xS;
function ig(e, t) {
    const {leavingVNodes: n} = e;
    let r = n.get(t.type);
    return r || (r = Object.create(null),
        n.set(t.type, r)),
        r
}
function Li(e, t, n, r) {
    const {appear: i, mode: s, persisted: o=!1, onBeforeEnter: a, onEnter: l, onAfterEnter: c, onEnterCancelled: u, onBeforeLeave: f, onLeave: d, onAfterLeave: h, onLeaveCancelled: y, onBeforeAppear: p, onAppear: w, onAfterAppear: m, onAppearCancelled: g} = t
        , b = String(e.key)
        , v = ig(n, e)
        , S = (T,P)=>{
        T && tn(T, r, 9, P)
    }
        , _ = (T,P)=>{
        const I = P[1];
        S(T, P),
            be(T) ? T.every(L=>L.length <= 1) && I() : T.length <= 1 && I()
    }
        , E = {
        mode: s,
        persisted: o,
        beforeEnter(T) {
            let P = a;
            if (!n.isMounted)
                if (i)
                    P = p || a;
                else
                    return;
            T._leaveCb && T._leaveCb(!0);
            const I = v[b];
            I && bn(e, I) && I.el._leaveCb && I.el._leaveCb(),
                S(P, [T])
        },
        enter(T) {
            let P = l
                , I = c
                , L = u;
            if (!n.isMounted)
                if (i)
                    P = w || l,
                        I = m || c,
                        L = g || u;
                else
                    return;
            let x = !1;
            const A = T._enterCb = k=>{
                    x || (x = !0,
                        k ? S(L, [T]) : S(I, [T]),
                    E.delayedLeave && E.delayedLeave(),
                        T._enterCb = void 0)
                }
            ;
            P ? _(P, [T, A]) : A()
        },
        leave(T, P) {
            const I = String(e.key);
            if (T._enterCb && T._enterCb(!0),
                n.isUnmounting)
                return P();
            S(f, [T]);
            let L = !1;
            const x = T._leaveCb = A=>{
                    L || (L = !0,
                        P(),
                        A ? S(y, [T]) : S(h, [T]),
                        T._leaveCb = void 0,
                    v[I] === e && delete v[I])
                }
            ;
            v[I] = e,
                d ? _(d, [T, x]) : x()
        },
        clone(T) {
            return Li(T, t, n, r)
        }
    };
    return E
}
function gl(e) {
    if (Zs(e))
        return e = Tn(e),
            e.children = null,
            e
}
function od(e) {
    return Zs(e) ? e.children ? e.children[0] : void 0 : e
}
function Vr(e, t) {
    e.shapeFlag & 6 && e.component ? Vr(e.component.subTree, t) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent),
        e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t
}
function Ha(e, t=!1, n) {
    let r = []
        , i = 0;
    for (let s = 0; s < e.length; s++) {
        let o = e[s];
        const a = n == null ? o.key : String(n) + String(o.key != null ? o.key : s);
        o.type === nt ? (o.patchFlag & 128 && i++,
            r = r.concat(Ha(o.children, t, a))) : (t || o.type !== kt) && r.push(a != null ? Tn(o, {
            key: a
        }) : o)
    }
    if (i > 1)
        for (let s = 0; s < r.length; s++)
            r[s].patchFlag = -2;
    return r
}
function Xe(e, t) {
    return Le(e) ? (()=>Ze({
        name: e.name
    }, t, {
        setup: e
    }))() : e
}
const $r = e=>!!e.type.__asyncLoader;
function PS(e) {
    Le(e) && (e = {
        loader: e
    });
    const {loader: t, loadingComponent: n, errorComponent: r, delay: i=200, timeout: s, suspensible: o=!0, onError: a} = e;
    let l = null, c, u = 0;
    const f = ()=>(u++,
            l = null,
            d())
        , d = ()=>{
            let h;
            return l || (h = l = t().catch(y=>{
                    if (y = y instanceof Error ? y : new Error(String(y)),
                        a)
                        return new Promise((p,w)=>{
                                a(y, ()=>p(f()), ()=>w(y), u + 1)
                            }
                        );
                    throw y
                }
            ).then(y=>h !== l && l ? l : (y && (y.__esModule || y[Symbol.toStringTag] === "Module") && (y = y.default),
                c = y,
                y)))
        }
    ;
    return Xe({
        name: "AsyncComponentWrapper",
        __asyncLoader: d,
        get __asyncResolved() {
            return c
        },
        setup() {
            const h = ft;
            if (c)
                return ()=>vl(c, h);
            const y = g=>{
                    l = null,
                        qr(g, h, 13, !r)
                }
            ;
            if (o && h.suspense || Oi)
                return d().then(g=>()=>vl(g, h)).catch(g=>(y(g),
                    ()=>r ? Re(r, {
                        error: g
                    }) : null));
            const p = X(!1)
                , w = X()
                , m = X(!!i);
            return i && setTimeout(()=>{
                    m.value = !1
                }
                , i),
            s != null && setTimeout(()=>{
                    if (!p.value && !w.value) {
                        const g = new Error(`Async component timed out after ${s}ms.`);
                        y(g),
                            w.value = g
                    }
                }
                , s),
                d().then(()=>{
                        p.value = !0,
                        h.parent && Zs(h.parent.vnode) && Na(h.parent.update)
                    }
                ).catch(g=>{
                        y(g),
                            w.value = g
                    }
                ),
                ()=>{
                    if (p.value && c)
                        return vl(c, h);
                    if (w.value && r)
                        return Re(r, {
                            error: w.value
                        });
                    if (n && !m.value)
                        return Re(n)
                }
        }
    })
}
function vl(e, t) {
    const {ref: n, props: r, children: i, ce: s} = t.vnode
        , o = Re(e, r, i);
    return o.ref = n,
        o.ce = s,
        delete t.vnode.ce,
        o
}
const Zs = e=>e.type.__isKeepAlive
    , kS = {
    name: "KeepAlive",
    __isKeepAlive: !0,
    props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
    },
    setup(e, {slots: t}) {
        const n = Ot()
            , r = n.ctx;
        if (!r.renderer)
            return ()=>{
                const g = t.default && t.default();
                return g && g.length === 1 ? g[0] : g
            }
                ;
        const i = new Map
            , s = new Set;
        let o = null;
        const a = n.suspense
            , {renderer: {p: l, m: c, um: u, o: {createElement: f}}} = r
            , d = f("div");
        r.activate = (g,b,v,S,_)=>{
            const E = g.component;
            c(g, b, v, 0, a),
                l(E.vnode, g, b, v, E, a, S, g.slotScopeIds, _),
                _t(()=>{
                        E.isDeactivated = !1,
                        E.a && Ci(E.a);
                        const T = g.props && g.props.onVnodeMounted;
                        T && Bt(T, E.parent, g)
                    }
                    , a)
        }
            ,
            r.deactivate = g=>{
                const b = g.component;
                c(g, d, null, 1, a),
                    _t(()=>{
                            b.da && Ci(b.da);
                            const v = g.props && g.props.onVnodeUnmounted;
                            v && Bt(v, b.parent, g),
                                b.isDeactivated = !0
                        }
                        , a)
            }
        ;
        function h(g) {
            yl(g),
                u(g, n, a, !0)
        }
        function y(g) {
            i.forEach((b,v)=>{
                    const S = pc(b.type);
                    S && (!g || !g(S)) && p(v)
                }
            )
        }
        function p(g) {
            const b = i.get(g);
            !o || !bn(b, o) ? h(b) : o && yl(o),
                i.delete(g),
                s.delete(g)
        }
        Se(()=>[e.include, e.exclude], ([g,b])=>{
                g && y(v=>cs(g, v)),
                b && y(v=>!cs(b, v))
            }
            , {
                flush: "post",
                deep: !0
            });
        let w = null;
        const m = ()=>{
                w != null && i.set(w, bl(n.subTree))
            }
        ;
        return Ve(m),
            Va(m),
            za(()=>{
                    i.forEach(g=>{
                            const {subTree: b, suspense: v} = n
                                , S = bl(b);
                            if (g.type === S.type && g.key === S.key) {
                                yl(S);
                                const _ = S.component.da;
                                _ && _t(_, v);
                                return
                            }
                            h(g)
                        }
                    )
                }
            ),
            ()=>{
                if (w = null,
                    !t.default)
                    return null;
                const g = t.default()
                    , b = g[0];
                if (g.length > 1)
                    return o = null,
                        g;
                if (!yr(b) || !(b.shapeFlag & 4) && !(b.shapeFlag & 128))
                    return o = null,
                        b;
                let v = bl(b);
                const S = v.type
                    , _ = pc($r(v) ? v.type.__asyncResolved || {} : S)
                    , {include: E, exclude: T, max: P} = e;
                if (E && (!_ || !cs(E, _)) || T && _ && cs(T, _))
                    return o = v,
                        b;
                const I = v.key == null ? S : v.key
                    , L = i.get(I);
                return v.el && (v = Tn(v),
                b.shapeFlag & 128 && (b.ssContent = v)),
                    w = I,
                    L ? (v.el = L.el,
                        v.component = L.component,
                    v.transition && Vr(v, v.transition),
                        v.shapeFlag |= 512,
                        s.delete(I),
                        s.add(I)) : (s.add(I),
                    P && s.size > parseInt(P, 10) && p(s.values().next().value)),
                    v.shapeFlag |= 256,
                    o = v,
                    Qm(b.type) ? b : v
            }
    }
}
    , sg = kS;
function cs(e, t) {
    return be(e) ? e.some(n=>cs(n, t)) : rt(e) ? e.split(",").includes(t) : nw(e) ? e.test(t) : !1
}
function og(e, t) {
    lg(e, "a", t)
}
function ag(e, t) {
    lg(e, "da", t)
}
function lg(e, t, n=ft) {
    const r = e.__wdc || (e.__wdc = ()=>{
            let i = n;
            for (; i; ) {
                if (i.isDeactivated)
                    return;
                i = i.parent
            }
            return e()
        }
    );
    if (Ba(t, r, n),
        n) {
        let i = n.parent;
        for (; i && i.parent; )
            Zs(i.parent.vnode) && RS(r, t, n, i),
                i = i.parent
    }
}
function RS(e, t, n, r) {
    const i = Ba(t, e, r, !0);
    Kt(()=>{
            vu(r[t], i)
        }
        , n)
}
function yl(e) {
    e.shapeFlag &= -257,
        e.shapeFlag &= -513
}
function bl(e) {
    return e.shapeFlag & 128 ? e.ssContent : e
}
function Ba(e, t, n=ft, r=!1) {
    if (n) {
        const i = n[e] || (n[e] = [])
            , s = t.__weh || (t.__weh = (...o)=>{
                if (n.isUnmounted)
                    return;
                Vi(),
                    br(n);
                const a = tn(t, n, e, o);
                return dr(),
                    zi(),
                    a
            }
        );
        return r ? i.unshift(s) : i.push(s),
            s
    }
}
const Jn = e=>(t,n=ft)=>(!Oi || e === "sp") && Ba(e, (...r)=>t(...r), n)
    , cg = Jn("bm")
    , Ve = Jn("m")
    , ug = Jn("bu")
    , Va = Jn("u")
    , za = Jn("bum")
    , Kt = Jn("um")
    , fg = Jn("sp")
    , dg = Jn("rtg")
    , pg = Jn("rtc");
function Du(e, t=ft) {
    Ba("ec", e, t)
}
const Nu = "components"
    , LS = "directives";
function hg(e, t) {
    return Fu(Nu, e, !0, t) || e
}
const mg = Symbol.for("v-ndc");
function $u(e) {
    return rt(e) ? Fu(Nu, e, !1) || e : e || mg
}
function OS(e) {
    return Fu(LS, e)
}
function Fu(e, t, n=!0, r=!1) {
    const i = St || ft;
    if (i) {
        const s = i.type;
        if (e === Nu) {
            const a = pc(s, !1);
            if (a && (a === t || a === Gt(t) || a === Ys(Gt(t))))
                return s
        }
        const o = ad(i[e] || s[e], t) || ad(i.appContext[e], t);
        return !o && r ? s : o
    }
}
function ad(e, t) {
    return e && (e[t] || e[Gt(t)] || e[Ys(Gt(t))])
}
function ju(e, t, n, r) {
    let i;
    const s = n && n[r];
    if (be(e) || rt(e)) {
        i = new Array(e.length);
        for (let o = 0, a = e.length; o < a; o++)
            i[o] = t(e[o], o, void 0, s && s[o])
    } else if (typeof e == "number") {
        i = new Array(e);
        for (let o = 0; o < e; o++)
            i[o] = t(o + 1, o, void 0, s && s[o])
    } else if (qe(e))
        if (e[Symbol.iterator])
            i = Array.from(e, (o,a)=>t(o, a, void 0, s && s[a]));
        else {
            const o = Object.keys(e);
            i = new Array(o.length);
            for (let a = 0, l = o.length; a < l; a++) {
                const c = o[a];
                i[a] = t(e[c], c, a, s && s[a])
            }
        }
    else
        i = [];
    return n && (n[r] = i),
        i
}
function AS(e, t) {
    for (let n = 0; n < t.length; n++) {
        const r = t[n];
        if (be(r))
            for (let i = 0; i < r.length; i++)
                e[r[i].name] = r[i].fn;
        else
            r && (e[r.name] = r.key ? (...i)=>{
                    const s = r.fn(...i);
                    return s && (s.key = r.key),
                        s
                }
                : r.fn)
    }
    return e
}
function Wi(e, t, n={}, r, i) {
    if (St.isCE || St.parent && $r(St.parent) && St.parent.isCE)
        return t !== "default" && (n.name = t),
            Re("slot", n, r && r());
    let s = e[t];
    s && s._c && (s._d = !1),
        Ae();
    const o = s && gg(s(n))
        , a = gt(nt, {
        key: n.key || o && o.key || `_ ${t}`
    }, o || (r ? r() : []), o && e._ === 1 ? 64 : -2);
    return !i && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]),
    s && s._c && (s._d = !0),
        a
}
function gg(e) {
    return e.some(t=>yr(t) ? !(t.type === kt || t.type === nt && !gg(t.children)) : !0) ? e : null
}
function IS(e, t) {
    const n = {};
    for (const r in e)
        n[t && /[A-Z]/.test(r) ? `on:${r}` : ms(r)] = e[r];
    return n
}
const rc = e=>e ? Mg(e) ? Ga(e) || e.proxy : rc(e.parent) : null
    , gs = Ze(Object.create(null), {
    $: e=>e,
    $el: e=>e.vnode.el,
    $data: e=>e.data,
    $props: e=>e.props,
    $attrs: e=>e.attrs,
    $slots: e=>e.slots,
    $refs: e=>e.refs,
    $parent: e=>rc(e.parent),
    $root: e=>rc(e.root),
    $emit: e=>e.emit,
    $options: e=>Hu(e),
    $forceUpdate: e=>e.f || (e.f = ()=>Na(e.update)),
    $nextTick: e=>e.n || (e.n = ct.bind(e.proxy)),
    $watch: e=>CS.bind(e)
})
    , wl = (e,t)=>e !== Ye && !e.__isScriptSetup && He(e, t)
    , ic = {
    get({_: e}, t) {
        const {ctx: n, setupState: r, data: i, props: s, accessCache: o, type: a, appContext: l} = e;
        let c;
        if (t[0] !== "$") {
            const h = o[t];
            if (h !== void 0)
                switch (h) {
                    case 1:
                        return r[t];
                    case 2:
                        return i[t];
                    case 4:
                        return n[t];
                    case 3:
                        return s[t]
                }
            else {
                if (wl(r, t))
                    return o[t] = 1,
                        r[t];
                if (i !== Ye && He(i, t))
                    return o[t] = 2,
                        i[t];
                if ((c = e.propsOptions[0]) && He(c, t))
                    return o[t] = 3,
                        s[t];
                if (n !== Ye && He(n, t))
                    return o[t] = 4,
                        n[t];
                sc && (o[t] = 0)
            }
        }
        const u = gs[t];
        let f, d;
        if (u)
            return t === "$attrs" && Xt(e, "get", t),
                u(e);
        if ((f = a.__cssModules) && (f = f[t]))
            return f;
        if (n !== Ye && He(n, t))
            return o[t] = 4,
                n[t];
        if (d = l.config.globalProperties,
            He(d, t))
            return d[t]
    },
    set({_: e}, t, n) {
        const {data: r, setupState: i, ctx: s} = e;
        return wl(i, t) ? (i[t] = n,
            !0) : r !== Ye && He(r, t) ? (r[t] = n,
            !0) : He(e.props, t) || t[0] === "$" && t.slice(1)in e ? !1 : (s[t] = n,
            !0)
    },
    has({_: {data: e, setupState: t, accessCache: n, ctx: r, appContext: i, propsOptions: s}}, o) {
        let a;
        return !!n[o] || e !== Ye && He(e, o) || wl(t, o) || (a = s[0]) && He(a, o) || He(r, o) || He(gs, o) || He(i.config.globalProperties, o)
    },
    defineProperty(e, t, n) {
        return n.get != null ? e._.accessCache[t] = 0 : He(n, "value") && this.set(e, t, n.value, null),
            Reflect.defineProperty(e, t, n)
    }
}
    , MS = Ze({}, ic, {
    get(e, t) {
        if (t !== Symbol.unscopables)
            return ic.get(e, t, e)
    },
    has(e, t) {
        return t[0] !== "_" && !aw(t)
    }
});
function DS() {
    return null
}
function NS() {
    return null
}
function $S(e) {}
function FS(e) {}
function jS() {
    return null
}
function HS() {}
function BS(e, t) {
    return null
}
function VS() {
    return vg().slots
}
function zS() {
    return vg().attrs
}
function US(e, t, n) {
    const r = Ot();
    if (n && n.local) {
        const i = X(e[t]);
        return Se(()=>e[t], s=>i.value = s),
            Se(i, s=>{
                    s !== e[t] && r.emit(`update:${t}`, s)
                }
            ),
            i
    } else
        return {
            __v_isRef: !0,
            get value() {
                return e[t]
            },
            set value(i) {
                r.emit(`update:${t}`, i)
            }
        }
}
function vg() {
    const e = Ot();
    return e.setupContext || (e.setupContext = $g(e))
}
function Is(e) {
    return be(e) ? e.reduce((t,n)=>(t[n] = null,
        t), {}) : e
}
function WS(e, t) {
    const n = Is(e);
    for (const r in t) {
        if (r.startsWith("__skip"))
            continue;
        let i = n[r];
        i ? be(i) || Le(i) ? i = n[r] = {
            type: i,
            default: t[r]
        } : i.default = t[r] : i === null && (i = n[r] = {
            default: t[r]
        }),
        i && t[`__skip_ ${r}`] && (i.skipFactory = !0)
    }
    return n
}
function GS(e, t) {
    return !e || !t ? e || t : be(e) && be(t) ? e.concat(t) : Ze({}, Is(e), Is(t))
}
function XS(e, t) {
    const n = {};
    for (const r in e)
        t.includes(r) || Object.defineProperty(n, r, {
            enumerable: !0,
            get: ()=>e[r]
        });
    return n
}
function KS(e) {
    const t = Ot();
    let n = e();
    return dr(),
    yu(n) && (n = n.catch(r=>{
            throw br(t),
                r
        }
    )),
        [n, ()=>br(t)]
}
let sc = !0;
function YS(e) {
    const t = Hu(e)
        , n = e.proxy
        , r = e.ctx;
    sc = !1,
    t.beforeCreate && ld(t.beforeCreate, e, "bc");
    const {data: i, computed: s, methods: o, watch: a, provide: l, inject: c, created: u, beforeMount: f, mounted: d, beforeUpdate: h, updated: y, activated: p, deactivated: w, beforeDestroy: m, beforeUnmount: g, destroyed: b, unmounted: v, render: S, renderTracked: _, renderTriggered: E, errorCaptured: T, serverPrefetch: P, expose: I, inheritAttrs: L, components: x, directives: A, filters: k} = t;
    if (c && qS(c, r, null),
        o)
        for (const D in o) {
            const W = o[D];
            Le(W) && (r[D] = W.bind(n))
        }
    if (i) {
        const D = i.call(n, n);
        qe(D) && (e.data = nn(D))
    }
    if (sc = !0,
        s)
        for (const D in s) {
            const W = s[D]
                , G = Le(W) ? W.bind(n, n) : Le(W.get) ? W.get.bind(n, n) : Sn
                , le = !Le(W) && Le(W.set) ? W.set.bind(n) : Sn
                , ge = fe({
                get: G,
                set: le
            });
            Object.defineProperty(r, D, {
                enumerable: !0,
                configurable: !0,
                get: ()=>ge.value,
                set: ye=>ge.value = ye
            })
        }
    if (a)
        for (const D in a)
            yg(a[D], r, n, D);
    if (l) {
        const D = Le(l) ? l.call(n) : l;
        Reflect.ownKeys(D).forEach(W=>{
                Dn(W, D[W])
            }
        )
    }
    u && ld(u, e, "c");
    function N(D, W) {
        be(W) ? W.forEach(G=>D(G.bind(n))) : W && D(W.bind(n))
    }
    if (N(cg, f),
        N(Ve, d),
        N(ug, h),
        N(Va, y),
        N(og, p),
        N(ag, w),
        N(Du, T),
        N(pg, _),
        N(dg, E),
        N(za, g),
        N(Kt, v),
        N(fg, P),
        be(I))
        if (I.length) {
            const D = e.exposed || (e.exposed = {});
            I.forEach(W=>{
                    Object.defineProperty(D, W, {
                        get: ()=>n[W],
                        set: G=>n[W] = G
                    })
                }
            )
        } else
            e.exposed || (e.exposed = {});
    S && e.render === Sn && (e.render = S),
    L != null && (e.inheritAttrs = L),
    x && (e.components = x),
    A && (e.directives = A)
}
function qS(e, t, n=Sn) {
    be(e) && (e = oc(e));
    for (const r in e) {
        const i = e[r];
        let s;
        qe(i) ? "default"in i ? s = vt(i.from || r, i.default, !0) : s = vt(i.from || r) : s = vt(i),
            Je(s) ? Object.defineProperty(t, r, {
                enumerable: !0,
                configurable: !0,
                get: ()=>s.value,
                set: o=>s.value = o
            }) : t[r] = s
    }
}
function ld(e, t, n) {
    tn(be(e) ? e.map(r=>r.bind(t.proxy)) : e.bind(t.proxy), t, n)
}
function yg(e, t, n, r) {
    const i = r.includes(".") ? ng(n, r) : ()=>n[r];
    if (rt(e)) {
        const s = t[e];
        Le(s) && Se(i, s)
    } else if (Le(e))
        Se(i, e.bind(n));
    else if (qe(e))
        if (be(e))
            e.forEach(s=>yg(s, t, n, r));
        else {
            const s = Le(e.handler) ? e.handler.bind(n) : t[e.handler];
            Le(s) && Se(i, s, e)
        }
}
function Hu(e) {
    const t = e.type
        , {mixins: n, extends: r} = t
        , {mixins: i, optionsCache: s, config: {optionMergeStrategies: o}} = e.appContext
        , a = s.get(t);
    let l;
    return a ? l = a : !i.length && !n && !r ? l = t : (l = {},
    i.length && i.forEach(c=>ra(l, c, o, !0)),
        ra(l, t, o)),
    qe(t) && s.set(t, l),
        l
}
function ra(e, t, n, r=!1) {
    const {mixins: i, extends: s} = t;
    s && ra(e, s, n, !0),
    i && i.forEach(o=>ra(e, o, n, !0));
    for (const o in t)
        if (!(r && o === "expose")) {
            const a = JS[o] || n && n[o];
            e[o] = a ? a(e[o], t[o]) : t[o]
        }
    return e
}
const JS = {
    data: cd,
    props: ud,
    emits: ud,
    methods: us,
    computed: us,
    beforeCreate: Mt,
    created: Mt,
    beforeMount: Mt,
    mounted: Mt,
    beforeUpdate: Mt,
    updated: Mt,
    beforeDestroy: Mt,
    beforeUnmount: Mt,
    destroyed: Mt,
    unmounted: Mt,
    activated: Mt,
    deactivated: Mt,
    errorCaptured: Mt,
    serverPrefetch: Mt,
    components: us,
    directives: us,
    watch: QS,
    provide: cd,
    inject: ZS
};
function cd(e, t) {
    return t ? e ? function() {
            return Ze(Le(e) ? e.call(this, this) : e, Le(t) ? t.call(this, this) : t)
        }
        : t : e
}
function ZS(e, t) {
    return us(oc(e), oc(t))
}
function oc(e) {
    if (be(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++)
            t[e[n]] = e[n];
        return t
    }
    return e
}
function Mt(e, t) {
    return e ? [...new Set([].concat(e, t))] : t
}
function us(e, t) {
    return e ? Ze(Object.create(null), e, t) : t
}
function ud(e, t) {
    return e ? be(e) && be(t) ? [...new Set([...e, ...t])] : Ze(Object.create(null), Is(e), Is(t ?? {})) : t
}
function QS(e, t) {
    if (!e)
        return t;
    if (!t)
        return e;
    const n = Ze(Object.create(null), e);
    for (const r in t)
        n[r] = Mt(e[r], t[r]);
    return n
}
function bg() {
    return {
        app: null,
        config: {
            isNativeTag: Q0,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let e_ = 0;
function t_(e, t) {
    return function(r, i=null) {
        Le(r) || (r = Ze({}, r)),
        i != null && !qe(i) && (i = null);
        const s = bg()
            , o = new Set;
        let a = !1;
        const l = s.app = {
            _uid: e_++,
            _component: r,
            _props: i,
            _container: null,
            _context: s,
            _instance: null,
            version: Bg,
            get config() {
                return s.config
            },
            set config(c) {},
            use(c, ...u) {
                return o.has(c) || (c && Le(c.install) ? (o.add(c),
                    c.install(l, ...u)) : Le(c) && (o.add(c),
                    c(l, ...u))),
                    l
            },
            mixin(c) {
                return s.mixins.includes(c) || s.mixins.push(c),
                    l
            },
            component(c, u) {
                return u ? (s.components[c] = u,
                    l) : s.components[c]
            },
            directive(c, u) {
                return u ? (s.directives[c] = u,
                    l) : s.directives[c]
            },
            mount(c, u, f) {
                if (!a) {
                    const d = Re(r, i);
                    return d.appContext = s,
                        u && t ? t(d, c) : e(d, c, f),
                        a = !0,
                        l._container = c,
                        c.__vue_app__ = l,
                    Ga(d.component) || d.component.proxy
                }
            },
            unmount() {
                a && (e(null, l._container),
                    delete l._container.__vue_app__)
            },
            provide(c, u) {
                return s.provides[c] = u,
                    l
            },
            runWithContext(c) {
                Ms = l;
                try {
                    return c()
                } finally {
                    Ms = null
                }
            }
        };
        return l
    }
}
let Ms = null;
function Dn(e, t) {
    if (ft) {
        let n = ft.provides;
        const r = ft.parent && ft.parent.provides;
        r === n && (n = ft.provides = Object.create(r)),
            n[e] = t
    }
}
function vt(e, t, n=!1) {
    const r = ft || St;
    if (r || Ms) {
        const i = r ? r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : Ms._context.provides;
        if (i && e in i)
            return i[e];
        if (arguments.length > 1)
            return n && Le(t) ? t.call(r && r.proxy) : t
    }
}
function Bu() {
    return !!(ft || St || Ms)
}
function n_(e, t, n, r=!1) {
    const i = {}
        , s = {};
    Zo(s, Ua, 1),
        e.propsDefaults = Object.create(null),
        wg(e, t, i, s);
    for (const o in e.propsOptions[0])
        o in i || (i[o] = void 0);
    n ? e.props = r ? i : Ui(i) : e.type.props ? e.props = i : e.props = s,
        e.attrs = s
}
function r_(e, t, n, r) {
    const {props: i, attrs: s, vnode: {patchFlag: o}} = e
        , a = ke(i)
        , [l] = e.propsOptions;
    let c = !1;
    if ((r || o > 0) && !(o & 16)) {
        if (o & 8) {
            const u = e.vnode.dynamicProps;
            for (let f = 0; f < u.length; f++) {
                let d = u[f];
                if ($a(e.emitsOptions, d))
                    continue;
                const h = t[d];
                if (l)
                    if (He(s, d))
                        h !== s[d] && (s[d] = h,
                            c = !0);
                    else {
                        const y = Gt(d);
                        i[y] = ac(l, a, y, h, e, !1)
                    }
                else
                    h !== s[d] && (s[d] = h,
                        c = !0)
            }
        }
    } else {
        wg(e, t, i, s) && (c = !0);
        let u;
        for (const f in a)
            (!t || !He(t, f) && ((u = cn(f)) === f || !He(t, u))) && (l ? n && (n[f] !== void 0 || n[u] !== void 0) && (i[f] = ac(l, a, f, void 0, e, !0)) : delete i[f]);
        if (s !== a)
            for (const f in s)
                (!t || !He(t, f)) && (delete s[f],
                    c = !0)
    }
    c && Yn(e, "set", "$attrs")
}
function wg(e, t, n, r) {
    const [i,s] = e.propsOptions;
    let o = !1, a;
    if (t)
        for (let l in t) {
            if (hs(l))
                continue;
            const c = t[l];
            let u;
            i && He(i, u = Gt(l)) ? !s || !s.includes(u) ? n[u] = c : (a || (a = {}))[u] = c : $a(e.emitsOptions, l) || (!(l in r) || c !== r[l]) && (r[l] = c,
                o = !0)
        }
    if (s) {
        const l = ke(n)
            , c = a || Ye;
        for (let u = 0; u < s.length; u++) {
            const f = s[u];
            n[f] = ac(i, l, f, c[f], e, !He(c, f))
        }
    }
    return o
}
function ac(e, t, n, r, i, s) {
    const o = e[n];
    if (o != null) {
        const a = He(o, "default");
        if (a && r === void 0) {
            const l = o.default;
            if (o.type !== Function && !o.skipFactory && Le(l)) {
                const {propsDefaults: c} = i;
                n in c ? r = c[n] : (br(i),
                    r = c[n] = l.call(null, t),
                    dr())
            } else
                r = l
        }
        o[0] && (s && !a ? r = !1 : o[1] && (r === "" || r === cn(n)) && (r = !0))
    }
    return r
}
function Sg(e, t, n=!1) {
    const r = t.propsCache
        , i = r.get(e);
    if (i)
        return i;
    const s = e.props
        , o = {}
        , a = [];
    let l = !1;
    if (!Le(e)) {
        const u = f=>{
                l = !0;
                const [d,h] = Sg(f, t, !0);
                Ze(o, d),
                h && a.push(...h)
            }
        ;
        !n && t.mixins.length && t.mixins.forEach(u),
        e.extends && u(e.extends),
        e.mixins && e.mixins.forEach(u)
    }
    if (!s && !l)
        return qe(e) && r.set(e, _i),
            _i;
    if (be(s))
        for (let u = 0; u < s.length; u++) {
            const f = Gt(s[u]);
            fd(f) && (o[f] = Ye)
        }
    else if (s)
        for (const u in s) {
            const f = Gt(u);
            if (fd(f)) {
                const d = s[u]
                    , h = o[f] = be(d) || Le(d) ? {
                    type: d
                } : Ze({}, d);
                if (h) {
                    const y = hd(Boolean, h.type)
                        , p = hd(String, h.type);
                    h[0] = y > -1,
                        h[1] = p < 0 || y < p,
                    (y > -1 || He(h, "default")) && a.push(f)
                }
            }
        }
    const c = [o, a];
    return qe(e) && r.set(e, c),
        c
}
function fd(e) {
    return e[0] !== "$"
}
function dd(e) {
    const t = e && e.toString().match(/^\s*(function|class) (\w+)/);
    return t ? t[2] : e === null ? "null" : ""
}
function pd(e, t) {
    return dd(e) === dd(t)
}
function hd(e, t) {
    return be(t) ? t.findIndex(n=>pd(n, e)) : Le(t) && pd(t, e) ? 0 : -1
}
const _g = e=>e[0] === "_" || e === "$stable"
    , Vu = e=>be(e) ? e.map(Qt) : [Qt(e)]
    , i_ = (e,t,n)=>{
        if (t._n)
            return t;
        const r = mt((...i)=>Vu(t(...i)), n);
        return r._c = !1,
            r
    }
    , Eg = (e,t,n)=>{
        const r = e._ctx;
        for (const i in e) {
            if (_g(i))
                continue;
            const s = e[i];
            if (Le(s))
                t[i] = i_(i, s, r);
            else if (s != null) {
                const o = Vu(s);
                t[i] = ()=>o
            }
        }
    }
    , Cg = (e,t)=>{
        const n = Vu(t);
        e.slots.default = ()=>n
    }
    , s_ = (e,t)=>{
        if (e.vnode.shapeFlag & 32) {
            const n = t._;
            n ? (e.slots = ke(t),
                Zo(t, "_", n)) : Eg(t, e.slots = {})
        } else
            e.slots = {},
            t && Cg(e, t);
        Zo(e.slots, Ua, 1)
    }
    , o_ = (e,t,n)=>{
        const {vnode: r, slots: i} = e;
        let s = !0
            , o = Ye;
        if (r.shapeFlag & 32) {
            const a = t._;
            a ? n && a === 1 ? s = !1 : (Ze(i, t),
            !n && a === 1 && delete i._) : (s = !t.$stable,
                Eg(t, i)),
                o = t
        } else
            t && (Cg(e, t),
                o = {
                    default: 1
                });
        if (s)
            for (const a in i)
                !_g(a) && !(a in o) && delete i[a]
    }
;
function ia(e, t, n, r, i=!1) {
    if (be(e)) {
        e.forEach((d,h)=>ia(d, t && (be(t) ? t[h] : t), n, r, i));
        return
    }
    if ($r(r) && !i)
        return;
    const s = r.shapeFlag & 4 ? Ga(r.component) || r.component.proxy : r.el
        , o = i ? null : s
        , {i: a, r: l} = e
        , c = t && t.r
        , u = a.refs === Ye ? a.refs = {} : a.refs
        , f = a.setupState;
    if (c != null && c !== l && (rt(c) ? (u[c] = null,
    He(f, c) && (f[c] = null)) : Je(c) && (c.value = null)),
        Le(l))
        Kn(l, a, 12, [o, u]);
    else {
        const d = rt(l)
            , h = Je(l);
        if (d || h) {
            const y = ()=>{
                    if (e.f) {
                        const p = d ? He(f, l) ? f[l] : u[l] : l.value;
                        i ? be(p) && vu(p, s) : be(p) ? p.includes(s) || p.push(s) : d ? (u[l] = [s],
                        He(f, l) && (f[l] = u[l])) : (l.value = [s],
                        e.k && (u[e.k] = l.value))
                    } else
                        d ? (u[l] = o,
                        He(f, l) && (f[l] = o)) : h && (l.value = o,
                        e.k && (u[e.k] = o))
                }
            ;
            o ? (y.id = -1,
                _t(y, n)) : y()
        }
    }
}
let nr = !1;
const go = e=>/svg/.test(e.namespaceURI) && e.tagName !== "foreignObject"
    , vo = e=>e.nodeType === 8;
function a_(e) {
    const {mt: t, p: n, o: {patchProp: r, createText: i, nextSibling: s, parentNode: o, remove: a, insert: l, createComment: c}} = e
        , u = (m,g)=>{
            if (!g.hasChildNodes()) {
                n(null, m, g),
                    na(),
                    g._vnode = m;
                return
            }
            nr = !1,
                f(g.firstChild, m, null, null, null),
                na(),
                g._vnode = m,
            nr && console.error("Hydration completed but contains mismatches.")
        }
        , f = (m,g,b,v,S,_=!1)=>{
            const E = vo(m) && m.data === "["
                , T = ()=>p(m, g, b, v, S, E)
                , {type: P, ref: I, shapeFlag: L, patchFlag: x} = g;
            let A = m.nodeType;
            g.el = m,
            x === -2 && (_ = !1,
                g.dynamicChildren = null);
            let k = null;
            switch (P) {
                case vr:
                    A !== 3 ? g.children === "" ? (l(g.el = i(""), o(m), m),
                        k = m) : k = T() : (m.data !== g.children && (nr = !0,
                        m.data = g.children),
                        k = s(m));
                    break;
                case kt:
                    A !== 8 || E ? k = T() : k = s(m);
                    break;
                case Fr:
                    if (E && (m = s(m),
                        A = m.nodeType),
                    A === 1 || A === 3) {
                        k = m;
                        const O = !g.children.length;
                        for (let N = 0; N < g.staticCount; N++)
                            O && (g.children += k.nodeType === 1 ? k.outerHTML : k.data),
                            N === g.staticCount - 1 && (g.anchor = k),
                                k = s(k);
                        return E ? s(k) : k
                    } else
                        T();
                    break;
                case nt:
                    E ? k = y(m, g, b, v, S, _) : k = T();
                    break;
                default:
                    if (L & 1)
                        A !== 1 || g.type.toLowerCase() !== m.tagName.toLowerCase() ? k = T() : k = d(m, g, b, v, S, _);
                    else if (L & 6) {
                        g.slotScopeIds = S;
                        const O = o(m);
                        if (t(g, O, null, b, v, go(O), _),
                            k = E ? w(m) : s(m),
                        k && vo(k) && k.data === "teleport end" && (k = s(k)),
                            $r(g)) {
                            let N;
                            E ? (N = Re(nt),
                                N.anchor = k ? k.previousSibling : O.lastChild) : N = m.nodeType === 3 ? Wa("") : Re("div"),
                                N.el = m,
                                g.component.subTree = N
                        }
                    } else
                        L & 64 ? A !== 8 ? k = T() : k = g.type.hydrate(m, g, b, v, S, _, e, h) : L & 128 && (k = g.type.hydrate(m, g, b, v, go(o(m)), S, _, e, f))
            }
            return I != null && ia(I, null, v, g),
                k
        }
        , d = (m,g,b,v,S,_)=>{
            _ = _ || !!g.dynamicChildren;
            const {type: E, props: T, patchFlag: P, shapeFlag: I, dirs: L} = g
                , x = E === "input" && L || E === "option";
            if (x || P !== -1) {
                if (L && An(g, null, b, "created"),
                    T)
                    if (x || !_ || P & 48)
                        for (const k in T)
                            (x && k.endsWith("value") || Ks(k) && !hs(k)) && r(m, k, null, T[k], !1, void 0, b);
                    else
                        T.onClick && r(m, "onClick", null, T.onClick, !1, void 0, b);
                let A;
                if ((A = T && T.onVnodeBeforeMount) && Bt(A, b, g),
                L && An(g, null, b, "beforeMount"),
                ((A = T && T.onVnodeMounted) || L) && eg(()=>{
                        A && Bt(A, b, g),
                        L && An(g, null, b, "mounted")
                    }
                    , v),
                I & 16 && !(T && (T.innerHTML || T.textContent))) {
                    let k = h(m.firstChild, g, m, b, v, S, _);
                    for (; k; ) {
                        nr = !0;
                        const O = k;
                        k = k.nextSibling,
                            a(O)
                    }
                } else
                    I & 8 && m.textContent !== g.children && (nr = !0,
                        m.textContent = g.children)
            }
            return m.nextSibling
        }
        , h = (m,g,b,v,S,_,E)=>{
            E = E || !!g.dynamicChildren;
            const T = g.children
                , P = T.length;
            for (let I = 0; I < P; I++) {
                const L = E ? T[I] : T[I] = Qt(T[I]);
                if (m)
                    m = f(m, L, v, S, _, E);
                else {
                    if (L.type === vr && !L.children)
                        continue;
                    nr = !0,
                        n(null, L, b, null, v, S, go(b), _)
                }
            }
            return m
        }
        , y = (m,g,b,v,S,_)=>{
            const {slotScopeIds: E} = g;
            E && (S = S ? S.concat(E) : E);
            const T = o(m)
                , P = h(s(m), g, T, b, v, S, _);
            return P && vo(P) && P.data === "]" ? s(g.anchor = P) : (nr = !0,
                l(g.anchor = c("]"), T, P),
                P)
        }
        , p = (m,g,b,v,S,_)=>{
            if (nr = !0,
                g.el = null,
                _) {
                const P = w(m);
                for (; ; ) {
                    const I = s(m);
                    if (I && I !== P)
                        a(I);
                    else
                        break
                }
            }
            const E = s(m)
                , T = o(m);
            return a(m),
                n(null, g, T, E, b, v, go(T), S),
                E
        }
        , w = m=>{
            let g = 0;
            for (; m; )
                if (m = s(m),
                m && vo(m) && (m.data === "[" && g++,
                m.data === "]")) {
                    if (g === 0)
                        return s(m);
                    g--
                }
            return m
        }
    ;
    return [u, f]
}
const _t = eg;
function Tg(e) {
    return Pg(e)
}
function xg(e) {
    return Pg(e, a_)
}
function Pg(e, t) {
    const n = Zl();
    n.__VUE__ = !0;
    const {insert: r, remove: i, patchProp: s, createElement: o, createText: a, createComment: l, setText: c, setElementText: u, parentNode: f, nextSibling: d, setScopeId: h=Sn, insertStaticContent: y} = e
        , p = (M,C,R,F=null,V=null,Y=null,re=!1,ie=null,ae=!!C.dynamicChildren)=>{
        if (M === C)
            return;
        M && !bn(M, C) && (F = J(M),
            ye(M, V, Y, !0),
            M = null),
        C.patchFlag === -2 && (ae = !1,
            C.dynamicChildren = null);
        const {type: Q, ref: U, shapeFlag: $} = C;
        switch (Q) {
            case vr:
                w(M, C, R, F);
                break;
            case kt:
                m(M, C, R, F);
                break;
            case Fr:
                M == null && g(C, R, F, re);
                break;
            case nt:
                x(M, C, R, F, V, Y, re, ie, ae);
                break;
            default:
                $ & 1 ? S(M, C, R, F, V, Y, re, ie, ae) : $ & 6 ? A(M, C, R, F, V, Y, re, ie, ae) : ($ & 64 || $ & 128) && Q.process(M, C, R, F, V, Y, re, ie, ae, ee)
        }
        U != null && V && ia(U, M && M.ref, Y, C || M, !C)
    }
        , w = (M,C,R,F)=>{
        if (M == null)
            r(C.el = a(C.children), R, F);
        else {
            const V = C.el = M.el;
            C.children !== M.children && c(V, C.children)
        }
    }
        , m = (M,C,R,F)=>{
        M == null ? r(C.el = l(C.children || ""), R, F) : C.el = M.el
    }
        , g = (M,C,R,F)=>{
        [M.el,M.anchor] = y(M.children, C, R, F, M.el, M.anchor)
    }
        , b = ({el: M, anchor: C},R,F)=>{
        let V;
        for (; M && M !== C; )
            V = d(M),
                r(M, R, F),
                M = V;
        r(C, R, F)
    }
        , v = ({el: M, anchor: C})=>{
        let R;
        for (; M && M !== C; )
            R = d(M),
                i(M),
                M = R;
        i(C)
    }
        , S = (M,C,R,F,V,Y,re,ie,ae)=>{
        re = re || C.type === "svg",
            M == null ? _(C, R, F, V, Y, re, ie, ae) : P(M, C, V, Y, re, ie, ae)
    }
        , _ = (M,C,R,F,V,Y,re,ie)=>{
        let ae, Q;
        const {type: U, props: $, shapeFlag: Z, transition: te, dirs: pe} = M;
        if (ae = M.el = o(M.type, Y, $ && $.is, $),
            Z & 8 ? u(ae, M.children) : Z & 16 && T(M.children, ae, null, F, V, Y && U !== "foreignObject", re, ie),
        pe && An(M, null, F, "created"),
            E(ae, M, M.scopeId, re, F),
            $) {
            for (const me in $)
                me !== "value" && !hs(me) && s(ae, me, null, $[me], Y, M.children, F, V, _e);
            "value"in $ && s(ae, "value", null, $.value),
            (Q = $.onVnodeBeforeMount) && Bt(Q, F, M)
        }
        pe && An(M, null, F, "beforeMount");
        const oe = (!V || V && !V.pendingBranch) && te && !te.persisted;
        oe && te.beforeEnter(ae),
            r(ae, C, R),
        ((Q = $ && $.onVnodeMounted) || oe || pe) && _t(()=>{
                Q && Bt(Q, F, M),
                oe && te.enter(ae),
                pe && An(M, null, F, "mounted")
            }
            , V)
    }
        , E = (M,C,R,F,V)=>{
        if (R && h(M, R),
            F)
            for (let Y = 0; Y < F.length; Y++)
                h(M, F[Y]);
        if (V) {
            let Y = V.subTree;
            if (C === Y) {
                const re = V.vnode;
                E(M, re, re.scopeId, re.slotScopeIds, V.parent)
            }
        }
    }
        , T = (M,C,R,F,V,Y,re,ie,ae=0)=>{
        for (let Q = ae; Q < M.length; Q++) {
            const U = M[Q] = ie ? ar(M[Q]) : Qt(M[Q]);
            p(null, U, C, R, F, V, Y, re, ie)
        }
    }
        , P = (M,C,R,F,V,Y,re)=>{
        const ie = C.el = M.el;
        let {patchFlag: ae, dynamicChildren: Q, dirs: U} = C;
        ae |= M.patchFlag & 16;
        const $ = M.props || Ye
            , Z = C.props || Ye;
        let te;
        R && Pr(R, !1),
        (te = Z.onVnodeBeforeUpdate) && Bt(te, R, C, M),
        U && An(C, M, R, "beforeUpdate"),
        R && Pr(R, !0);
        const pe = V && C.type !== "foreignObject";
        if (Q ? I(M.dynamicChildren, Q, ie, R, F, pe, Y) : re || W(M, C, ie, null, R, F, pe, Y, !1),
        ae > 0) {
            if (ae & 16)
                L(ie, C, $, Z, R, F, V);
            else if (ae & 2 && $.class !== Z.class && s(ie, "class", null, Z.class, V),
            ae & 4 && s(ie, "style", $.style, Z.style, V),
            ae & 8) {
                const oe = C.dynamicProps;
                for (let me = 0; me < oe.length; me++) {
                    const Me = oe[me]
                        , Ne = $[Me]
                        , et = Z[Me];
                    (et !== Ne || Me === "value") && s(ie, Me, Ne, et, V, M.children, R, F, _e)
                }
            }
            ae & 1 && M.children !== C.children && u(ie, C.children)
        } else
            !re && Q == null && L(ie, C, $, Z, R, F, V);
        ((te = Z.onVnodeUpdated) || U) && _t(()=>{
                te && Bt(te, R, C, M),
                U && An(C, M, R, "updated")
            }
            , F)
    }
        , I = (M,C,R,F,V,Y,re)=>{
        for (let ie = 0; ie < C.length; ie++) {
            const ae = M[ie]
                , Q = C[ie]
                , U = ae.el && (ae.type === nt || !bn(ae, Q) || ae.shapeFlag & 70) ? f(ae.el) : R;
            p(ae, Q, U, null, F, V, Y, re, !0)
        }
    }
        , L = (M,C,R,F,V,Y,re)=>{
        if (R !== F) {
            if (R !== Ye)
                for (const ie in R)
                    !hs(ie) && !(ie in F) && s(M, ie, R[ie], null, re, C.children, V, Y, _e);
            for (const ie in F) {
                if (hs(ie))
                    continue;
                const ae = F[ie]
                    , Q = R[ie];
                ae !== Q && ie !== "value" && s(M, ie, Q, ae, re, C.children, V, Y, _e)
            }
            "value"in F && s(M, "value", R.value, F.value)
        }
    }
        , x = (M,C,R,F,V,Y,re,ie,ae)=>{
        const Q = C.el = M ? M.el : a("")
            , U = C.anchor = M ? M.anchor : a("");
        let {patchFlag: $, dynamicChildren: Z, slotScopeIds: te} = C;
        te && (ie = ie ? ie.concat(te) : te),
            M == null ? (r(Q, R, F),
                r(U, R, F),
                T(C.children, R, U, V, Y, re, ie, ae)) : $ > 0 && $ & 64 && Z && M.dynamicChildren ? (I(M.dynamicChildren, Z, R, V, Y, re, ie),
            (C.key != null || V && C === V.subTree) && zu(M, C, !0)) : W(M, C, R, U, V, Y, re, ie, ae)
    }
        , A = (M,C,R,F,V,Y,re,ie,ae)=>{
        C.slotScopeIds = ie,
            M == null ? C.shapeFlag & 512 ? V.ctx.activate(C, R, F, re, ae) : k(C, R, F, V, Y, re, ae) : O(M, C, ae)
    }
        , k = (M,C,R,F,V,Y,re)=>{
        const ie = M.component = Ig(M, F, V);
        if (Zs(M) && (ie.ctx.renderer = ee),
            Dg(ie),
            ie.asyncDep) {
            if (V && V.registerDep(ie, N),
                !M.el) {
                const ae = ie.subTree = Re(kt);
                m(null, ae, C, R)
            }
            return
        }
        N(ie, M, C, R, V, Y, re)
    }
        , O = (M,C,R)=>{
        const F = C.component = M.component;
        if (gS(M, C, R))
            if (F.asyncDep && !F.asyncResolved) {
                D(F, C, R);
                return
            } else
                F.next = C,
                    aS(F.update),
                    F.update();
        else
            C.el = M.el,
                F.vnode = C
    }
        , N = (M,C,R,F,V,Y,re)=>{
        const ie = ()=>{
            if (M.isMounted) {
                let {next: U, bu: $, u: Z, parent: te, vnode: pe} = M, oe = U, me;
                Pr(M, !1),
                    U ? (U.el = pe.el,
                        D(M, U, re)) : U = pe,
                $ && Ci($),
                (me = U.props && U.props.onVnodeBeforeUpdate) && Bt(me, te, U, pe),
                    Pr(M, !0);
                const Me = $o(M)
                    , Ne = M.subTree;
                M.subTree = Me,
                    p(Ne, Me, f(Ne.el), J(Ne), M, V, Y),
                    U.el = Me.el,
                oe === null && Ou(M, Me.el),
                Z && _t(Z, V),
                (me = U.props && U.props.onVnodeUpdated) && _t(()=>Bt(me, te, U, pe), V)
            } else {
                let U;
                const {el: $, props: Z} = C
                    , {bm: te, m: pe, parent: oe} = M
                    , me = $r(C);
                if (Pr(M, !1),
                te && Ci(te),
                !me && (U = Z && Z.onVnodeBeforeMount) && Bt(U, oe, C),
                    Pr(M, !0),
                $ && Ce) {
                    const Me = ()=>{
                            M.subTree = $o(M),
                                Ce($, M.subTree, M, V, null)
                        }
                    ;
                    me ? C.type.__asyncLoader().then(()=>!M.isUnmounted && Me()) : Me()
                } else {
                    const Me = M.subTree = $o(M);
                    p(null, Me, R, F, M, V, Y),
                        C.el = Me.el
                }
                if (pe && _t(pe, V),
                !me && (U = Z && Z.onVnodeMounted)) {
                    const Me = C;
                    _t(()=>Bt(U, oe, Me), V)
                }
                (C.shapeFlag & 256 || oe && $r(oe.vnode) && oe.vnode.shapeFlag & 256) && M.a && _t(M.a, V),
                    M.isMounted = !0,
                    C = R = F = null
            }
        }
            , ae = M.effect = new qs(ie,()=>Na(Q),M.scope)
            , Q = M.update = ()=>ae.run();
        Q.id = M.uid,
            Pr(M, !0),
            Q()
    }
        , D = (M,C,R)=>{
        C.component = M;
        const F = M.vnode.props;
        M.vnode = C,
            M.next = null,
            r_(M, C.props, F, R),
            o_(M, C.children, R),
            Vi(),
            rd(),
            zi()
    }
        , W = (M,C,R,F,V,Y,re,ie,ae=!1)=>{
        const Q = M && M.children
            , U = M ? M.shapeFlag : 0
            , $ = C.children
            , {patchFlag: Z, shapeFlag: te} = C;
        if (Z > 0) {
            if (Z & 128) {
                le(Q, $, R, F, V, Y, re, ie, ae);
                return
            } else if (Z & 256) {
                G(Q, $, R, F, V, Y, re, ie, ae);
                return
            }
        }
        te & 8 ? (U & 16 && _e(Q, V, Y),
        $ !== Q && u(R, $)) : U & 16 ? te & 16 ? le(Q, $, R, F, V, Y, re, ie, ae) : _e(Q, V, Y, !0) : (U & 8 && u(R, ""),
        te & 16 && T($, R, F, V, Y, re, ie, ae))
    }
        , G = (M,C,R,F,V,Y,re,ie,ae)=>{
        M = M || _i,
            C = C || _i;
        const Q = M.length
            , U = C.length
            , $ = Math.min(Q, U);
        let Z;
        for (Z = 0; Z < $; Z++) {
            const te = C[Z] = ae ? ar(C[Z]) : Qt(C[Z]);
            p(M[Z], te, R, null, V, Y, re, ie, ae)
        }
        Q > U ? _e(M, V, Y, !0, !1, $) : T(C, R, F, V, Y, re, ie, ae, $)
    }
        , le = (M,C,R,F,V,Y,re,ie,ae)=>{
        let Q = 0;
        const U = C.length;
        let $ = M.length - 1
            , Z = U - 1;
        for (; Q <= $ && Q <= Z; ) {
            const te = M[Q]
                , pe = C[Q] = ae ? ar(C[Q]) : Qt(C[Q]);
            if (bn(te, pe))
                p(te, pe, R, null, V, Y, re, ie, ae);
            else
                break;
            Q++
        }
        for (; Q <= $ && Q <= Z; ) {
            const te = M[$]
                , pe = C[Z] = ae ? ar(C[Z]) : Qt(C[Z]);
            if (bn(te, pe))
                p(te, pe, R, null, V, Y, re, ie, ae);
            else
                break;
            $--,
                Z--
        }
        if (Q > $) {
            if (Q <= Z) {
                const te = Z + 1
                    , pe = te < U ? C[te].el : F;
                for (; Q <= Z; )
                    p(null, C[Q] = ae ? ar(C[Q]) : Qt(C[Q]), R, pe, V, Y, re, ie, ae),
                        Q++
            }
        } else if (Q > Z)
            for (; Q <= $; )
                ye(M[Q], V, Y, !0),
                    Q++;
        else {
            const te = Q
                , pe = Q
                , oe = new Map;
            for (Q = pe; Q <= Z; Q++) {
                const ze = C[Q] = ae ? ar(C[Q]) : Qt(C[Q]);
                ze.key != null && oe.set(ze.key, Q)
            }
            let me, Me = 0;
            const Ne = Z - pe + 1;
            let et = !1
                , se = 0;
            const Ie = new Array(Ne);
            for (Q = 0; Q < Ne; Q++)
                Ie[Q] = 0;
            for (Q = te; Q <= $; Q++) {
                const ze = M[Q];
                if (Me >= Ne) {
                    ye(ze, V, Y, !0);
                    continue
                }
                let $e;
                if (ze.key != null)
                    $e = oe.get(ze.key);
                else
                    for (me = pe; me <= Z; me++)
                        if (Ie[me - pe] === 0 && bn(ze, C[me])) {
                            $e = me;
                            break
                        }
                $e === void 0 ? ye(ze, V, Y, !0) : (Ie[$e - pe] = Q + 1,
                    $e >= se ? se = $e : et = !0,
                    p(ze, C[$e], R, null, V, Y, re, ie, ae),
                    Me++)
            }
            const De = et ? l_(Ie) : _i;
            for (me = De.length - 1,
                     Q = Ne - 1; Q >= 0; Q--) {
                const ze = pe + Q
                    , $e = C[ze]
                    , Ue = ze + 1 < U ? C[ze + 1].el : F;
                Ie[Q] === 0 ? p(null, $e, R, Ue, V, Y, re, ie, ae) : et && (me < 0 || Q !== De[me] ? ge($e, R, Ue, 2) : me--)
            }
        }
    }
        , ge = (M,C,R,F,V=null)=>{
        const {el: Y, type: re, transition: ie, children: ae, shapeFlag: Q} = M;
        if (Q & 6) {
            ge(M.component.subTree, C, R, F);
            return
        }
        if (Q & 128) {
            M.suspense.move(C, R, F);
            return
        }
        if (Q & 64) {
            re.move(M, C, R, ee);
            return
        }
        if (re === nt) {
            r(Y, C, R);
            for (let $ = 0; $ < ae.length; $++)
                ge(ae[$], C, R, F);
            r(M.anchor, C, R);
            return
        }
        if (re === Fr) {
            b(M, C, R);
            return
        }
        if (F !== 2 && Q & 1 && ie)
            if (F === 0)
                ie.beforeEnter(Y),
                    r(Y, C, R),
                    _t(()=>ie.enter(Y), V);
            else {
                const {leave: $, delayLeave: Z, afterLeave: te} = ie
                    , pe = ()=>r(Y, C, R)
                    , oe = ()=>{
                        $(Y, ()=>{
                                pe(),
                                te && te()
                            }
                        )
                    }
                ;
                Z ? Z(Y, pe, oe) : oe()
            }
        else
            r(Y, C, R)
    }
        , ye = (M,C,R,F=!1,V=!1)=>{
        const {type: Y, props: re, ref: ie, children: ae, dynamicChildren: Q, shapeFlag: U, patchFlag: $, dirs: Z} = M;
        if (ie != null && ia(ie, null, R, M, !0),
        U & 256) {
            C.ctx.deactivate(M);
            return
        }
        const te = U & 1 && Z
            , pe = !$r(M);
        let oe;
        if (pe && (oe = re && re.onVnodeBeforeUnmount) && Bt(oe, C, M),
        U & 6)
            Pe(M.component, R, F);
        else {
            if (U & 128) {
                M.suspense.unmount(R, F);
                return
            }
            te && An(M, null, C, "beforeUnmount"),
                U & 64 ? M.type.remove(M, C, R, V, ee, F) : Q && (Y !== nt || $ > 0 && $ & 64) ? _e(Q, C, R, !1, !0) : (Y === nt && $ & 384 || !V && U & 16) && _e(ae, C, R),
            F && de(M)
        }
        (pe && (oe = re && re.onVnodeUnmounted) || te) && _t(()=>{
                oe && Bt(oe, C, M),
                te && An(M, null, C, "unmounted")
            }
            , R)
    }
        , de = M=>{
        const {type: C, el: R, anchor: F, transition: V} = M;
        if (C === nt) {
            z(R, F);
            return
        }
        if (C === Fr) {
            v(M);
            return
        }
        const Y = ()=>{
                i(R),
                V && !V.persisted && V.afterLeave && V.afterLeave()
            }
        ;
        if (M.shapeFlag & 1 && V && !V.persisted) {
            const {leave: re, delayLeave: ie} = V
                , ae = ()=>re(R, Y);
            ie ? ie(M.el, Y, ae) : ae()
        } else
            Y()
    }
        , z = (M,C)=>{
        let R;
        for (; M !== C; )
            R = d(M),
                i(M),
                M = R;
        i(C)
    }
        , Pe = (M,C,R)=>{
        const {bum: F, scope: V, update: Y, subTree: re, um: ie} = M;
        F && Ci(F),
            V.stop(),
        Y && (Y.active = !1,
            ye(re, M, C, R)),
        ie && _t(ie, C),
            _t(()=>{
                    M.isUnmounted = !0
                }
                , C),
        C && C.pendingBranch && !C.isUnmounted && M.asyncDep && !M.asyncResolved && M.suspenseId === C.pendingId && (C.deps--,
        C.deps === 0 && C.resolve())
    }
        , _e = (M,C,R,F=!1,V=!1,Y=0)=>{
        for (let re = Y; re < M.length; re++)
            ye(M[re], C, R, F, V)
    }
        , J = M=>M.shapeFlag & 6 ? J(M.component.subTree) : M.shapeFlag & 128 ? M.suspense.next() : d(M.anchor || M.el)
        , ne = (M,C,R)=>{
        M == null ? C._vnode && ye(C._vnode, null, null, !0) : p(C._vnode || null, M, C, null, null, null, R),
            rd(),
            na(),
            C._vnode = M
    }
        , ee = {
        p,
        um: ye,
        m: ge,
        r: de,
        mt: k,
        mc: T,
        pc: W,
        pbc: I,
        n: J,
        o: e
    };
    let ce, Ce;
    return t && ([ce,Ce] = t(ee)),
        {
            render: ne,
            hydrate: ce,
            createApp: t_(ne, ce)
        }
}
function Pr({effect: e, update: t}, n) {
    e.allowRecurse = t.allowRecurse = n
}
function zu(e, t, n=!1) {
    const r = e.children
        , i = t.children;
    if (be(r) && be(i))
        for (let s = 0; s < r.length; s++) {
            const o = r[s];
            let a = i[s];
            a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = i[s] = ar(i[s]),
                a.el = o.el),
            n || zu(o, a)),
            a.type === vr && (a.el = o.el)
        }
}
function l_(e) {
    const t = e.slice()
        , n = [0];
    let r, i, s, o, a;
    const l = e.length;
    for (r = 0; r < l; r++) {
        const c = e[r];
        if (c !== 0) {
            if (i = n[n.length - 1],
            e[i] < c) {
                t[r] = i,
                    n.push(r);
                continue
            }
            for (s = 0,
                     o = n.length - 1; s < o; )
                a = s + o >> 1,
                    e[n[a]] < c ? s = a + 1 : o = a;
            c < e[n[s]] && (s > 0 && (t[r] = n[s - 1]),
                n[s] = r)
        }
    }
    for (s = n.length,
             o = n[s - 1]; s-- > 0; )
        n[s] = o,
            o = t[o];
    return n
}
const c_ = e=>e.__isTeleport
    , vs = e=>e && (e.disabled || e.disabled === "")
    , md = e=>typeof SVGElement < "u" && e instanceof SVGElement
    , lc = (e,t)=>{
    const n = e && e.to;
    return rt(n) ? t ? t(n) : null : n
}
    , u_ = {
    __isTeleport: !0,
    process(e, t, n, r, i, s, o, a, l, c) {
        const {mc: u, pc: f, pbc: d, o: {insert: h, querySelector: y, createText: p, createComment: w}} = c
            , m = vs(t.props);
        let {shapeFlag: g, children: b, dynamicChildren: v} = t;
        if (e == null) {
            const S = t.el = p("")
                , _ = t.anchor = p("");
            h(S, n, r),
                h(_, n, r);
            const E = t.target = lc(t.props, y)
                , T = t.targetAnchor = p("");
            E && (h(T, E),
                o = o || md(E));
            const P = (I,L)=>{
                    g & 16 && u(b, I, L, i, s, o, a, l)
                }
            ;
            m ? P(n, _) : E && P(E, T)
        } else {
            t.el = e.el;
            const S = t.anchor = e.anchor
                , _ = t.target = e.target
                , E = t.targetAnchor = e.targetAnchor
                , T = vs(e.props)
                , P = T ? n : _
                , I = T ? S : E;
            if (o = o || md(_),
                v ? (d(e.dynamicChildren, v, P, i, s, o, a),
                    zu(e, t, !0)) : l || f(e, t, P, I, i, s, o, a, !1),
                m)
                T || yo(t, n, S, c, 1);
            else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
                const L = t.target = lc(t.props, y);
                L && yo(t, L, null, c, 0)
            } else
                T && yo(t, _, E, c, 1)
        }
        kg(t)
    },
    remove(e, t, n, r, {um: i, o: {remove: s}}, o) {
        const {shapeFlag: a, children: l, anchor: c, targetAnchor: u, target: f, props: d} = e;
        if (f && s(u),
        (o || !vs(d)) && (s(c),
        a & 16))
            for (let h = 0; h < l.length; h++) {
                const y = l[h];
                i(y, t, n, !0, !!y.dynamicChildren)
            }
    },
    move: yo,
    hydrate: f_
};
function yo(e, t, n, {o: {insert: r}, m: i}, s=2) {
    s === 0 && r(e.targetAnchor, t, n);
    const {el: o, anchor: a, shapeFlag: l, children: c, props: u} = e
        , f = s === 2;
    if (f && r(o, t, n),
    (!f || vs(u)) && l & 16)
        for (let d = 0; d < c.length; d++)
            i(c[d], t, n, 2);
    f && r(a, t, n)
}
function f_(e, t, n, r, i, s, {o: {nextSibling: o, parentNode: a, querySelector: l}}, c) {
    const u = t.target = lc(t.props, l);
    if (u) {
        const f = u._lpa || u.firstChild;
        if (t.shapeFlag & 16)
            if (vs(t.props))
                t.anchor = c(o(e), t, a(e), n, r, i, s),
                    t.targetAnchor = f;
            else {
                t.anchor = o(e);
                let d = f;
                for (; d; )
                    if (d = o(d),
                    d && d.nodeType === 8 && d.data === "teleport anchor") {
                        t.targetAnchor = d,
                            u._lpa = t.targetAnchor && o(t.targetAnchor);
                        break
                    }
                c(f, t, u, n, r, i, s)
            }
        kg(t)
    }
    return t.anchor && o(t.anchor)
}
const cc = u_;
function kg(e) {
    const t = e.ctx;
    if (t && t.ut) {
        let n = e.children[0].el;
        for (; n !== e.targetAnchor; )
            n.nodeType === 1 && n.setAttribute("data-v-owner", t.uid),
                n = n.nextSibling;
        t.ut()
    }
}
const nt = Symbol.for("v-fgt")
    , vr = Symbol.for("v-txt")
    , kt = Symbol.for("v-cmt")
    , Fr = Symbol.for("v-stc")
    , ys = [];
let Ut = null;
function Ae(e=!1) {
    ys.push(Ut = e ? null : [])
}
function Rg() {
    ys.pop(),
        Ut = ys[ys.length - 1] || null
}
let zr = 1;
function uc(e) {
    zr += e
}
function Lg(e) {
    return e.dynamicChildren = zr > 0 ? Ut || _i : null,
        Rg(),
    zr > 0 && Ut && Ut.push(e),
        e
}
function Qe(e, t, n, r, i, s) {
    return Lg(Te(e, t, n, r, i, s, !0))
}
function gt(e, t, n, r, i) {
    return Lg(Re(e, t, n, r, i, !0))
}
function yr(e) {
    return e ? e.__v_isVNode === !0 : !1
}
function bn(e, t) {
    return e.type === t.type && e.key === t.key
}
function d_(e) {}
const Ua = "__vInternal"
    , Og = ({key: e})=>e ?? null
    , Fo = ({ref: e, ref_key: t, ref_for: n})=>(typeof e == "number" && (e = "" + e),
    e != null ? rt(e) || Je(e) || Le(e) ? {
        i: St,
        r: e,
        k: t,
        f: !!n
    } : e : null);
function Te(e, t=null, n=null, r=0, i=null, s=e === nt ? 0 : 1, o=!1, a=!1) {
    const l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e,
        props: t,
        key: t && Og(t),
        ref: t && Fo(t),
        scopeId: Fa,
        slotScopeIds: null,
        children: n,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: s,
        patchFlag: r,
        dynamicProps: i,
        dynamicChildren: null,
        appContext: null,
        ctx: St
    };
    return a ? (Uu(l, n),
    s & 128 && e.normalize(l)) : n && (l.shapeFlag |= rt(n) ? 8 : 16),
    zr > 0 && !o && Ut && (l.patchFlag > 0 || s & 6) && l.patchFlag !== 32 && Ut.push(l),
        l
}
const Re = p_;
function p_(e, t=null, n=null, r=0, i=null, s=!1) {
    if ((!e || e === mg) && (e = kt),
        yr(e)) {
        const a = Tn(e, t, !0);
        return n && Uu(a, n),
        zr > 0 && !s && Ut && (a.shapeFlag & 6 ? Ut[Ut.indexOf(e)] = a : Ut.push(a)),
            a.patchFlag |= -2,
            a
    }
    if (S_(e) && (e = e.__vccOpts),
        t) {
        t = Ag(t);
        let {class: a, style: l} = t;
        a && !rt(a) && (t.class = Pt(a)),
        qe(l) && (Cu(l) && !be(l) && (l = Ze({}, l)),
            t.style = Br(l))
    }
    const o = rt(e) ? 1 : Qm(e) ? 128 : c_(e) ? 64 : qe(e) ? 4 : Le(e) ? 2 : 0;
    return Te(e, t, n, r, i, o, s, !0)
}
function Ag(e) {
    return e ? Cu(e) || Ua in e ? Ze({}, e) : e : null
}
function Tn(e, t, n=!1) {
    const {props: r, ref: i, patchFlag: s, children: o} = e
        , a = t ? Wu(r || {}, t) : r;
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e.type,
        props: a,
        key: a && Og(a),
        ref: t && t.ref ? n && i ? be(i) ? i.concat(Fo(t)) : [i, Fo(t)] : Fo(t) : i,
        scopeId: e.scopeId,
        slotScopeIds: e.slotScopeIds,
        children: o,
        target: e.target,
        targetAnchor: e.targetAnchor,
        staticCount: e.staticCount,
        shapeFlag: e.shapeFlag,
        patchFlag: t && e.type !== nt ? s === -1 ? 16 : s | 16 : s,
        dynamicProps: e.dynamicProps,
        dynamicChildren: e.dynamicChildren,
        appContext: e.appContext,
        dirs: e.dirs,
        transition: e.transition,
        component: e.component,
        suspense: e.suspense,
        ssContent: e.ssContent && Tn(e.ssContent),
        ssFallback: e.ssFallback && Tn(e.ssFallback),
        el: e.el,
        anchor: e.anchor,
        ctx: e.ctx,
        ce: e.ce
    }
}
function Wa(e=" ", t=0) {
    return Re(vr, null, e, t)
}
function h_(e, t) {
    const n = Re(Fr, null, e);
    return n.staticCount = t,
        n
}
function Wt(e="", t=!1) {
    return t ? (Ae(),
        gt(kt, null, e)) : Re(kt, null, e)
}
function Qt(e) {
    return e == null || typeof e == "boolean" ? Re(kt) : be(e) ? Re(nt, null, e.slice()) : typeof e == "object" ? ar(e) : Re(vr, null, String(e))
}
function ar(e) {
    return e.el === null && e.patchFlag !== -1 || e.memo ? e : Tn(e)
}
function Uu(e, t) {
    let n = 0;
    const {shapeFlag: r} = e;
    if (t == null)
        t = null;
    else if (be(t))
        n = 16;
    else if (typeof t == "object")
        if (r & 65) {
            const i = t.default;
            i && (i._c && (i._d = !1),
                Uu(e, i()),
            i._c && (i._d = !0));
            return
        } else {
            n = 32;
            const i = t._;
            !i && !(Ua in t) ? t._ctx = St : i === 3 && St && (St.slots._ === 1 ? t._ = 1 : (t._ = 2,
                e.patchFlag |= 1024))
        }
    else
        Le(t) ? (t = {
            default: t,
            _ctx: St
        },
            n = 32) : (t = String(t),
            r & 64 ? (n = 16,
                t = [Wa(t)]) : n = 8);
    e.children = t,
        e.shapeFlag |= n
}
function Wu(...e) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
        const r = e[n];
        for (const i in r)
            if (i === "class")
                t.class !== r.class && (t.class = Pt([t.class, r.class]));
            else if (i === "style")
                t.style = Br([t.style, r.style]);
            else if (Ks(i)) {
                const s = t[i]
                    , o = r[i];
                o && s !== o && !(be(s) && s.includes(o)) && (t[i] = s ? [].concat(s, o) : o)
            } else
                i !== "" && (t[i] = r[i])
    }
    return t
}
function Bt(e, t, n, r=null) {
    tn(e, t, 7, [n, r])
}
const m_ = bg();
let g_ = 0;
function Ig(e, t, n) {
    const r = e.type
        , i = (t ? t.appContext : e.appContext) || m_
        , s = {
        uid: g_++,
        vnode: e,
        type: r,
        parent: t,
        appContext: i,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        scope: new wu(!0),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: t ? t.provides : Object.create(i.provides),
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: Sg(r, i),
        emitsOptions: Zm(r, i),
        emit: null,
        emitted: null,
        propsDefaults: Ye,
        inheritAttrs: r.inheritAttrs,
        ctx: Ye,
        data: Ye,
        props: Ye,
        attrs: Ye,
        slots: Ye,
        refs: Ye,
        setupState: Ye,
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        suspense: n,
        suspenseId: n ? n.pendingId : 0,
        asyncDep: null,
        asyncResolved: !1,
        isMounted: !1,
        isUnmounted: !1,
        isDeactivated: !1,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    return s.ctx = {
        _: s
    },
        s.root = t ? t.root : s,
        s.emit = cS.bind(null, s),
    e.ce && e.ce(s),
        s
}
let ft = null;
const Ot = ()=>ft || St;
let Gu, si, gd = "__VUE_INSTANCE_SETTERS__";
(si = Zl()[gd]) || (si = Zl()[gd] = []),
    si.push(e=>ft = e),
    Gu = e=>{
        si.length > 1 ? si.forEach(t=>t(e)) : si[0](e)
    }
;
const br = e=>{
        Gu(e),
            e.scope.on()
    }
    , dr = ()=>{
        ft && ft.scope.off(),
            Gu(null)
    }
;
function Mg(e) {
    return e.vnode.shapeFlag & 4
}
let Oi = !1;
function Dg(e, t=!1) {
    Oi = t;
    const {props: n, children: r} = e.vnode
        , i = Mg(e);
    n_(e, n, i, t),
        s_(e, r);
    const s = i ? v_(e, t) : void 0;
    return Oi = !1,
        s
}
function v_(e, t) {
    const n = e.type;
    e.accessCache = Object.create(null),
        e.proxy = Tu(new Proxy(e.ctx,ic));
    const {setup: r} = n;
    if (r) {
        const i = e.setupContext = r.length > 1 ? $g(e) : null;
        br(e),
            Vi();
        const s = Kn(r, e, 0, [e.props, i]);
        if (zi(),
            dr(),
            yu(s)) {
            if (s.then(dr, dr),
                t)
                return s.then(o=>{
                        fc(e, o, t)
                    }
                ).catch(o=>{
                        qr(o, e, 0)
                    }
                );
            e.asyncDep = s
        } else
            fc(e, s, t)
    } else
        Ng(e, t)
}
function fc(e, t, n) {
    Le(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : qe(t) && (e.setupState = ku(t)),
        Ng(e, n)
}
let sa, dc;
function y_(e) {
    sa = e,
        dc = t=>{
            t.render._rc && (t.withProxy = new Proxy(t.ctx,MS))
        }
}
const b_ = ()=>!sa;
function Ng(e, t, n) {
    const r = e.type;
    if (!e.render) {
        if (!t && sa && !r.render) {
            const i = r.template || Hu(e).template;
            if (i) {
                const {isCustomElement: s, compilerOptions: o} = e.appContext.config
                    , {delimiters: a, compilerOptions: l} = r
                    , c = Ze(Ze({
                    isCustomElement: s,
                    delimiters: a
                }, o), l);
                r.render = sa(i, c)
            }
        }
        e.render = r.render || Sn,
        dc && dc(e)
    }
    br(e),
        Vi(),
        YS(e),
        zi(),
        dr()
}
function w_(e) {
    return e.attrsProxy || (e.attrsProxy = new Proxy(e.attrs,{
        get(t, n) {
            return Xt(e, "get", "$attrs"),
                t[n]
        }
    }))
}
function $g(e) {
    const t = n=>{
            e.exposed = n || {}
        }
    ;
    return {
        get attrs() {
            return w_(e)
        },
        slots: e.slots,
        emit: e.emit,
        expose: t
    }
}
function Ga(e) {
    if (e.exposed)
        return e.exposeProxy || (e.exposeProxy = new Proxy(ku(Tu(e.exposed)),{
            get(t, n) {
                if (n in t)
                    return t[n];
                if (n in gs)
                    return gs[n](e)
            },
            has(t, n) {
                return n in t || n in gs
            }
        }))
}
function pc(e, t=!0) {
    return Le(e) ? e.displayName || e.name : e.name || t && e.__name
}
function S_(e) {
    return Le(e) && "__vccOpts"in e
}
const fe = (e,t)=>nS(e, t, Oi);
function yt(e, t, n) {
    const r = arguments.length;
    return r === 2 ? qe(t) && !be(t) ? yr(t) ? Re(e, null, [t]) : Re(e, t) : Re(e, null, t) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && yr(n) && (n = [n]),
        Re(e, t, n))
}
const Fg = Symbol.for("v-scx")
    , jg = ()=>vt(Fg);
function __() {}
function E_(e, t, n, r) {
    const i = n[r];
    if (i && Hg(i, e))
        return i;
    const s = t();
    return s.memo = e.slice(),
        n[r] = s
}
function Hg(e, t) {
    const n = e.memo;
    if (n.length != t.length)
        return !1;
    for (let r = 0; r < n.length; r++)
        if (ki(n[r], t[r]))
            return !1;
    return zr > 0 && Ut && Ut.push(e),
        !0
}
const Bg = "3.3.4"
    , C_ = {
    createComponentInstance: Ig,
    setupComponent: Dg,
    renderComponentRoot: $o,
    setCurrentRenderingInstance: Os,
    isVNode: yr,
    normalizeVNode: Qt
}
    , T_ = C_
    , x_ = null
    , P_ = null
    , k_ = "http://www.w3.org/2000/svg"
    , Or = typeof document < "u" ? document : null
    , vd = Or && Or.createElement("template")
    , R_ = {
    insert: (e,t,n)=>{
        t.insertBefore(e, n || null)
    }
    ,
    remove: e=>{
        const t = e.parentNode;
        t && t.removeChild(e)
    }
    ,
    createElement: (e,t,n,r)=>{
        const i = t ? Or.createElementNS(k_, e) : Or.createElement(e, n ? {
            is: n
        } : void 0);
        return e === "select" && r && r.multiple != null && i.setAttribute("multiple", r.multiple),
            i
    }
    ,
    createText: e=>Or.createTextNode(e),
    createComment: e=>Or.createComment(e),
    setText: (e,t)=>{
        e.nodeValue = t
    }
    ,
    setElementText: (e,t)=>{
        e.textContent = t
    }
    ,
    parentNode: e=>e.parentNode,
    nextSibling: e=>e.nextSibling,
    querySelector: e=>Or.querySelector(e),
    setScopeId(e, t) {
        e.setAttribute(t, "")
    },
    insertStaticContent(e, t, n, r, i, s) {
        const o = n ? n.previousSibling : t.lastChild;
        if (i && (i === s || i.nextSibling))
            for (; t.insertBefore(i.cloneNode(!0), n),
                       !(i === s || !(i = i.nextSibling)); )
                ;
        else {
            vd.innerHTML = r ? `<svg>${e}</svg>` : e;
            const a = vd.content;
            if (r) {
                const l = a.firstChild;
                for (; l.firstChild; )
                    a.appendChild(l.firstChild);
                a.removeChild(l)
            }
            t.insertBefore(a, n)
        }
        return [o ? o.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
    }
};
function L_(e, t, n) {
    const r = e._vtc;
    r && (t = (t ? [t, ...r] : [...r]).join(" ")),
        t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t
}
function O_(e, t, n) {
    const r = e.style
        , i = rt(n);
    if (n && !i) {
        if (t && !rt(t))
            for (const s in t)
                n[s] == null && hc(r, s, "");
        for (const s in n)
            hc(r, s, n[s])
    } else {
        const s = r.display;
        i ? t !== n && (r.cssText = n) : t && e.removeAttribute("style"),
        "_vod"in e && (r.display = s)
    }
}
const yd = /\s*!important$/;
function hc(e, t, n) {
    if (be(n))
        n.forEach(r=>hc(e, t, r));
    else if (n == null && (n = ""),
        t.startsWith("--"))
        e.setProperty(t, n);
    else {
        const r = A_(e, t);
        yd.test(n) ? e.setProperty(cn(r), n.replace(yd, ""), "important") : e[r] = n
    }
}
const bd = ["Webkit", "Moz", "ms"]
    , Sl = {};
function A_(e, t) {
    const n = Sl[t];
    if (n)
        return n;
    let r = Gt(t);
    if (r !== "filter" && r in e)
        return Sl[t] = r;
    r = Ys(r);
    for (let i = 0; i < bd.length; i++) {
        const s = bd[i] + r;
        if (s in e)
            return Sl[t] = s
    }
    return t
}
const wd = "http://www.w3.org/1999/xlink";
function I_(e, t, n, r, i) {
    if (r && t.startsWith("xlink:"))
        n == null ? e.removeAttributeNS(wd, t.slice(6, t.length)) : e.setAttributeNS(wd, t, n);
    else {
        const s = hw(t);
        n == null || s && !Rm(n) ? e.removeAttribute(t) : e.setAttribute(t, s ? "" : n)
    }
}
function M_(e, t, n, r, i, s, o) {
    if (t === "innerHTML" || t === "textContent") {
        r && o(r, i, s),
            e[t] = n ?? "";
        return
    }
    const a = e.tagName;
    if (t === "value" && a !== "PROGRESS" && !a.includes("-")) {
        e._value = n;
        const c = a === "OPTION" ? e.getAttribute("value") : e.value
            , u = n ?? "";
        c !== u && (e.value = u),
        n == null && e.removeAttribute(t);
        return
    }
    let l = !1;
    if (n === "" || n == null) {
        const c = typeof e[t];
        c === "boolean" ? n = Rm(n) : n == null && c === "string" ? (n = "",
            l = !0) : c === "number" && (n = 0,
            l = !0)
    }
    try {
        e[t] = n
    } catch {}
    l && e.removeAttribute(t)
}
function Xn(e, t, n, r) {
    e.addEventListener(t, n, r)
}
function D_(e, t, n, r) {
    e.removeEventListener(t, n, r)
}
function N_(e, t, n, r, i=null) {
    const s = e._vei || (e._vei = {})
        , o = s[t];
    if (r && o)
        o.value = r;
    else {
        const [a,l] = $_(t);
        if (r) {
            const c = s[t] = H_(r, i);
            Xn(e, a, c, l)
        } else
            o && (D_(e, a, o, l),
                s[t] = void 0)
    }
}
const Sd = /(?:Once|Passive|Capture)$/;
function $_(e) {
    let t;
    if (Sd.test(e)) {
        t = {};
        let r;
        for (; r = e.match(Sd); )
            e = e.slice(0, e.length - r[0].length),
                t[r[0].toLowerCase()] = !0
    }
    return [e[2] === ":" ? e.slice(3) : cn(e.slice(2)), t]
}
let _l = 0;
const F_ = Promise.resolve()
    , j_ = ()=>_l || (F_.then(()=>_l = 0),
    _l = Date.now());
function H_(e, t) {
    const n = r=>{
            if (!r._vts)
                r._vts = Date.now();
            else if (r._vts <= n.attached)
                return;
            tn(B_(r, n.value), t, 5, [r])
        }
    ;
    return n.value = e,
        n.attached = j_(),
        n
}
function B_(e, t) {
    if (be(t)) {
        const n = e.stopImmediatePropagation;
        return e.stopImmediatePropagation = ()=>{
            n.call(e),
                e._stopped = !0
        }
            ,
            t.map(r=>i=>!i._stopped && r && r(i))
    } else
        return t
}
const _d = /^on[a-z]/
    , V_ = (e,t,n,r,i=!1,s,o,a,l)=>{
        t === "class" ? L_(e, r, i) : t === "style" ? O_(e, n, r) : Ks(t) ? gu(t) || N_(e, t, n, r, o) : (t[0] === "." ? (t = t.slice(1),
            !0) : t[0] === "^" ? (t = t.slice(1),
            !1) : z_(e, t, r, i)) ? M_(e, t, r, s, o, a, l) : (t === "true-value" ? e._trueValue = r : t === "false-value" && (e._falseValue = r),
            I_(e, t, r, i))
    }
;
function z_(e, t, n, r) {
    return r ? !!(t === "innerHTML" || t === "textContent" || t in e && _d.test(t) && Le(n)) : t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA" || _d.test(t) && rt(n) ? !1 : t in e
}
function Vg(e, t) {
    const n = Xe(e);
    class r extends Xa {
        constructor(s) {
            super(n, s, t)
        }
    }
    return r.def = n,
        r
}
const U_ = e=>Vg(e, sv)
    , W_ = typeof HTMLElement < "u" ? HTMLElement : class {
    }
;
class Xa extends W_ {
    constructor(t, n={}, r) {
        super(),
            this._def = t,
            this._props = n,
            this._instance = null,
            this._connected = !1,
            this._resolved = !1,
            this._numberProps = null,
            this.shadowRoot && r ? r(this._createVNode(), this.shadowRoot) : (this.attachShadow({
                mode: "open"
            }),
            this._def.__asyncLoader || this._resolveProps(this._def))
    }
    connectedCallback() {
        this._connected = !0,
        this._instance || (this._resolved ? this._update() : this._resolveDef())
    }
    disconnectedCallback() {
        this._connected = !1,
            ct(()=>{
                    this._connected || (vc(null, this.shadowRoot),
                        this._instance = null)
                }
            )
    }
    _resolveDef() {
        this._resolved = !0;
        for (let r = 0; r < this.attributes.length; r++)
            this._setAttr(this.attributes[r].name);
        new MutationObserver(r=>{
                for (const i of r)
                    this._setAttr(i.attributeName)
            }
        ).observe(this, {
            attributes: !0
        });
        const t = (r,i=!1)=>{
            const {props: s, styles: o} = r;
            let a;
            if (s && !be(s))
                for (const l in s) {
                    const c = s[l];
                    (c === Number || c && c.type === Number) && (l in this._props && (this._props[l] = ea(this._props[l])),
                        (a || (a = Object.create(null)))[Gt(l)] = !0)
                }
            this._numberProps = a,
            i && this._resolveProps(r),
                this._applyStyles(o),
                this._update()
        }
            , n = this._def.__asyncLoader;
        n ? n().then(r=>t(r, !0)) : t(this._def)
    }
    _resolveProps(t) {
        const {props: n} = t
            , r = be(n) ? n : Object.keys(n || {});
        for (const i of Object.keys(this))
            i[0] !== "_" && r.includes(i) && this._setProp(i, this[i], !0, !1);
        for (const i of r.map(Gt))
            Object.defineProperty(this, i, {
                get() {
                    return this._getProp(i)
                },
                set(s) {
                    this._setProp(i, s)
                }
            })
    }
    _setAttr(t) {
        let n = this.getAttribute(t);
        const r = Gt(t);
        this._numberProps && this._numberProps[r] && (n = ea(n)),
            this._setProp(r, n, !1)
    }
    _getProp(t) {
        return this._props[t]
    }
    _setProp(t, n, r=!0, i=!0) {
        n !== this._props[t] && (this._props[t] = n,
        i && this._instance && this._update(),
        r && (n === !0 ? this.setAttribute(cn(t), "") : typeof n == "string" || typeof n == "number" ? this.setAttribute(cn(t), n + "") : n || this.removeAttribute(cn(t))))
    }
    _update() {
        vc(this._createVNode(), this.shadowRoot)
    }
    _createVNode() {
        const t = Re(this._def, Ze({}, this._props));
        return this._instance || (t.ce = n=>{
                this._instance = n,
                    n.isCE = !0;
                const r = (s,o)=>{
                        this.dispatchEvent(new CustomEvent(s,{
                            detail: o
                        }))
                    }
                ;
                n.emit = (s,...o)=>{
                    r(s, o),
                    cn(s) !== s && r(cn(s), o)
                }
                ;
                let i = this;
                for (; i = i && (i.parentNode || i.host); )
                    if (i instanceof Xa) {
                        n.parent = i._instance,
                            n.provides = i._instance.provides;
                        break
                    }
            }
        ),
            t
    }
    _applyStyles(t) {
        t && t.forEach(n=>{
                const r = document.createElement("style");
                r.textContent = n,
                    this.shadowRoot.appendChild(r)
            }
        )
    }
}
function G_(e="$style") {
    {
        const t = Ot();
        if (!t)
            return Ye;
        const n = t.type.__cssModules;
        if (!n)
            return Ye;
        const r = n[e];
        return r || Ye
    }
}
function X_(e) {
    const t = Ot();
    if (!t)
        return;
    const n = t.ut = (i=e(t.proxy))=>{
            Array.from(document.querySelectorAll(`[data-v-owner="${t.uid}"]`)).forEach(s=>gc(s, i))
        }
        , r = ()=>{
            const i = e(t.proxy);
            mc(t.subTree, i),
                n(i)
        }
    ;
    tg(r),
        Ve(()=>{
                const i = new MutationObserver(r);
                i.observe(t.subTree.el.parentNode, {
                    childList: !0
                }),
                    Kt(()=>i.disconnect())
            }
        )
}
function mc(e, t) {
    if (e.shapeFlag & 128) {
        const n = e.suspense;
        e = n.activeBranch,
        n.pendingBranch && !n.isHydrating && n.effects.push(()=>{
                mc(n.activeBranch, t)
            }
        )
    }
    for (; e.component; )
        e = e.component.subTree;
    if (e.shapeFlag & 1 && e.el)
        gc(e.el, t);
    else if (e.type === nt)
        e.children.forEach(n=>mc(n, t));
    else if (e.type === Fr) {
        let {el: n, anchor: r} = e;
        for (; n && (gc(n, t),
        n !== r); )
            n = n.nextSibling
    }
}
function gc(e, t) {
    if (e.nodeType === 1) {
        const n = e.style;
        for (const r in t)
            n.setProperty(`--${r}`, t[r])
    }
}
const rr = "transition"
    , Ji = "animation"
    , Ur = (e,{slots: t})=>yt(rg, Ug(e), t);
Ur.displayName = "Transition";
const zg = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
}
    , K_ = Ur.props = Ze({}, Mu, zg)
    , kr = (e,t=[])=>{
    be(e) ? e.forEach(n=>n(...t)) : e && e(...t)
}
    , Ed = e=>e ? be(e) ? e.some(t=>t.length > 1) : e.length > 1 : !1;
function Ug(e) {
    const t = {};
    for (const x in e)
        x in zg || (t[x] = e[x]);
    if (e.css === !1)
        return t;
    const {name: n="v", type: r, duration: i, enterFromClass: s=`${n}-enter-from`, enterActiveClass: o=`${n}-enter-active`, enterToClass: a=`${n}-enter-to`, appearFromClass: l=s, appearActiveClass: c=o, appearToClass: u=a, leaveFromClass: f=`${n}-leave-from`, leaveActiveClass: d=`${n}-leave-active`, leaveToClass: h=`${n}-leave-to`} = e
        , y = Y_(i)
        , p = y && y[0]
        , w = y && y[1]
        , {onBeforeEnter: m, onEnter: g, onEnterCancelled: b, onLeave: v, onLeaveCancelled: S, onBeforeAppear: _=m, onAppear: E=g, onAppearCancelled: T=b} = t
        , P = (x,A,k)=>{
            or(x, A ? u : a),
                or(x, A ? c : o),
            k && k()
        }
        , I = (x,A)=>{
            x._isLeaving = !1,
                or(x, f),
                or(x, h),
                or(x, d),
            A && A()
        }
        , L = x=>(A,k)=>{
            const O = x ? E : g
                , N = ()=>P(A, x, k);
            kr(O, [A, N]),
                Cd(()=>{
                        or(A, x ? l : s),
                            zn(A, x ? u : a),
                        Ed(O) || Td(A, r, p, N)
                    }
                )
        }
    ;
    return Ze(t, {
        onBeforeEnter(x) {
            kr(m, [x]),
                zn(x, s),
                zn(x, o)
        },
        onBeforeAppear(x) {
            kr(_, [x]),
                zn(x, l),
                zn(x, c)
        },
        onEnter: L(!1),
        onAppear: L(!0),
        onLeave(x, A) {
            x._isLeaving = !0;
            const k = ()=>I(x, A);
            zn(x, f),
                Gg(),
                zn(x, d),
                Cd(()=>{
                        x._isLeaving && (or(x, f),
                            zn(x, h),
                        Ed(v) || Td(x, r, w, k))
                    }
                ),
                kr(v, [x, k])
        },
        onEnterCancelled(x) {
            P(x, !1),
                kr(b, [x])
        },
        onAppearCancelled(x) {
            P(x, !0),
                kr(T, [x])
        },
        onLeaveCancelled(x) {
            I(x),
                kr(S, [x])
        }
    })
}
function Y_(e) {
    if (e == null)
        return null;
    if (qe(e))
        return [El(e.enter), El(e.leave)];
    {
        const t = El(e);
        return [t, t]
    }
}
function El(e) {
    return ea(e)
}
function zn(e, t) {
    t.split(/\s+/).forEach(n=>n && e.classList.add(n)),
        (e._vtc || (e._vtc = new Set)).add(t)
}
function or(e, t) {
    t.split(/\s+/).forEach(r=>r && e.classList.remove(r));
    const {_vtc: n} = e;
    n && (n.delete(t),
    n.size || (e._vtc = void 0))
}
function Cd(e) {
    requestAnimationFrame(()=>{
            requestAnimationFrame(e)
        }
    )
}
let q_ = 0;
function Td(e, t, n, r) {
    const i = e._endId = ++q_
        , s = ()=>{
            i === e._endId && r()
        }
    ;
    if (n)
        return setTimeout(s, n);
    const {type: o, timeout: a, propCount: l} = Wg(e, t);
    if (!o)
        return r();
    const c = o + "end";
    let u = 0;
    const f = ()=>{
            e.removeEventListener(c, d),
                s()
        }
        , d = h=>{
            h.target === e && ++u >= l && f()
        }
    ;
    setTimeout(()=>{
            u < l && f()
        }
        , a + 1),
        e.addEventListener(c, d)
}
function Wg(e, t) {
    const n = window.getComputedStyle(e)
        , r = y=>(n[y] || "").split(", ")
        , i = r(`${rr}Delay`)
        , s = r(`${rr}Duration`)
        , o = xd(i, s)
        , a = r(`${Ji}Delay`)
        , l = r(`${Ji}Duration`)
        , c = xd(a, l);
    let u = null
        , f = 0
        , d = 0;
    t === rr ? o > 0 && (u = rr,
        f = o,
        d = s.length) : t === Ji ? c > 0 && (u = Ji,
        f = c,
        d = l.length) : (f = Math.max(o, c),
        u = f > 0 ? o > c ? rr : Ji : null,
        d = u ? u === rr ? s.length : l.length : 0);
    const h = u === rr && /\b(transform|all)(,|$)/.test(r(`${rr}Property`).toString());
    return {
        type: u,
        timeout: f,
        propCount: d,
        hasTransform: h
    }
}
function xd(e, t) {
    for (; e.length < t.length; )
        e = e.concat(e);
    return Math.max(...t.map((n,r)=>Pd(n) + Pd(e[r])))
}
function Pd(e) {
    return Number(e.slice(0, -1).replace(",", ".")) * 1e3
}
function Gg() {
    return document.body.offsetHeight
}
const Xg = new WeakMap
    , Kg = new WeakMap
    , Yg = {
    name: "TransitionGroup",
    props: Ze({}, K_, {
        tag: String,
        moveClass: String
    }),
    setup(e, {slots: t}) {
        const n = Ot()
            , r = Iu();
        let i, s;
        return Va(()=>{
                if (!i.length)
                    return;
                const o = e.moveClass || `${e.name || "v"}-move`;
                if (!tE(i[0].el, n.vnode.el, o))
                    return;
                i.forEach(Z_),
                    i.forEach(Q_);
                const a = i.filter(eE);
                Gg(),
                    a.forEach(l=>{
                            const c = l.el
                                , u = c.style;
                            zn(c, o),
                                u.transform = u.webkitTransform = u.transitionDuration = "";
                            const f = c._moveCb = d=>{
                                    d && d.target !== c || (!d || /transform$/.test(d.propertyName)) && (c.removeEventListener("transitionend", f),
                                        c._moveCb = null,
                                        or(c, o))
                                }
                            ;
                            c.addEventListener("transitionend", f)
                        }
                    )
            }
        ),
            ()=>{
                const o = ke(e)
                    , a = Ug(o);
                let l = o.tag || nt;
                i = s,
                    s = t.default ? Ha(t.default()) : [];
                for (let c = 0; c < s.length; c++) {
                    const u = s[c];
                    u.key != null && Vr(u, Li(u, a, r, n))
                }
                if (i)
                    for (let c = 0; c < i.length; c++) {
                        const u = i[c];
                        Vr(u, Li(u, a, r, n)),
                            Xg.set(u, u.el.getBoundingClientRect())
                    }
                return Re(l, null, s)
            }
    }
}
    , J_ = e=>delete e.mode;
Yg.props;
const Xu = Yg;
function Z_(e) {
    const t = e.el;
    t._moveCb && t._moveCb(),
    t._enterCb && t._enterCb()
}
function Q_(e) {
    Kg.set(e, e.el.getBoundingClientRect())
}
function eE(e) {
    const t = Xg.get(e)
        , n = Kg.get(e)
        , r = t.left - n.left
        , i = t.top - n.top;
    if (r || i) {
        const s = e.el.style;
        return s.transform = s.webkitTransform = `translate(${r}px,${i}px)`,
            s.transitionDuration = "0s",
            e
    }
}
function tE(e, t, n) {
    const r = e.cloneNode();
    e._vtc && e._vtc.forEach(o=>{
            o.split(/\s+/).forEach(a=>a && r.classList.remove(a))
        }
    ),
        n.split(/\s+/).forEach(o=>o && r.classList.add(o)),
        r.style.display = "none";
    const i = t.nodeType === 1 ? t : t.parentNode;
    i.appendChild(r);
    const {hasTransform: s} = Wg(r);
    return i.removeChild(r),
        s
}
const wr = e=>{
        const t = e.props["onUpdate:modelValue"] || !1;
        return be(t) ? n=>Ci(t, n) : t
    }
;
function nE(e) {
    e.target.composing = !0
}
function kd(e) {
    const t = e.target;
    t.composing && (t.composing = !1,
        t.dispatchEvent(new Event("input")))
}
const oa = {
    created(e, {modifiers: {lazy: t, trim: n, number: r}}, i) {
        e._assign = wr(i);
        const s = r || i.props && i.props.type === "number";
        Xn(e, t ? "change" : "input", o=>{
                if (o.target.composing)
                    return;
                let a = e.value;
                n && (a = a.trim()),
                s && (a = Qo(a)),
                    e._assign(a)
            }
        ),
        n && Xn(e, "change", ()=>{
                e.value = e.value.trim()
            }
        ),
        t || (Xn(e, "compositionstart", nE),
            Xn(e, "compositionend", kd),
            Xn(e, "change", kd))
    },
    mounted(e, {value: t}) {
        e.value = t ?? ""
    },
    beforeUpdate(e, {value: t, modifiers: {lazy: n, trim: r, number: i}}, s) {
        if (e._assign = wr(s),
        e.composing || document.activeElement === e && e.type !== "range" && (n || r && e.value.trim() === t || (i || e.type === "number") && Qo(e.value) === t))
            return;
        const o = t ?? "";
        e.value !== o && (e.value = o)
    }
}
    , Ku = {
    deep: !0,
    created(e, t, n) {
        e._assign = wr(n),
            Xn(e, "change", ()=>{
                    const r = e._modelValue
                        , i = Ai(e)
                        , s = e.checked
                        , o = e._assign;
                    if (be(r)) {
                        const a = Ra(r, i)
                            , l = a !== -1;
                        if (s && !l)
                            o(r.concat(i));
                        else if (!s && l) {
                            const c = [...r];
                            c.splice(a, 1),
                                o(c)
                        }
                    } else if (Yr(r)) {
                        const a = new Set(r);
                        s ? a.add(i) : a.delete(i),
                            o(a)
                    } else
                        o(Jg(e, s))
                }
            )
    },
    mounted: Rd,
    beforeUpdate(e, t, n) {
        e._assign = wr(n),
            Rd(e, t, n)
    }
};
function Rd(e, {value: t, oldValue: n}, r) {
    e._modelValue = t,
        be(t) ? e.checked = Ra(t, r.props.value) > -1 : Yr(t) ? e.checked = t.has(r.props.value) : t !== n && (e.checked = pr(t, Jg(e, !0)))
}
const Yu = {
    created(e, {value: t}, n) {
        e.checked = pr(t, n.props.value),
            e._assign = wr(n),
            Xn(e, "change", ()=>{
                    e._assign(Ai(e))
                }
            )
    },
    beforeUpdate(e, {value: t, oldValue: n}, r) {
        e._assign = wr(r),
        t !== n && (e.checked = pr(t, r.props.value))
    }
}
    , qg = {
    deep: !0,
    created(e, {value: t, modifiers: {number: n}}, r) {
        const i = Yr(t);
        Xn(e, "change", ()=>{
                const s = Array.prototype.filter.call(e.options, o=>o.selected).map(o=>n ? Qo(Ai(o)) : Ai(o));
                e._assign(e.multiple ? i ? new Set(s) : s : s[0])
            }
        ),
            e._assign = wr(r)
    },
    mounted(e, {value: t}) {
        Ld(e, t)
    },
    beforeUpdate(e, t, n) {
        e._assign = wr(n)
    },
    updated(e, {value: t}) {
        Ld(e, t)
    }
};
function Ld(e, t) {
    const n = e.multiple;
    if (!(n && !be(t) && !Yr(t))) {
        for (let r = 0, i = e.options.length; r < i; r++) {
            const s = e.options[r]
                , o = Ai(s);
            if (n)
                be(t) ? s.selected = Ra(t, o) > -1 : s.selected = t.has(o);
            else if (pr(Ai(s), t)) {
                e.selectedIndex !== r && (e.selectedIndex = r);
                return
            }
        }
        !n && e.selectedIndex !== -1 && (e.selectedIndex = -1)
    }
}
function Ai(e) {
    return "_value"in e ? e._value : e.value
}
function Jg(e, t) {
    const n = t ? "_trueValue" : "_falseValue";
    return n in e ? e[n] : t
}
const Zg = {
    created(e, t, n) {
        bo(e, t, n, null, "created")
    },
    mounted(e, t, n) {
        bo(e, t, n, null, "mounted")
    },
    beforeUpdate(e, t, n, r) {
        bo(e, t, n, r, "beforeUpdate")
    },
    updated(e, t, n, r) {
        bo(e, t, n, r, "updated")
    }
};
function Qg(e, t) {
    switch (e) {
        case "SELECT":
            return qg;
        case "TEXTAREA":
            return oa;
        default:
            switch (t) {
                case "checkbox":
                    return Ku;
                case "radio":
                    return Yu;
                default:
                    return oa
            }
    }
}
function bo(e, t, n, r, i) {
    const o = Qg(e.tagName, n.props && n.props.type)[i];
    o && o(e, t, n, r)
}
function rE() {
    oa.getSSRProps = ({value: e})=>({
        value: e
    }),
        Yu.getSSRProps = ({value: e},t)=>{
            if (t.props && pr(t.props.value, e))
                return {
                    checked: !0
                }
        }
        ,
        Ku.getSSRProps = ({value: e},t)=>{
            if (be(e)) {
                if (t.props && Ra(e, t.props.value) > -1)
                    return {
                        checked: !0
                    }
            } else if (Yr(e)) {
                if (t.props && e.has(t.props.value))
                    return {
                        checked: !0
                    }
            } else if (e)
                return {
                    checked: !0
                }
        }
        ,
        Zg.getSSRProps = (e,t)=>{
            if (typeof t.type != "string")
                return;
            const n = Qg(t.type.toUpperCase(), t.props && t.props.type);
            if (n.getSSRProps)
                return n.getSSRProps(e, t)
        }
}
const iE = ["ctrl", "shift", "alt", "meta"]
    , sE = {
    stop: e=>e.stopPropagation(),
    prevent: e=>e.preventDefault(),
    self: e=>e.target !== e.currentTarget,
    ctrl: e=>!e.ctrlKey,
    shift: e=>!e.shiftKey,
    alt: e=>!e.altKey,
    meta: e=>!e.metaKey,
    left: e=>"button"in e && e.button !== 0,
    middle: e=>"button"in e && e.button !== 1,
    right: e=>"button"in e && e.button !== 2,
    exact: (e,t)=>iE.some(n=>e[`${n}Key`] && !t.includes(n))
}
    , ev = (e,t)=>(n,...r)=>{
    for (let i = 0; i < t.length; i++) {
        const s = sE[t[i]];
        if (s && s(n, t))
            return
    }
    return e(n, ...r)
}
    , oE = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
}
    , aE = (e,t)=>n=>{
    if (!("key"in n))
        return;
    const r = cn(n.key);
    if (t.some(i=>i === r || oE[i] === r))
        return e(n)
}
    , tv = {
    beforeMount(e, {value: t}, {transition: n}) {
        e._vod = e.style.display === "none" ? "" : e.style.display,
            n && t ? n.beforeEnter(e) : Zi(e, t)
    },
    mounted(e, {value: t}, {transition: n}) {
        n && t && n.enter(e)
    },
    updated(e, {value: t, oldValue: n}, {transition: r}) {
        !t != !n && (r ? t ? (r.beforeEnter(e),
            Zi(e, !0),
            r.enter(e)) : r.leave(e, ()=>{
                Zi(e, !1)
            }
        ) : Zi(e, t))
    },
    beforeUnmount(e, {value: t}) {
        Zi(e, t)
    }
};
function Zi(e, t) {
    e.style.display = t ? e._vod : "none"
}
function lE() {
    tv.getSSRProps = ({value: e})=>{
        if (!e)
            return {
                style: {
                    display: "none"
                }
            }
    }
}
const nv = Ze({
    patchProp: V_
}, R_);
let bs, Od = !1;
function rv() {
    return bs || (bs = Tg(nv))
}
function iv() {
    return bs = Od ? bs : xg(nv),
        Od = !0,
        bs
}
const vc = (...e)=>{
        rv().render(...e)
    }
    , sv = (...e)=>{
        iv().hydrate(...e)
    }
    , ov = (...e)=>{
        const t = rv().createApp(...e)
            , {mount: n} = t;
        return t.mount = r=>{
            const i = lv(r);
            if (!i)
                return;
            const s = t._component;
            !Le(s) && !s.render && !s.template && (s.template = i.innerHTML),
                i.innerHTML = "";
            const o = n(i, !1, i instanceof SVGElement);
            return i instanceof Element && (i.removeAttribute("v-cloak"),
                i.setAttribute("data-v-app", "")),
                o
        }
            ,
            t
    }
    , av = (...e)=>{
        const t = iv().createApp(...e)
            , {mount: n} = t;
        return t.mount = r=>{
            const i = lv(r);
            if (i)
                return n(i, !0, i instanceof SVGElement)
        }
            ,
            t
    }
;
function lv(e) {
    return rt(e) ? document.querySelector(e) : e
}
let Ad = !1;
const cE = ()=>{
    Ad || (Ad = !0,
        rE(),
        lE())
}
    , uE = ()=>{}
    , fE = Object.freeze(Object.defineProperty({
    __proto__: null,
    BaseTransition: rg,
    BaseTransitionPropsValidators: Mu,
    Comment: kt,
    EffectScope: wu,
    Fragment: nt,
    KeepAlive: sg,
    ReactiveEffect: qs,
    Static: Fr,
    Suspense: ja,
    Teleport: cc,
    Text: vr,
    Transition: Ur,
    TransitionGroup: Xu,
    VueElement: Xa,
    assertNumber: iS,
    callWithAsyncErrorHandling: tn,
    callWithErrorHandling: Kn,
    camelize: Gt,
    capitalize: Ys,
    cloneVNode: Tn,
    compatUtils: P_,
    compile: uE,
    computed: fe,
    createApp: ov,
    createBlock: gt,
    createCommentVNode: Wt,
    createElementBlock: Qe,
    createElementVNode: Te,
    createHydrationRenderer: xg,
    createPropsRestProxy: XS,
    createRenderer: Tg,
    createSSRApp: av,
    createSlots: AS,
    createStaticVNode: h_,
    createTextVNode: Wa,
    createVNode: Re,
    customRef: Gm,
    defineAsyncComponent: PS,
    defineComponent: Xe,
    defineCustomElement: Vg,
    defineEmits: NS,
    defineExpose: $S,
    defineModel: HS,
    defineOptions: FS,
    defineProps: DS,
    defineSSRCustomElement: U_,
    defineSlots: jS,
    get devtools() {
        return hi
    },
    effect: yw,
    effectScope: La,
    getCurrentInstance: Ot,
    getCurrentScope: Su,
    getTransitionRawChildren: Ha,
    guardReactiveProps: Ag,
    h: yt,
    handleError: qr,
    hasInjectionContext: Bu,
    hydrate: sv,
    initCustomFormatter: __,
    initDirectivesForSSR: cE,
    inject: vt,
    isMemoSame: Hg,
    isProxy: Cu,
    isReactive: Nr,
    isReadonly: mr,
    isRef: Je,
    isRuntimeOnly: b_,
    isShallow: Ps,
    isVNode: yr,
    markRaw: Tu,
    mergeDefaults: WS,
    mergeModels: GS,
    mergeProps: Wu,
    nextTick: ct,
    normalizeClass: Pt,
    normalizeProps: dw,
    normalizeStyle: Br,
    onActivated: og,
    onBeforeMount: cg,
    onBeforeUnmount: za,
    onBeforeUpdate: ug,
    onDeactivated: ag,
    onErrorCaptured: Du,
    onMounted: Ve,
    onRenderTracked: pg,
    onRenderTriggered: dg,
    onScopeDispose: Am,
    onServerPrefetch: fg,
    onUnmounted: Kt,
    onUpdated: Va,
    openBlock: Ae,
    popScopeId: fS,
    provide: Dn,
    proxyRefs: ku,
    pushScopeId: uS,
    queuePostFlushCb: Lu,
    reactive: nn,
    readonly: _r,
    ref: X,
    registerRuntimeCompiler: y_,
    render: vc,
    renderList: ju,
    renderSlot: Wi,
    resolveComponent: hg,
    resolveDirective: OS,
    resolveDynamicComponent: $u,
    resolveFilter: x_,
    resolveTransitionHooks: Li,
    setBlockTracking: uc,
    setDevtoolsHook: Jm,
    setTransitionHooks: Vr,
    shallowReactive: Ui,
    shallowReadonly: Gw,
    shallowRef: gr,
    ssrContextKey: Fg,
    ssrUtils: T_,
    stop: bw,
    toDisplayString: _n,
    toHandlerKey: ms,
    toHandlers: IS,
    toRaw: ke,
    toRef: Ri,
    toRefs: Zw,
    toValue: Yw,
    transformVNodeArgs: d_,
    triggerRef: Kw,
    unref: we,
    useAttrs: zS,
    useCssModule: G_,
    useCssVars: X_,
    useModel: US,
    useSSRContext: jg,
    useSlots: VS,
    useTransitionState: Iu,
    vModelCheckbox: Ku,
    vModelDynamic: Zg,
    vModelRadio: Yu,
    vModelSelect: qg,
    vModelText: oa,
    vShow: tv,
    version: Bg,
    warn: rS,
    watch: Se,
    watchEffect: Er,
    watchPostEffect: tg,
    watchSyncEffect: ES,
    withAsyncContext: KS,
    withCtx: mt,
    withDefaults: BS,
    withDirectives: TS,
    withKeys: aE,
    withMemo: E_,
    withModifiers: ev,
    withScopeId: dS
}, Symbol.toStringTag, {
    value: "Module"
}))
    , dE = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/
    , pE = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/
    , hE = /^\s*["[{]|^\s*-?\d[\d.]{0,14}\s*$/;
function mE(e, t) {
    if (e === "__proto__" || e === "constructor" && t && typeof t == "object" && "prototype"in t) {
        gE(e);
        return
    }
    return t
}
function gE(e) {
    console.warn(`[destr] Dropping "${e}" key to prevent prototype pollution.`)
}
function cv(e, t={}) {
    if (typeof e != "string")
        return e;
    const n = e.trim();
    if (e[0] === '"' && e[e.length - 1] === '"')
        return n.slice(1, -1);
    const r = n.toLowerCase();
    if (r === "true")
        return !0;
    if (r === "false")
        return !1;
    if (r !== "undefined") {
        if (r === "null")
            return null;
        if (r === "nan")
            return Number.NaN;
        if (r === "infinity")
            return Number.POSITIVE_INFINITY;
        if (r === "-infinity")
            return Number.NEGATIVE_INFINITY;
        if (!hE.test(e)) {
            if (t.strict)
                throw new SyntaxError("[destr] Invalid JSON");
            return e
        }
        try {
            if (dE.test(e) || pE.test(e)) {
                if (t.strict)
                    throw new Error("[destr] Possible prototype pollution");
                return JSON.parse(e, mE)
            }
            return JSON.parse(e)
        } catch (i) {
            if (t.strict)
                throw i;
            return e
        }
    }
}
const vE = /#/g
    , yE = /&/g
    , bE = /=/g
    , qu = /\+/g
    , wE = /%5e/gi
    , SE = /%60/gi
    , _E = /%7c/gi
    , EE = /%20/gi;
function CE(e) {
    return encodeURI("" + e).replace(_E, "|")
}
function yc(e) {
    return CE(typeof e == "string" ? e : JSON.stringify(e)).replace(qu, "%2B").replace(EE, "+").replace(vE, "%23").replace(yE, "%26").replace(SE, "`").replace(wE, "^")
}
function Cl(e) {
    return yc(e).replace(bE, "%3D")
}
function aa(e="") {
    try {
        return decodeURIComponent("" + e)
    } catch {
        return "" + e
    }
}
function TE(e) {
    return aa(e.replace(qu, " "))
}
function xE(e) {
    return aa(e.replace(qu, " "))
}
function PE(e="") {
    const t = {};
    e[0] === "?" && (e = e.slice(1));
    for (const n of e.split("&")) {
        const r = n.match(/([^=]+)=?(.*)/) || [];
        if (r.length < 2)
            continue;
        const i = TE(r[1]);
        if (i === "__proto__" || i === "constructor")
            continue;
        const s = xE(r[2] || "");
        t[i] === void 0 ? t[i] = s : Array.isArray(t[i]) ? t[i].push(s) : t[i] = [t[i], s]
    }
    return t
}
function kE(e, t) {
    return (typeof t == "number" || typeof t == "boolean") && (t = String(t)),
        t ? Array.isArray(t) ? t.map(n=>`${Cl(e)}=${yc(n)}`).join("&") : `${Cl(e)}=${yc(t)}` : Cl(e)
}
function RE(e) {
    return Object.keys(e).filter(t=>e[t] !== void 0).map(t=>kE(t, e[t])).filter(Boolean).join("&")
}
const LE = /^\w{2,}:([/\\]{1,2})/
    , OE = /^\w{2,}:([/\\]{2})?/
    , AE = /^([/\\]\s*){2,}[^/\\]/;
function Qs(e, t={}) {
    return typeof t == "boolean" && (t = {
        acceptRelative: t
    }),
        t.strict ? LE.test(e) : OE.test(e) || (t.acceptRelative ? AE.test(e) : !1)
}
const IE = /\/$|\/\?/;
function bc(e="", t=!1) {
    return t ? IE.test(e) : e.endsWith("/")
}
function uv(e="", t=!1) {
    if (!t)
        return (bc(e) ? e.slice(0, -1) : e) || "/";
    if (!bc(e, !0))
        return e || "/";
    const [n,...r] = e.split("?");
    return (n.slice(0, -1) || "/") + (r.length > 0 ? `?${r.join("?")}` : "")
}
function wc(e="", t=!1) {
    if (!t)
        return e.endsWith("/") ? e : e + "/";
    if (bc(e, !0))
        return e || "/";
    const [n,...r] = e.split("?");
    return n + "/" + (r.length > 0 ? `?${r.join("?")}` : "")
}
function ME(e="") {
    return e.startsWith("/")
}
function Id(e="") {
    return ME(e) ? e : "/" + e
}
function DE(e, t) {
    if (dv(t) || Qs(e))
        return e;
    const n = uv(t);
    return e.startsWith(n) ? e : eo(n, e)
}
function Md(e, t) {
    if (dv(t))
        return e;
    const n = uv(t);
    if (!e.startsWith(n))
        return e;
    const r = e.slice(n.length);
    return r[0] === "/" ? r : "/" + r
}
function fv(e, t) {
    const n = Ju(e)
        , r = {
        ...PE(n.search),
        ...t
    };
    return n.search = RE(r),
        FE(n)
}
function dv(e) {
    return !e || e === "/"
}
function NE(e) {
    return e && e !== "/"
}
const $E = /^\.?\//;
function eo(e, ...t) {
    let n = e || "";
    for (const r of t.filter(i=>NE(i)))
        if (n) {
            const i = r.replace($E, "");
            n = wc(n) + i
        } else
            n = r;
    return n
}
function pv(e, t, n={}) {
    return n.trailingSlash || (e = wc(e),
        t = wc(t)),
    n.leadingSlash || (e = Id(e),
        t = Id(t)),
    n.encoding || (e = aa(e),
        t = aa(t)),
    e === t
}
function Ju(e="", t) {
    if (!Qs(e, {
        acceptRelative: !0
    }))
        return t ? Ju(t + e) : Dd(e);
    const [n="",r,i=""] = (e.replace(/\\/g, "/").match(/([^/:]+:)?\/\/([^/@]+@)?(.*)/) || []).splice(1)
        , [s="",o=""] = (i.match(/([^#/?]*)(.*)?/) || []).splice(1)
        , {pathname: a, search: l, hash: c} = Dd(o.replace(/\/(?=[A-Za-z]:)/, ""));
    return {
        protocol: n,
        auth: r ? r.slice(0, Math.max(0, r.length - 1)) : "",
        host: s,
        pathname: a,
        search: l,
        hash: c
    }
}
function Dd(e="") {
    const [t="",n="",r=""] = (e.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
    return {
        pathname: t,
        search: n,
        hash: r
    }
}
function FE(e) {
    const t = e.pathname + (e.search ? (e.search.startsWith("?") ? "" : "?") + e.search : "") + e.hash;
    return e.protocol ? e.protocol + "//" + (e.auth ? e.auth + "@" : "") + e.host + t : t
}
class jE extends Error {
    constructor() {
        super(...arguments),
            this.name = "FetchError"
    }
}
function HE(e, t, n) {
    let r = "";
    t && (r = t.message),
        e && n ? r = `${r} (${n.status} ${n.statusText} (${e.toString()}))` : e && (r = `${r} (${e.toString()})`);
    const i = new jE(r);
    return Object.defineProperty(i, "request", {
        get() {
            return e
        }
    }),
        Object.defineProperty(i, "response", {
            get() {
                return n
            }
        }),
        Object.defineProperty(i, "data", {
            get() {
                return n && n._data
            }
        }),
        Object.defineProperty(i, "status", {
            get() {
                return n && n.status
            }
        }),
        Object.defineProperty(i, "statusText", {
            get() {
                return n && n.statusText
            }
        }),
        Object.defineProperty(i, "statusCode", {
            get() {
                return n && n.status
            }
        }),
        Object.defineProperty(i, "statusMessage", {
            get() {
                return n && n.statusText
            }
        }),
        i
}
const BE = new Set(Object.freeze(["PATCH", "POST", "PUT", "DELETE"]));
function Nd(e="GET") {
    return BE.has(e.toUpperCase())
}
function VE(e) {
    if (e === void 0)
        return !1;
    const t = typeof e;
    return t === "string" || t === "number" || t === "boolean" || t === null ? !0 : t !== "object" ? !1 : Array.isArray(e) ? !0 : e.constructor && e.constructor.name === "Object" || typeof e.toJSON == "function"
}
const zE = new Set(["image/svg", "application/xml", "application/xhtml", "application/html"])
    , UE = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function WE(e="") {
    if (!e)
        return "json";
    const t = e.split(";").shift() || "";
    return UE.test(t) ? "json" : zE.has(t) || t.startsWith("text/") ? "text" : "blob"
}
function GE(e, t, n=globalThis.Headers) {
    const r = {
        ...t,
        ...e
    };
    if (t != null && t.params && (e != null && e.params) && (r.params = {
        ...t == null ? void 0 : t.params,
        ...e == null ? void 0 : e.params
    }),
    t != null && t.query && (e != null && e.query) && (r.query = {
        ...t == null ? void 0 : t.query,
        ...e == null ? void 0 : e.query
    }),
    t != null && t.headers && (e != null && e.headers)) {
        r.headers = new n((t == null ? void 0 : t.headers) || {});
        for (const [i,s] of new n((e == null ? void 0 : e.headers) || {}))
            r.headers.set(i, s)
    }
    return r
}
const XE = new Set([408, 409, 425, 429, 500, 502, 503, 504]);
function hv(e) {
    const {fetch: t, Headers: n} = e;
    function r(o) {
        const a = o.error && o.error.name === "AbortError" || !1;
        if (o.options.retry !== !1 && !a) {
            let c;
            typeof o.options.retry == "number" ? c = o.options.retry : c = Nd(o.options.method) ? 0 : 1;
            const u = o.response && o.response.status || 500;
            if (c > 0 && XE.has(u))
                return i(o.request, {
                    ...o.options,
                    retry: c - 1
                })
        }
        const l = HE(o.request, o.error, o.response);
        throw Error.captureStackTrace && Error.captureStackTrace(l, i),
            l
    }
    const i = async function(a, l={}) {
        const c = {
            request: a,
            options: GE(l, e.defaults, n),
            response: void 0,
            error: void 0
        };
        c.options.onRequest && await c.options.onRequest(c),
        typeof c.request == "string" && (c.options.baseURL && (c.request = DE(c.request, c.options.baseURL)),
        (c.options.query || c.options.params) && (c.request = fv(c.request, {
            ...c.options.params,
            ...c.options.query
        })),
        c.options.body && Nd(c.options.method) && VE(c.options.body) && (c.options.body = typeof c.options.body == "string" ? c.options.body : JSON.stringify(c.options.body),
            c.options.headers = new n(c.options.headers || {}),
        c.options.headers.has("content-type") || c.options.headers.set("content-type", "application/json"),
        c.options.headers.has("accept") || c.options.headers.set("accept", "application/json")));
        try {
            c.response = await t(c.request, c.options)
        } catch (f) {
            return c.error = f,
            c.options.onRequestError && await c.options.onRequestError(c),
                await r(c)
        }
        const u = (c.options.parseResponse ? "json" : c.options.responseType) || WE(c.response.headers.get("content-type") || "");
        if (u === "json") {
            const f = await c.response.text()
                , d = c.options.parseResponse || cv;
            c.response._data = d(f)
        } else
            u === "stream" ? c.response._data = c.response.body : c.response._data = await c.response[u]();
        return c.options.onResponse && await c.options.onResponse(c),
            !c.options.ignoreResponseError && c.response.status >= 400 && c.response.status < 600 ? (c.options.onResponseError && await c.options.onResponseError(c),
                await r(c)) : c.response
    }
        , s = async function(a, l) {
        return (await i(a, l))._data
    };
    return s.raw = i,
        s.native = t,
        s.create = (o={})=>hv({
            ...e,
            defaults: {
                ...e.defaults,
                ...o
            }
        }),
        s
}
const mv = function() {
        if (typeof globalThis < "u")
            return globalThis;
        if (typeof self < "u")
            return self;
        if (typeof window < "u")
            return window;
        if (typeof global < "u")
            return global;
        throw new Error("unable to locate global object")
    }()
    , KE = mv.fetch || (()=>Promise.reject(new Error("[ofetch] global.fetch is not supported!")))
    , YE = mv.Headers
    , qE = hv({
        fetch: KE,
        Headers: YE
    })
    , JE = qE
    , ZE = ()=>{
        var e;
        return ((e = window == null ? void 0 : window.__NUXT__) == null ? void 0 : e.config) || {}
    }
    , la = ZE().app
    , QE = ()=>la.baseURL
    , eC = ()=>la.buildAssetsDir
    , tC = (...e)=>eo(gv(), eC(), ...e)
    , gv = (...e)=>{
        const t = la.cdnURL || la.baseURL;
        return e.length ? eo(t, ...e) : t
    }
;
globalThis.__buildAssetsURL = tC,
    globalThis.__publicAssetsURL = gv;
function Ds(e, t={}, n) {
    for (const r in e) {
        const i = e[r]
            , s = n ? `${n}:${r}` : r;
        typeof i == "object" && i !== null ? Ds(i, t, s) : typeof i == "function" && (t[s] = i)
    }
    return t
}
function nC(...e) {
    const t = {};
    for (const n of e) {
        const r = Ds(n);
        for (const i in r)
            t[i] ? t[i].push(r[i]) : t[i] = [r[i]]
    }
    for (const n in t)
        if (t[n].length > 1) {
            const r = t[n];
            t[n] = (...i)=>vv(r, s=>s(...i))
        } else
            t[n] = t[n][0];
    return t
}
function vv(e, t) {
    return e.reduce((n,r)=>n.then(()=>t(r)), Promise.resolve())
}
const rC = {
    run: e=>e()
}
    , iC = ()=>rC
    , yv = typeof console.createTask < "u" ? console.createTask : iC;
function sC(e, t) {
    const n = t.shift()
        , r = yv(n);
    return e.reduce((i,s)=>i.then(()=>r.run(()=>s(...t))), Promise.resolve())
}
function oC(e, t) {
    const n = t.shift()
        , r = yv(n);
    return Promise.all(e.map(i=>r.run(()=>i(...t))))
}
function aC(e, t) {
    return e.reduce((n,r)=>n.then(()=>r(...t || [])), Promise.resolve())
}
function lC(e, t) {
    return Promise.all(e.map(n=>n(...t || [])))
}
function Tl(e, t) {
    for (const n of [...e])
        n(t)
}
class bv {
    constructor() {
        this._hooks = {},
            this._before = void 0,
            this._after = void 0,
            this._deprecatedMessages = void 0,
            this._deprecatedHooks = {},
            this.hook = this.hook.bind(this),
            this.callHook = this.callHook.bind(this),
            this.callHookWith = this.callHookWith.bind(this)
    }
    hook(t, n, r={}) {
        if (!t || typeof n != "function")
            return ()=>{}
                ;
        const i = t;
        let s;
        for (; this._deprecatedHooks[t]; )
            s = this._deprecatedHooks[t],
                t = s.to;
        if (s && !r.allowDeprecated) {
            let o = s.message;
            o || (o = `${i} hook has been deprecated` + (s.to ? `, please use ${s.to}` : "")),
            this._deprecatedMessages || (this._deprecatedMessages = new Set),
            this._deprecatedMessages.has(o) || (console.warn(o),
                this._deprecatedMessages.add(o))
        }
        if (!n.name)
            try {
                Object.defineProperty(n, "name", {
                    get: ()=>"_" + t.replace(/\W+/g, "_") + "_hook_cb",
                    configurable: !0
                })
            } catch {}
        return this._hooks[t] = this._hooks[t] || [],
            this._hooks[t].push(n),
            ()=>{
                n && (this.removeHook(t, n),
                    n = void 0)
            }
    }
    hookOnce(t, n) {
        let r, i = (...s)=>(typeof r == "function" && r(),
            r = void 0,
            i = void 0,
            n(...s));
        return r = this.hook(t, i),
            r
    }
    removeHook(t, n) {
        if (this._hooks[t]) {
            const r = this._hooks[t].indexOf(n);
            r !== -1 && this._hooks[t].splice(r, 1),
            this._hooks[t].length === 0 && delete this._hooks[t]
        }
    }
    deprecateHook(t, n) {
        this._deprecatedHooks[t] = typeof n == "string" ? {
            to: n
        } : n;
        const r = this._hooks[t] || [];
        delete this._hooks[t];
        for (const i of r)
            this.hook(t, i)
    }
    deprecateHooks(t) {
        Object.assign(this._deprecatedHooks, t);
        for (const n in t)
            this.deprecateHook(n, t[n])
    }
    addHooks(t) {
        const n = Ds(t)
            , r = Object.keys(n).map(i=>this.hook(i, n[i]));
        return ()=>{
            for (const i of r.splice(0, r.length))
                i()
        }
    }
    removeHooks(t) {
        const n = Ds(t);
        for (const r in n)
            this.removeHook(r, n[r])
    }
    removeAllHooks() {
        for (const t in this._hooks)
            delete this._hooks[t]
    }
    callHook(t, ...n) {
        return n.unshift(t),
            this.callHookWith(sC, t, ...n)
    }
    callHookParallel(t, ...n) {
        return n.unshift(t),
            this.callHookWith(oC, t, ...n)
    }
    callHookWith(t, n, ...r) {
        const i = this._before || this._after ? {
            name: n,
            args: r,
            context: {}
        } : void 0;
        this._before && Tl(this._before, i);
        const s = t(n in this._hooks ? [...this._hooks[n]] : [], r);
        return s instanceof Promise ? s.finally(()=>{
                this._after && i && Tl(this._after, i)
            }
        ) : (this._after && i && Tl(this._after, i),
            s)
    }
    beforeEach(t) {
        return this._before = this._before || [],
            this._before.push(t),
            ()=>{
                if (this._before !== void 0) {
                    const n = this._before.indexOf(t);
                    n !== -1 && this._before.splice(n, 1)
                }
            }
    }
    afterEach(t) {
        return this._after = this._after || [],
            this._after.push(t),
            ()=>{
                if (this._after !== void 0) {
                    const n = this._after.indexOf(t);
                    n !== -1 && this._after.splice(n, 1)
                }
            }
    }
}
function wv() {
    return new bv
}
const $d = typeof window < "u";
function cC(e, t={}) {
    const n = {
        inspect: $d,
        group: $d,
        filter: ()=>!0,
        ...t
    }
        , r = n.filter
        , i = typeof r == "string" ? u=>u.startsWith(r) : r
        , s = n.tag ? `[${n.tag}] ` : ""
        , o = u=>s + u.name + "".padEnd(u._id, "\0")
        , a = {}
        , l = e.beforeEach(u=>{
            i !== void 0 && !i(u.name) || (a[u.name] = a[u.name] || 0,
                u._id = a[u.name]++,
                console.time(o(u)))
        }
    )
        , c = e.afterEach(u=>{
            i !== void 0 && !i(u.name) || (n.group && console.groupCollapsed(u.name),
                n.inspect ? console.timeLog(o(u), u.args) : console.timeEnd(o(u)),
            n.group && console.groupEnd(),
                a[u.name]--)
        }
    );
    return {
        close: ()=>{
            l(),
                c()
        }
    }
}
const uC = Object.freeze(Object.defineProperty({
    __proto__: null,
    Hookable: bv,
    createDebugger: cC,
    createHooks: wv,
    flatHooks: Ds,
    mergeHooks: nC,
    parallelCaller: lC,
    serial: vv,
    serialCaller: aC
}, Symbol.toStringTag, {
    value: "Module"
}));
function fC(e={}) {
    let t, n = !1;
    const r = o=>{
            if (t && t !== o)
                throw new Error("Context conflict")
        }
    ;
    let i;
    if (e.asyncContext) {
        const o = e.AsyncLocalStorage || globalThis.AsyncLocalStorage;
        o ? i = new o : console.warn("[unctx] `AsyncLocalStorage` is not provided.")
    }
    const s = ()=>{
            if (i && t === void 0) {
                const o = i.getStore();
                if (o !== void 0)
                    return o
            }
            return t
        }
    ;
    return {
        use: ()=>{
            const o = s();
            if (o === void 0)
                throw new Error("Context is not available");
            return o
        }
        ,
        tryUse: ()=>s(),
        set: (o,a)=>{
            a || r(o),
                t = o,
                n = !0
        }
        ,
        unset: ()=>{
            t = void 0,
                n = !1
        }
        ,
        call: (o,a)=>{
            r(o),
                t = o;
            try {
                return i ? i.run(o, a) : a()
            } finally {
                n || (t = void 0)
            }
        }
        ,
        async callAsync(o, a) {
            t = o;
            const l = ()=>{
                t = o
            }
                , c = ()=>t === o ? l : void 0;
            Sc.add(c);
            try {
                const u = i ? i.run(o, a) : a();
                return n || (t = void 0),
                    await u
            } finally {
                Sc.delete(c)
            }
        }
    }
}
function dC(e={}) {
    const t = {};
    return {
        get(n, r={}) {
            return t[n] || (t[n] = fC({
                ...e,
                ...r
            })),
                t[n],
                t[n]
        }
    }
}
const ca = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof global < "u" ? global : typeof window < "u" ? window : {}
    , Fd = "__unctx__"
    , pC = ca[Fd] || (ca[Fd] = dC())
    , hC = (e,t={})=>pC.get(e, t)
    , jd = "__unctx_async_handlers__"
    , Sc = ca[jd] || (ca[jd] = new Set);
function jr(e) {
    const t = [];
    for (const i of Sc) {
        const s = i();
        s && t.push(s)
    }
    const n = ()=>{
            for (const i of t)
                i()
        }
    ;
    let r = e();
    return r && typeof r == "object" && "catch"in r && (r = r.catch(i=>{
            throw n(),
                i
        }
    )),
        [r, n]
}
const Sv = hC("nuxt-app")
    , mC = "__nuxt_plugin";
function gC(e) {
    let t = 0;
    const n = {
        provide: void 0,
        globalName: "nuxt",
        versions: {
            get nuxt() {
                return "3.6.5"
            },
            get vue() {
                return n.vueApp.version
            }
        },
        payload: nn({
            data: {},
            state: {},
            _errors: {},
            ...window.__NUXT__ ?? {}
        }),
        static: {
            data: {}
        },
        runWithContext: i=>bC(n, i),
        isHydrating: !0,
        deferHydration() {
            if (!n.isHydrating)
                return ()=>{}
                    ;
            t++;
            let i = !1;
            return ()=>{
                if (!i && (i = !0,
                    t--,
                t === 0))
                    return n.isHydrating = !1,
                        n.callHook("app:suspense:resolve")
            }
        },
        _asyncDataPromises: {},
        _asyncData: {},
        _payloadRevivers: {},
        ...e
    };
    n.hooks = wv(),
        n.hook = n.hooks.hook,
        n.callHook = n.hooks.callHook,
        n.provide = (i,s)=>{
            const o = "$" + i;
            wo(n, o, s),
                wo(n.vueApp.config.globalProperties, o, s)
        }
        ,
        wo(n.vueApp, "$nuxt", n),
        wo(n.vueApp.config.globalProperties, "$nuxt", n);
    {
        window.addEventListener("nuxt.preloadError", s=>{
                n.callHook("app:chunkError", {
                    error: s.payload
                })
            }
        ),
            window.useNuxtApp = window.useNuxtApp || pt;
        const i = n.hook("app:error", (...s)=>{
                console.error("[nuxt] error caught during app initialization", ...s)
            }
        );
        n.hook("app:mounted", i)
    }
    const r = nn(n.payload.config);
    return n.provide("config", r),
        n
}
async function vC(e, t) {
    if (t.hooks && e.hooks.addHooks(t.hooks),
    typeof t == "function") {
        const {provide: n} = await e.runWithContext(()=>t(e)) || {};
        if (n && typeof n == "object")
            for (const r in n)
                e.provide(r, n[r])
    }
}
async function yC(e, t) {
    const n = []
        , r = [];
    for (const i of t) {
        const s = vC(e, i);
        i.parallel ? n.push(s.catch(o=>r.push(o))) : await s
    }
    if (await Promise.all(n),
        r.length)
        throw r[0]
}
/*! @__NO_SIDE_EFFECTS__ */
function dn(e) {
    return typeof e == "function" ? e : (delete e.name,
        Object.assign(e.setup || (()=>{}
        ), e, {
            [mC]: !0
        }))
}
function bC(e, t, n) {
    const r = ()=>n ? t(...n) : t();
    return Sv.set(e),
        e.vueApp.runWithContext(r)
}
/*! @__NO_SIDE_EFFECTS__ */
function pt() {
    var t;
    let e;
    if (Bu() && (e = (t = Ot()) == null ? void 0 : t.appContext.app.$nuxt),
        e = e || Sv.tryUse(),
        !e)
        throw new Error("[nuxt] instance unavailable");
    return e
}
/*! @__NO_SIDE_EFFECTS__ */
function Cr() {
    return pt().$config
}
function wo(e, t, n) {
    Object.defineProperty(e, t, {
        get: ()=>n
    })
}
const wC = "modulepreload"
    , SC = function(e, t) {
    return e.startsWith(".") ? new URL(e,t).href : e
}
    , Hd = {}
    , _C = function(t, n, r) {
    if (!n || n.length === 0)
        return t();
    const i = document.getElementsByTagName("link");
    return Promise.all(n.map(s=>{
            if (s = SC(s, r),
            s in Hd)
                return;
            Hd[s] = !0;
            const o = s.endsWith(".css")
                , a = o ? '[rel="stylesheet"]' : "";
            if (!!r)
                for (let u = i.length - 1; u >= 0; u--) {
                    const f = i[u];
                    if (f.href === s && (!o || f.rel === "stylesheet"))
                        return
                }
            else if (document.querySelector(`link[href="${s}"]${a}`))
                return;
            const c = document.createElement("link");
            if (c.rel = o ? "stylesheet" : wC,
            o || (c.as = "script",
                c.crossOrigin = ""),
                c.href = s,
                document.head.appendChild(c),
                o)
                return new Promise((u,f)=>{
                        c.addEventListener("load", u),
                            c.addEventListener("error", ()=>f(new Error(`Unable to preload CSS for ${s}`)))
                    }
                )
        }
    )).then(()=>t())
}
    , at = (...e)=>_C(...e).catch(t=>{
        const n = new Event("nuxt.preloadError");
        throw n.payload = t,
            window.dispatchEvent(n),
            t
    }
)
    , EC = -1
    , CC = -2
    , TC = -3
    , xC = -4
    , PC = -5
    , kC = -6;
function RC(e, t) {
    return LC(JSON.parse(e), t)
}
function LC(e, t) {
    if (typeof e == "number")
        return i(e, !0);
    if (!Array.isArray(e) || e.length === 0)
        throw new Error("Invalid input");
    const n = e
        , r = Array(n.length);
    function i(s, o=!1) {
        if (s === EC)
            return;
        if (s === TC)
            return NaN;
        if (s === xC)
            return 1 / 0;
        if (s === PC)
            return -1 / 0;
        if (s === kC)
            return -0;
        if (o)
            throw new Error("Invalid input");
        if (s in r)
            return r[s];
        const a = n[s];
        if (!a || typeof a != "object")
            r[s] = a;
        else if (Array.isArray(a))
            if (typeof a[0] == "string") {
                const l = a[0]
                    , c = t == null ? void 0 : t[l];
                if (c)
                    return r[s] = c(i(a[1]));
                switch (l) {
                    case "Date":
                        r[s] = new Date(a[1]);
                        break;
                    case "Set":
                        const u = new Set;
                        r[s] = u;
                        for (let h = 1; h < a.length; h += 1)
                            u.add(i(a[h]));
                        break;
                    case "Map":
                        const f = new Map;
                        r[s] = f;
                        for (let h = 1; h < a.length; h += 2)
                            f.set(i(a[h]), i(a[h + 1]));
                        break;
                    case "RegExp":
                        r[s] = new RegExp(a[1],a[2]);
                        break;
                    case "Object":
                        r[s] = Object(a[1]);
                        break;
                    case "BigInt":
                        r[s] = BigInt(a[1]);
                        break;
                    case "null":
                        const d = Object.create(null);
                        r[s] = d;
                        for (let h = 1; h < a.length; h += 2)
                            d[a[h]] = i(a[h + 1]);
                        break;
                    default:
                        throw new Error(`Unknown type ${l}`)
                }
            } else {
                const l = new Array(a.length);
                r[s] = l;
                for (let c = 0; c < a.length; c += 1) {
                    const u = a[c];
                    u !== CC && (l[c] = i(u))
                }
            }
        else {
            const l = {};
            r[s] = l;
            for (const c in a) {
                const u = a[c];
                l[c] = i(u)
            }
        }
        return r[s]
    }
    return i(0)
}
var mi = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function _v(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
function Zu(e) {
    if (e.__esModule)
        return e;
    var t = e.default;
    if (typeof t == "function") {
        var n = function r() {
            if (this instanceof r) {
                var i = [null];
                i.push.apply(i, arguments);
                var s = Function.bind.apply(t, i);
                return new s
            }
            return t.apply(this, arguments)
        };
        n.prototype = t.prototype
    } else
        n = {};
    return Object.defineProperty(n, "__esModule", {
        value: !0
    }),
        Object.keys(e).forEach(function(r) {
            var i = Object.getOwnPropertyDescriptor(e, r);
            Object.defineProperty(n, r, i.get ? i : {
                enumerable: !0,
                get: function() {
                    return e[r]
                }
            })
        }),
        n
}
var Qu = {};
const OC = Zu(uC);
var Ev = {};
function AC(e) {
    return Array.isArray(e) ? e : [e]
}
const IC = ["meta", "link", "base"]
    , MC = ["title", "script", "style", "noscript"]
    , DC = ["base", "meta", "link", "style", "script", "noscript"]
    , NC = ["title", "titleTemplate", "templateParams", "base", "htmlAttrs", "bodyAttrs", "meta", "link", "style", "script", "noscript"]
    , Cv = ["base", "title", "titleTemplate", "bodyAttrs", "htmlAttrs", "templateParams"]
    , $C = ["tagPosition", "tagPriority", "tagDuplicateStrategy", "innerHTML", "textContent"]
    , FC = ["tagPosition", "tagPriority"];
function jC(e) {
    return e
}
function Tv(e) {
    let t = 9;
    for (let n = 0; n < e.length; )
        t = Math.imul(t ^ e.charCodeAt(n++), 9 ** 9);
    return ((t ^ t >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase()
}
function HC(e) {
    return Tv(`${e.tag}:${e.textContent || e.innerHTML || ""}:${Object.entries(e.props).map(([t,n])=>`${t}:${String(n)}`).join(",")}`)
}
function BC(e) {
    let t = 9;
    for (const n of e)
        for (let r = 0; r < n.length; )
            t = Math.imul(t ^ n.charCodeAt(r++), 9 ** 9);
    return ((t ^ t >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase()
}
function VC(e, t) {
    const {props: n, tag: r} = e;
    if (Cv.includes(r))
        return r;
    if (r === "link" && n.rel === "canonical")
        return "canonical";
    if (n.charset)
        return "charset";
    const i = ["id"];
    r === "meta" && i.push("name", "property", "http-equiv");
    for (const s of i)
        if (typeof n[s] < "u") {
            const o = String(n[s]);
            return t && !t(o) ? !1 : `${r}:${s}:${o}`
        }
    return !1
}
function zC(e, t) {
    return e == null ? t || null : typeof e == "function" ? e(t) : e
}
const UC = Object.freeze(Object.defineProperty({
    __proto__: null,
    EntryConfigKeys: FC,
    HasElementTags: DC,
    SelfClosingTags: IC,
    TagConfigKeys: $C,
    TagsWithInnerContent: MC,
    UniqueTags: Cv,
    ValidHeadTags: NC,
    asArray: AC,
    computeHashes: BC,
    defineHeadPlugin: jC,
    hashCode: Tv,
    hashTag: HC,
    resolveTitleTemplate: zC,
    tagDedupeKey: VC
}, Symbol.toStringTag, {
    value: "Module"
}))
    , ef = Zu(UC);
(function(e) {
        const t = ef;
        function n(l, c=!1, u) {
            const {tag: f, $el: d} = l;
            d && (Object.entries(f.props).forEach(([h,y])=>{
                    y = String(y);
                    const p = `attr:${h}`;
                    if (h === "class") {
                        if (!y)
                            return;
                        for (const w of y.split(" ")) {
                            const m = `${p}:${w}`;
                            u && u(l, m, ()=>d.classList.remove(w)),
                            d.classList.contains(w) || d.classList.add(w)
                        }
                        return
                    }
                    u && !h.startsWith("data-h-") && u(l, p, ()=>d.removeAttribute(h)),
                    (c || d.getAttribute(h) !== y) && d.setAttribute(h, y)
                }
            ),
            t.TagsWithInnerContent.includes(f.tag) && (f.textContent && f.textContent !== d.textContent ? d.textContent = f.textContent : f.innerHTML && f.innerHTML !== d.innerHTML && (d.innerHTML = f.innerHTML)))
        }
        let r = !1;
        async function i(l, c={}) {
            var v, S;
            const u = {
                shouldRender: !0
            };
            if (await l.hooks.callHook("dom:beforeRender", u),
                !u.shouldRender)
                return;
            const f = c.document || l.resolvedOptions.document || window.document
                , d = (await l.resolveTags()).map(p);
            if (l.resolvedOptions.experimentalHashHydration && (r = r || l._hash || !1,
                r)) {
                const _ = t.computeHashes(d.map(E=>E.tag._h));
                if (r === _)
                    return;
                r = _
            }
            const h = l._popSideEffectQueue();
            l.headEntries().map(_=>_._sde).forEach(_=>{
                    Object.entries(_).forEach(([E,T])=>{
                            h[E] = T
                        }
                    )
                }
            );
            const y = (_,E,T)=>{
                    E = `${_.renderId}:${E}`,
                    _.entry && (_.entry._sde[E] = T),
                        delete h[E]
                }
            ;
            function p(_) {
                const E = l.headEntries().find(P=>P._i === _._e)
                    , T = {
                    renderId: _._d || t.hashTag(_),
                    $el: null,
                    shouldRender: !0,
                    tag: _,
                    entry: E,
                    markSideEffect: (P,I)=>y(T, P, I)
                };
                return T
            }
            const w = []
                , m = {
                    body: [],
                    head: []
                }
                , g = _=>{
                    l._elMap[_.renderId] = _.$el,
                        w.push(_),
                        y(_, "el", ()=>{
                                var E;
                                (E = _.$el) == null || E.remove(),
                                    delete l._elMap[_.renderId]
                            }
                        )
                }
            ;
            for (const _ of d) {
                if (await l.hooks.callHook("dom:beforeRenderTag", _),
                    !_.shouldRender)
                    continue;
                const {tag: E} = _;
                if (E.tag === "title") {
                    f.title = E.textContent || "",
                        w.push(_);
                    continue
                }
                if (E.tag === "htmlAttrs" || E.tag === "bodyAttrs") {
                    _.$el = f[E.tag === "htmlAttrs" ? "documentElement" : "body"],
                        n(_, !1, y),
                        w.push(_);
                    continue
                }
                if (_.$el = l._elMap[_.renderId],
                !_.$el && E.key && (_.$el = f.querySelector(`${(v = E.tagPosition) != null && v.startsWith("body") ? "body" : "head"} > ${E.tag}[data-h-${E._h}]`)),
                    _.$el) {
                    _.tag._d && n(_),
                        g(_);
                    continue
                }
                m[(S = E.tagPosition) != null && S.startsWith("body") ? "body" : "head"].push(_)
            }
            const b = {
                bodyClose: void 0,
                bodyOpen: void 0,
                head: void 0
            };
            Object.entries(m).forEach(([_,E])=>{
                    var P;
                    if (!E.length)
                        return;
                    const T = (P = f == null ? void 0 : f[_]) == null ? void 0 : P.children;
                    if (T) {
                        for (const I of [...T].reverse()) {
                            const L = I.tagName.toLowerCase();
                            if (!t.HasElementTags.includes(L))
                                continue;
                            const x = I.getAttributeNames().reduce((N,D)=>({
                                ...N,
                                [D]: I.getAttribute(D)
                            }), {})
                                , A = {
                                tag: L,
                                props: x
                            };
                            I.innerHTML && (A.innerHTML = I.innerHTML);
                            const k = t.hashTag(A);
                            let O = E.findIndex(N=>(N == null ? void 0 : N.renderId) === k);
                            if (O === -1) {
                                const N = t.tagDedupeKey(A);
                                O = E.findIndex(D=>(D == null ? void 0 : D.tag._d) && D.tag._d === N)
                            }
                            if (O !== -1) {
                                const N = E[O];
                                N.$el = I,
                                    n(N),
                                    g(N),
                                    delete E[O]
                            }
                        }
                        E.forEach(I=>{
                                const L = I.tag.tagPosition || "head";
                                b[L] = b[L] || f.createDocumentFragment(),
                                I.$el || (I.$el = f.createElement(I.tag.tag),
                                    n(I, !0)),
                                    b[L].appendChild(I.$el),
                                    g(I)
                            }
                        )
                    }
                }
            ),
            b.head && f.head.appendChild(b.head),
            b.bodyOpen && f.body.insertBefore(b.bodyOpen, f.body.firstChild),
            b.bodyClose && f.body.appendChild(b.bodyClose);
            for (const _ of w)
                await l.hooks.callHook("dom:renderTag", _);
            Object.values(h).forEach(_=>_())
        }
        e.domUpdatePromise = null;
        async function s(l, c={}) {
            function u() {
                return e.domUpdatePromise = null,
                    i(l, c)
            }
            const f = c.delayFn || (d=>setTimeout(d, 10));
            return e.domUpdatePromise = e.domUpdatePromise || new Promise(d=>f(()=>d(u())))
        }
        function o(l) {
            return t.defineHeadPlugin({
                hooks: {
                    "entries:updated": function(c) {
                        if (typeof (l == null ? void 0 : l.document) > "u" && typeof window > "u")
                            return;
                        let u = l == null ? void 0 : l.delayFn;
                        !u && typeof requestAnimationFrame < "u" && (u = requestAnimationFrame),
                            s(c, {
                                document: (l == null ? void 0 : l.document) || window.document,
                                delayFn: u
                            })
                    }
                }
            })
        }
        function a(l) {
            var c;
            return ((c = l == null ? void 0 : l.head.querySelector('meta[name="unhead:ssr"]')) == null ? void 0 : c.getAttribute("content")) || !1
        }
        e.PatchDomOnEntryUpdatesPlugin = o,
            e.debouncedRenderDOMHead = s,
            e.maybeGetSSRHash = a,
            e.renderDOMHead = i,
            e.setAttrs = n
    }
)(Ev);
(function(e) {
        const t = OC
            , n = Ev
            , r = ef
            , i = {
            base: -1,
            title: 1
        }
            , s = {
            critical: -8,
            high: -1,
            low: 2
        };
        function o(j) {
            let B = 10;
            const K = j.tagPriority;
            return typeof K == "number" ? K : (j.tag === "meta" ? (j.props.charset && (B = -2),
            j.props["http-equiv"] === "content-security-policy" && (B = 0)) : j.tag == "link" && j.props.rel === "preconnect" ? B = 2 : j.tag in i && (B = i[j.tag]),
                typeof K == "string" && K in s ? B + s[K] : B)
        }
        const a = [{
            prefix: "before:",
            offset: -1
        }, {
            prefix: "after:",
            offset: 1
        }];
        function l() {
            return r.defineHeadPlugin({
                hooks: {
                    "tags:resolve": j=>{
                        const B = K=>{
                                var H;
                                return (H = j.tags.find(q=>q._d === K)) == null ? void 0 : H._p
                            }
                        ;
                        for (const {prefix: K, offset: H} of a)
                            for (const q of j.tags.filter(he=>typeof he.tagPriority == "string" && he.tagPriority.startsWith(K))) {
                                const he = B(q.tagPriority.replace(K, ""));
                                typeof he < "u" && (q._p = he + H)
                            }
                        j.tags.sort((K,H)=>K._p - H._p).sort((K,H)=>o(K) - o(H))
                    }
                }
            })
        }
        function c() {
            return r.defineHeadPlugin({
                hooks: {
                    "tags:resolve": j=>{
                        const {tags: B} = j;
                        let K = B.findIndex(q=>q.tag === "titleTemplate");
                        const H = B.findIndex(q=>q.tag === "title");
                        if (H !== -1 && K !== -1) {
                            const q = r.resolveTitleTemplate(B[K].textContent, B[H].textContent);
                            q !== null ? B[H].textContent = q || B[H].textContent : delete B[H]
                        } else if (K !== -1) {
                            const q = r.resolveTitleTemplate(B[K].textContent);
                            q !== null && (B[K].textContent = q,
                                B[K].tag = "title",
                                K = -1)
                        }
                        K !== -1 && delete B[K],
                            j.tags = B.filter(Boolean)
                    }
                }
            })
        }
        function u() {
            return r.defineHeadPlugin({
                hooks: {
                    "tag:normalise": function({tag: j}) {
                        typeof j.props.body < "u" && (j.tagPosition = "bodyClose",
                            delete j.props.body)
                    }
                }
            })
        }
        const f = ["link", "style", "script", "noscript"];
        function d() {
            return r.defineHeadPlugin({
                hooks: {
                    "tag:normalise": ({tag: j, resolvedOptions: B})=>{
                        B.experimentalHashHydration === !0 && (j._h = r.hashTag(j)),
                        j.key && f.includes(j.tag) && (j._h = r.hashCode(j.key),
                            j.props[`data-h-${j._h}`] = "")
                    }
                }
            })
        }
        const h = ["script", "link", "bodyAttrs"];
        function y() {
            const j = (B,K)=>{
                    const H = {}
                        , q = {};
                    Object.entries(K.props).forEach(([ue,Ee])=>{
                            ue.startsWith("on") && typeof Ee == "function" ? q[ue] = Ee : H[ue] = Ee
                        }
                    );
                    let he;
                    return B === "dom" && K.tag === "script" && typeof H.src == "string" && typeof q.onload < "u" && (he = H.src,
                        delete H.src),
                        {
                            props: H,
                            eventHandlers: q,
                            delayedSrc: he
                        }
                }
            ;
            return r.defineHeadPlugin({
                hooks: {
                    "ssr:render": function(B) {
                        B.tags = B.tags.map(K=>(!h.includes(K.tag) || !Object.entries(K.props).find(([H,q])=>H.startsWith("on") && typeof q == "function") || (K.props = j("ssr", K).props),
                            K))
                    },
                    "dom:beforeRenderTag": function(B) {
                        if (!h.includes(B.tag.tag) || !Object.entries(B.tag.props).find(([he,ue])=>he.startsWith("on") && typeof ue == "function"))
                            return;
                        const {props: K, eventHandlers: H, delayedSrc: q} = j("dom", B.tag);
                        Object.keys(H).length && (B.tag.props = K,
                            B.tag._eventHandlers = H,
                            B.tag._delayedSrc = q)
                    },
                    "dom:renderTag": function(B) {
                        const K = B.$el;
                        if (!B.tag._eventHandlers || !K)
                            return;
                        const H = B.tag.tag === "bodyAttrs" && typeof window < "u" ? window : K;
                        Object.entries(B.tag._eventHandlers).forEach(([q,he])=>{
                                const ue = `${B.tag._d || B.tag._p}:${q}`
                                    , Ee = q.slice(2).toLowerCase()
                                    , Oe = `data-h-${Ee}`;
                                if (B.markSideEffect(ue, ()=>{}
                                ),
                                    K.hasAttribute(Oe))
                                    return;
                                const xe = he;
                                K.setAttribute(Oe, ""),
                                    H.addEventListener(Ee, xe),
                                B.entry && (B.entry._sde[ue] = ()=>{
                                        H.removeEventListener(Ee, xe),
                                            K.removeAttribute(Oe)
                                    }
                                )
                            }
                        ),
                        B.tag._delayedSrc && K.setAttribute("src", B.tag._delayedSrc)
                    }
                }
            })
        }
        const p = ["templateParams", "htmlAttrs", "bodyAttrs"];
        function w() {
            return r.defineHeadPlugin({
                hooks: {
                    "tag:normalise": function({tag: j}) {
                        ["hid", "vmid", "key"].forEach(H=>{
                                j.props[H] && (j.key = j.props[H],
                                    delete j.props[H])
                            }
                        );
                        const K = r.tagDedupeKey(j) || (j.key ? `${j.tag}:${j.key}` : !1);
                        K && (j._d = K)
                    },
                    "tags:resolve": function(j) {
                        const B = {};
                        j.tags.forEach(H=>{
                                const q = (H.key ? `${H.tag}:${H.key}` : H._d) || H._p
                                    , he = B[q];
                                if (he) {
                                    let Ee = H == null ? void 0 : H.tagDuplicateStrategy;
                                    if (!Ee && p.includes(H.tag) && (Ee = "merge"),
                                    Ee === "merge") {
                                        const Oe = he.props;
                                        ["class", "style"].forEach(xe=>{
                                                H.props[xe] && Oe[xe] && (xe === "style" && !Oe[xe].endsWith(";") && (Oe[xe] += ";"),
                                                    H.props[xe] = `${Oe[xe]} ${H.props[xe]}`)
                                            }
                                        ),
                                            B[q].props = {
                                                ...Oe,
                                                ...H.props
                                            };
                                        return
                                    } else if (H._e === he._e) {
                                        he._duped = he._duped || [],
                                            H._d = `${he._d}:${he._duped.length + 1}`,
                                            he._duped.push(H);
                                        return
                                    } else if (o(H) > o(he))
                                        return
                                }
                                const ue = Object.keys(H.props).length + (H.innerHTML ? 1 : 0) + (H.textContent ? 1 : 0);
                                if (r.HasElementTags.includes(H.tag) && ue === 0) {
                                    delete B[q];
                                    return
                                }
                                B[q] = H
                            }
                        );
                        const K = [];
                        Object.values(B).forEach(H=>{
                                const q = H._duped;
                                delete H._duped,
                                    K.push(H),
                                q && K.push(...q)
                            }
                        ),
                            j.tags = K
                    }
                }
            })
        }
        function m(j, B) {
            if (typeof j != "string")
                return j;
            function K(ue) {
                if (["s", "pageTitle"].includes(ue))
                    return B.pageTitle;
                let Ee;
                return ue.includes(".") ? Ee = ue.split(".").reduce((Oe,xe)=>Oe && Oe[xe] || void 0, B) : Ee = B[ue],
                    typeof Ee < "u" ? Ee || "" : !1
            }
            let H = j;
            try {
                H = decodeURI(j)
            } catch {}
            (H.match(/%(\w+\.+\w+)|%(\w+)/g) || []).sort().reverse().forEach(ue=>{
                    const Ee = K(ue.slice(1));
                    typeof Ee == "string" && (j = j.replace(new RegExp(`\\${ue}(\\W|$)`,"g"), (Oe,xe)=>`${Ee}${xe}`).trim())
                }
            );
            const he = B.separator;
            return j.includes(he) && (j.endsWith(he) && (j = j.slice(0, -he.length).trim()),
            j.startsWith(he) && (j = j.slice(he.length).trim()),
                j = j.replace(new RegExp(`\\${he}\\s*\\${he}`,"g"), he)),
                j
        }
        function g() {
            return r.defineHeadPlugin({
                hooks: {
                    "tags:resolve": j=>{
                        var he;
                        const {tags: B} = j
                            , K = (he = B.find(ue=>ue.tag === "title")) == null ? void 0 : he.textContent
                            , H = B.findIndex(ue=>ue.tag === "templateParams")
                            , q = H !== -1 ? B[H].props : {};
                        q.separator = q.separator || "|",
                            q.pageTitle = m(q.pageTitle || K || "", q);
                        for (const ue of B)
                            if (["titleTemplate", "title"].includes(ue.tag) && typeof ue.textContent == "string")
                                ue.textContent = m(ue.textContent, q);
                            else if (ue.tag === "meta" && typeof ue.props.content == "string")
                                ue.props.content = m(ue.props.content, q);
                            else if (ue.tag === "link" && typeof ue.props.href == "string")
                                ue.props.href = m(ue.props.href, q);
                            else if (ue.tag === "script" && ["application/json", "application/ld+json"].includes(ue.props.type) && typeof ue.innerHTML == "string")
                                try {
                                    ue.innerHTML = JSON.stringify(JSON.parse(ue.innerHTML), (Ee,Oe)=>typeof Oe == "string" ? m(Oe, q) : Oe)
                                } catch {}
                        j.tags = B.filter(ue=>ue.tag !== "templateParams")
                    }
                }
            })
        }
        const b = /@import/;
        function v() {
            return r.defineHeadPlugin({
                hooks: {
                    "tags:beforeResolve": function({tags: j}) {
                        var B;
                        for (const K of j) {
                            if (K.tagPriority)
                                continue;
                            const H = ue=>ue === ""
                                , q = K.tag === "script"
                                , he = K.tag === "link";
                            q && H(K.props.async) ? K.tagPriority = 3 : K.tag === "style" && K.innerHTML && b.test(K.innerHTML) ? K.tagPriority = 4 : q && K.props.src && !H(K.props.defer) && !H(K.props.async) && K.props.type !== "module" && !((B = K.props.type) != null && B.endsWith("json")) ? K.tagPriority = 5 : he && K.props.rel === "stylesheet" || K.tag === "style" ? K.tagPriority = 6 : he && ["preload", "modulepreload"].includes(K.props.rel) ? K.tagPriority = 7 : q && H(K.props.defer) && K.props.src && !H(K.props.async) ? K.tagPriority = 8 : he && ["prefetch", "dns-prefetch", "prerender"].includes(K.props.rel) && (K.tagPriority = 9)
                        }
                    }
                }
            })
        }
        const S = typeof window < "u";
        e.activeHead = void 0;
        function _(j) {
            return e.activeHead = j
        }
        function E() {
            return e.activeHead
        }
        function T(j, B={}) {
            var H;
            const K = E();
            if (K) {
                const q = S || ((H = K.resolvedOptions) == null ? void 0 : H.document);
                return B.mode === "server" && q || B.mode === "client" && !q ? void 0 : K.push(j, B)
            }
        }
        function P(j, B={}) {
            return T(j, {
                ...B || {},
                transform: qi
            })
        }
        function I(j, B={}) {
            return T(j, {
                ...B,
                mode: "server"
            })
        }
        function L(j, B={}) {
            return P(j, {
                ...B,
                mode: "server"
            })
        }
        function x(j, B) {
            const {title: K, titleTemplate: H, ...q} = j;
            return T({
                title: K,
                titleTemplate: H,
                meta: se(q)
            }, B)
        }
        function A(j, B) {
            return x(j, {
                ...B || {},
                mode: "server"
            })
        }
        function k(j) {
            return T({
                title: j
            })
        }
        function O(j) {
            return T({
                base: j
            })
        }
        function N(j) {
            return T({
                meta: r.asArray(j)
            })
        }
        function D(j) {
            return N(se(j))
        }
        function W(j) {
            return T({
                link: r.asArray(j)
            })
        }
        function G(j) {
            return T({
                script: r.asArray(j)
            })
        }
        function le(j) {
            return T({
                style: r.asArray(j)
            })
        }
        function ge(j) {
            return T({
                noscript: r.asArray(j)
            })
        }
        function ye(j) {
            return T({
                htmlAttrs: j
            })
        }
        function de(j) {
            return T({
                bodyAttrs: j
            })
        }
        function z(j) {
            return T({
                titleTemplate: j
            })
        }
        function Pe(j) {
            return I({
                title: j
            })
        }
        function _e(j) {
            return I({
                base: j
            })
        }
        function J(j) {
            return I({
                meta: r.asArray(j)
            })
        }
        function ne(j) {
            return J(se(j))
        }
        function ee(j) {
            return I({
                link: r.asArray(j)
            })
        }
        function ce(j) {
            return I({
                script: r.asArray(j)
            })
        }
        function Ce(j) {
            return I({
                style: r.asArray(j)
            })
        }
        function M(j) {
            return I({
                noscript: r.asArray(j)
            })
        }
        function C(j) {
            return I({
                htmlAttrs: j
            })
        }
        function R(j) {
            return I({
                bodyAttrs: j
            })
        }
        function F(j) {
            return I({
                titleTemplate: j
            })
        }
        function V(j) {
            return Array.isArray(j) ? j : [j]
        }
        const Y = "_$key";
        function re(j, B) {
            const K = Object.keys(j);
            let[H,q] = K;
            B = B || {},
                B.key = B.key || H,
                B.value = B.value || q,
                B.resolveKey = B.resolveKey || (xe=>xe);
            const he = xe=>V(B == null ? void 0 : B[xe]).find(Ct=>typeof Ct == "string" && Ct.includes(".") ? Ct : Ct && K.includes(Ct))
                , ue = (xe,Rn)=>{
                    if (xe.includes(".")) {
                        const Ct = xe.split(".");
                        let xr = Rn;
                        for (const J0 of Ct)
                            xr = xr[J0];
                        return xr
                    }
                    return Rn[xe]
                }
            ;
            H = he("key") || H,
                q = he("value") || q;
            const Ee = j.key ? `${Y}${j.key}-` : "";
            let Oe = ue(H, j);
            return Oe = B.resolveKey(Oe),
                {
                    [`${Ee}${Oe}`]: ue(q, j)
                }
        }
        function ie(j, B) {
            const K = {};
            for (const H of j) {
                const q = re(H, B)
                    , he = Object.keys(q)[0]
                    , ue = he.startsWith(Y);
                !ue && K[he] ? (K[he] = Array.isArray(K[he]) ? K[he] : [K[he]],
                    K[he].push(Object.values(q)[0])) : K[ue && he.split("-").slice(1).join("-") || he] = q[he]
            }
            return K
        }
        function ae(j, B) {
            const K = []
                , H = B.resolveKeyData || (he=>he.key)
                , q = B.resolveValueData || (he=>he.value);
            for (const [he,ue] of Object.entries(j))
                K.push(...(Array.isArray(ue) ? ue : [ue]).map(Ee=>{
                        const Oe = {
                            key: he,
                            value: Ee
                        }
                            , xe = q(Oe);
                        return typeof xe == "object" ? ae(xe, B) : Array.isArray(xe) ? xe : {
                            [typeof B.key == "function" ? B.key(Oe) : B.key]: H(Oe),
                            [typeof B.value == "function" ? B.value(Oe) : B.value]: xe
                        }
                    }
                ).flat());
            return K
        }
        function Q(j, B) {
            return Object.entries(j).map(([K,H])=>{
                    if (typeof H == "object" && (H = Q(H, B)),
                        B.resolve) {
                        const q = B.resolve({
                            key: K,
                            value: H
                        });
                        if (q)
                            return q
                    }
                    return typeof H == "number" && (H = H.toString()),
                    typeof H == "string" && B.wrapValue && (H = H.replace(new RegExp(B.wrapValue,"g"), `\\${B.wrapValue}`),
                        H = `${B.wrapValue}${H}${B.wrapValue}`),
                        `${K}${B.keyValueSeparator || ""}${H}`
                }
            ).join(B.entrySeparator || "")
        }
        const U = {
            robots: {
                unpack: {
                    keyValueSeparator: ":"
                }
            },
            contentSecurityPolicy: {
                unpack: {
                    keyValueSeparator: " ",
                    entrySeparator: "; "
                },
                metaKey: "http-equiv"
            },
            fbAppId: {
                keyValue: "fb:app_id",
                metaKey: "property"
            },
            ogSiteName: {
                keyValue: "og:site_name"
            },
            msapplicationTileImage: {
                keyValue: "msapplication-TileImage"
            },
            msapplicationTileColor: {
                keyValue: "msapplication-TileColor"
            },
            msapplicationConfig: {
                keyValue: "msapplication-Config"
            },
            charset: {
                metaKey: "charset"
            },
            contentType: {
                metaKey: "http-equiv"
            },
            defaultStyle: {
                metaKey: "http-equiv"
            },
            xUaCompatible: {
                metaKey: "http-equiv"
            },
            refresh: {
                metaKey: "http-equiv"
            }
        };
        function $(j) {
            const B = Object.entries(U).map(([K,H])=>[K, H.keyValue]);
            return ie(j, {
                key: ["name", "property", "httpEquiv", "http-equiv", "charset"],
                value: ["content", "charset"],
                resolveKey(K) {
                    var he, ue;
                    let H = ((ue = (he = B.filter(Ee=>Ee[1] === K)) == null ? void 0 : he[0]) == null ? void 0 : ue[0]) || K;
                    const q = (Ee,Oe)=>Oe == null ? void 0 : Oe.toUpperCase();
                    return H = H.replace(/:([a-z])/g, q).replace(/-([a-z])/g, q),
                        H
                }
            })
        }
        const Z = ["og:Image", "og:Video", "og:Audio", "twitter:Image"]
            , te = ["themeColor"]
            , pe = /^(og|twitter|fb)/
            , oe = /^(og|fb)/;
        function me(j) {
            var B;
            return oe.test(j) ? "property" : ((B = U[j]) == null ? void 0 : B.metaKey) || "name"
        }
        function Me(j) {
            var B;
            return ((B = U[j]) == null ? void 0 : B.keyValue) || Ne(j)
        }
        function Ne(j) {
            return j = j.replace(/([A-Z])/g, "-$1").toLowerCase(),
            pe.test(j) && (j = j.replace("secure-url", "secure_url").replace(/-/g, ":")),
                j
        }
        function et(j) {
            if (Array.isArray(j))
                return j.map(K=>et(K));
            if (typeof j != "object" || Array.isArray(j))
                return j;
            const B = {};
            for (const [K,H] of Object.entries(j))
                B[Ne(K)] = et(H);
            return B
        }
        function se(j) {
            const B = [];
            Z.forEach(H=>{
                    const q = H.toLowerCase()
                        , he = `${H.replace(":", "")}`
                        , ue = j[he];
                    typeof ue == "object" && ((Array.isArray(ue) ? ue : [ue]).forEach(Ee=>{
                            if (!Ee)
                                return;
                            const Oe = ae(Ee, {
                                key: H.startsWith("og") ? "property" : "name",
                                value: "content",
                                resolveKeyData({key: xe}) {
                                    return Ne(`${q}${xe !== "url" ? `:${xe}` : ""}`)
                                },
                                resolveValueData({value: xe}) {
                                    return typeof xe == "number" ? xe.toString() : xe
                                }
                            });
                            B.push(...Oe.sort((xe,Rn)=>xe.property === q ? -1 : Rn.property === q ? 1 : 0))
                        }
                    ),
                        delete j[he])
                }
            ),
                te.forEach(H=>{
                        if (j[H] && typeof j[H] != "string") {
                            const q = Array.isArray(j[H]) ? j[H] : [j[H]];
                            delete j[H],
                                q.forEach(he=>{
                                        B.push({
                                            name: Ne(H),
                                            ...he
                                        })
                                    }
                                )
                        }
                    }
                );
            const K = ae(j, {
                key({key: H}) {
                    return me(H)
                },
                value({key: H}) {
                    return H === "charset" ? "charset" : "content"
                },
                resolveKeyData({key: H}) {
                    return Me(H)
                },
                resolveValueData({value: H, key: q}) {
                    return H === null ? "_null" : typeof H == "object" ? Ie(H, q) : typeof H == "number" ? H.toString() : H
                }
            });
            return [...B, ...K].filter(H=>typeof H.content > "u" || H.content !== "_null")
        }
        function Ie(j, B) {
            const K = U[B];
            return B === "refresh" ? `${j.seconds};url=${j.url}` : Q(et(j), {
                entrySeparator: ", ",
                keyValueSeparator: "=",
                resolve({value: H, key: q}) {
                    if (H === null)
                        return "";
                    if (typeof H == "boolean")
                        return `${q}`
                },
                ...K == null ? void 0 : K.unpack
            })
        }
        async function De(j, B, K) {
            const H = {
                tag: j,
                props: {}
            };
            return B instanceof Promise && (B = await B),
                j === "templateParams" ? (H.props = B,
                    H) : ["title", "titleTemplate"].includes(j) ? (B && typeof B == "object" ? (H.textContent = B.textContent,
                B.tagPriority && (H.tagPriority = B.tagPriority)) : H.textContent = B,
                    H) : typeof B == "string" ? ["script", "noscript", "style"].includes(j) ? (j === "script" && (/^(https?:)?\/\//.test(B) || B.startsWith("/")) ? H.props.src = B : H.innerHTML = B,
                    H) : !1 : (H.props = await $e(j, {
                    ...B
                }),
                H.props.children && (H.props.innerHTML = H.props.children),
                    delete H.props.children,
                    Object.keys(H.props).filter(q=>r.TagConfigKeys.includes(q)).forEach(q=>{
                            (!["innerHTML", "textContent"].includes(q) || r.TagsWithInnerContent.includes(H.tag)) && (H[q] = H.props[q]),
                                delete H.props[q]
                        }
                    ),
                    r.TagConfigKeys.forEach(q=>{
                            !H[q] && K[q] && (H[q] = K[q])
                        }
                    ),
                    ["innerHTML", "textContent"].forEach(q=>{
                            if (H.tag === "script" && typeof H[q] == "string" && ["application/ld+json", "application/json"].includes(H.props.type))
                                try {
                                    H[q] = JSON.parse(H[q])
                                } catch {
                                    H[q] = ""
                                }
                            typeof H[q] == "object" && (H[q] = JSON.stringify(H[q]))
                        }
                    ),
                H.props.class && (H.props.class = ze(H.props.class)),
                    H.props.content && Array.isArray(H.props.content) ? H.props.content.map(q=>({
                        ...H,
                        props: {
                            ...H.props,
                            content: q
                        }
                    })) : H)
        }
        function ze(j) {
            return typeof j == "object" && !Array.isArray(j) && (j = Object.keys(j).filter(B=>j[B])),
                (Array.isArray(j) ? j.join(" ") : j).split(" ").filter(B=>B.trim()).filter(Boolean).join(" ")
        }
        async function $e(j, B) {
            for (const K of Object.keys(B)) {
                const H = K.startsWith("data-");
                B[K]instanceof Promise && (B[K] = await B[K]),
                    String(B[K]) === "true" ? B[K] = H ? "true" : "" : String(B[K]) === "false" && (H ? B[K] = "false" : delete B[K])
            }
            return B
        }
        const Ue = 10;
        async function kn(j) {
            const B = [];
            return Object.entries(j.resolvedInput).filter(([K,H])=>typeof H < "u" && r.ValidHeadTags.includes(K)).forEach(([K,H])=>{
                    const q = r.asArray(H);
                    B.push(...q.map(he=>De(K, he, j)).flat())
                }
            ),
                (await Promise.all(B)).flat().filter(Boolean).map((K,H)=>(K._e = j._i,
                    K._p = (j._i << Ue) + H,
                    K))
        }
        const pn = {
            htmlAttrs: ["id", "class", "lang", "dir"],
            bodyAttrs: ["id", "class"],
            meta: ["id", "name", "property", "charset", "content"],
            noscript: ["id", "textContent"],
            script: ["id", "type", "textContent"],
            link: ["id", "color", "crossorigin", "fetchpriority", "href", "hreflang", "imagesrcset", "imagesizes", "integrity", "media", "referrerpolicy", "rel", "sizes", "type"]
        };
        function qi(j) {
            const B = {};
            return Object.keys(j).forEach(K=>{
                    const H = j[K];
                    if (H)
                        switch (K) {
                            case "title":
                            case "titleTemplate":
                            case "templateParams":
                                B[K] = H;
                                break;
                            case "htmlAttrs":
                            case "bodyAttrs":
                                B[K] = {},
                                    pn[K].forEach(q=>{
                                            H[q] && (B[K][q] = H[q])
                                        }
                                    ),
                                    Object.keys(H || {}).filter(q=>q.startsWith("data-")).forEach(q=>{
                                            B[K][q] = H[q]
                                        }
                                    );
                                break;
                            case "meta":
                                Array.isArray(H) && (B[K] = H.map(q=>{
                                        const he = {};
                                        return pn.meta.forEach(ue=>{
                                                (q[ue] || ue.startsWith("data-")) && (he[ue] = q[ue])
                                            }
                                        ),
                                            he
                                    }
                                ).filter(q=>Object.keys(q).length > 0));
                                break;
                            case "link":
                                Array.isArray(H) && (B[K] = H.map(q=>{
                                        const he = {};
                                        return pn.link.forEach(ue=>{
                                                const Ee = q[ue];
                                                if (!(ue === "rel" && ["stylesheet", "canonical", "modulepreload", "prerender", "preload", "prefetch"].includes(Ee)))
                                                    if (ue === "href") {
                                                        if (Ee.includes("javascript:") || Ee.includes("data:"))
                                                            return;
                                                        he[ue] = Ee
                                                    } else
                                                        (Ee || ue.startsWith("data-")) && (he[ue] = Ee)
                                            }
                                        ),
                                            he
                                    }
                                ).filter(q=>Object.keys(q).length > 1 && !!q.rel));
                                break;
                            case "noscript":
                                Array.isArray(H) && (B[K] = H.map(q=>{
                                        const he = {};
                                        return pn.noscript.forEach(ue=>{
                                                (q[ue] || ue.startsWith("data-")) && (he[ue] = q[ue])
                                            }
                                        ),
                                            he
                                    }
                                ).filter(q=>Object.keys(q).length > 0));
                                break;
                            case "script":
                                Array.isArray(H) && (B[K] = H.map(q=>{
                                        const he = {};
                                        return pn.script.forEach(ue=>{
                                                if (q[ue] || ue.startsWith("data-"))
                                                    if (ue === "textContent")
                                                        try {
                                                            const Ee = typeof q[ue] == "string" ? JSON.parse(q[ue]) : q[ue];
                                                            he[ue] = JSON.stringify(Ee, null, 0)
                                                        } catch {}
                                                    else
                                                        he[ue] = q[ue]
                                            }
                                        ),
                                            he
                                    }
                                ).filter(q=>Object.keys(q).length > 0));
                                break
                        }
                }
            ),
                B
        }
        function Wf() {
            return [w(), l(), g(), c(), d(), y(), u()]
        }
        function Gf(j={}) {
            return [n.PatchDomOnEntryUpdatesPlugin({
                document: j == null ? void 0 : j.document,
                delayFn: j == null ? void 0 : j.domDelayFn
            })]
        }
        function X0(j={}) {
            const B = ml({
                ...j,
                plugins: [...Gf(j), ...(j == null ? void 0 : j.plugins) || []]
            });
            return j.experimentalHashHydration && B.resolvedOptions.document && (B._hash = n.maybeGetSSRHash(B.resolvedOptions.document)),
                _(B),
                B
        }
        function K0(j={}) {
            const B = ml({
                ...j,
                mode: "server"
            });
            return _(B),
                B
        }
        function ml(j={}) {
            let B = []
                , K = {}
                , H = 0;
            const q = t.createHooks();
            j != null && j.hooks && q.addHooks(j.hooks),
                j.plugins = [...Wf(), ...(j == null ? void 0 : j.plugins) || []],
                j.plugins.forEach(Ee=>Ee.hooks && q.addHooks(Ee.hooks)),
                j.document = j.document || (S ? document : void 0);
            const he = ()=>q.callHook("entries:updated", ue)
                , ue = {
                resolvedOptions: j,
                headEntries() {
                    return B
                },
                get hooks() {
                    return q
                },
                use(Ee) {
                    Ee.hooks && q.addHooks(Ee.hooks)
                },
                push(Ee, Oe) {
                    const xe = {
                        _i: H++,
                        input: Ee,
                        _sde: {},
                        ...Oe
                    }
                        , Rn = (xe == null ? void 0 : xe.mode) || j.mode;
                    return Rn && (xe.mode = Rn),
                        B.push(xe),
                        he(),
                        {
                            dispose() {
                                B = B.filter(Ct=>Ct._i !== xe._i ? !0 : (K = {
                                    ...K,
                                    ...Ct._sde || {}
                                },
                                    Ct._sde = {},
                                    he(),
                                    !1))
                            },
                            patch(Ct) {
                                B = B.map(xr=>(xr._i === xe._i && (xe.input = xr.input = Ct,
                                    he()),
                                    xr))
                            }
                        }
                },
                async resolveTags() {
                    const Ee = {
                        tags: [],
                        entries: [...B]
                    };
                    await q.callHook("entries:resolve", Ee);
                    for (const Oe of Ee.entries) {
                        const xe = Oe.resolvedInput || Oe.input;
                        if (Oe.resolvedInput = await (Oe.transform ? Oe.transform(xe) : xe),
                            Oe.resolvedInput)
                            for (const Rn of await kn(Oe)) {
                                const Ct = {
                                    tag: Rn,
                                    entry: Oe,
                                    resolvedOptions: ue.resolvedOptions
                                };
                                await q.callHook("tag:normalise", Ct),
                                    Ee.tags.push(Ct.tag)
                            }
                    }
                    return await q.callHook("tags:beforeResolve", Ee),
                        await q.callHook("tags:resolve", Ee),
                        Ee.tags
                },
                _popSideEffectQueue() {
                    const Ee = {
                        ...K
                    };
                    return K = {},
                        Ee
                },
                _elMap: {}
            };
            return ue.hooks.callHook("init", ue),
                ue
        }
        const Y0 = ["getActiveHead"]
            , Xf = ["useHead", "useSeoMeta", "useHeadSafe", "useServerHead", "useServerSeoMeta", "useServerHeadSafe", "useTagTitle", "useTagBase", "useTagMeta", "useTagMetaFlat", "useTagLink", "useTagScript", "useTagStyle", "useTagNoscript", "useHtmlAttrs", "useBodyAttrs", "useTitleTemplate", "useServerTagTitle", "useServerTagBase", "useServerTagMeta", "useServerTagMetaFlat", "useServerTagLink", "useServerTagScript", "useServerTagStyle", "useServerTagNoscript", "useServerHtmlAttrs", "useServerBodyAttrs", "useServerTitleTemplate"]
            , q0 = [{
            from: "unhead",
            imports: [...Y0, ...Xf]
        }];
        e.CapoPlugin = v,
            e.CorePlugins = Wf,
            e.DOMPlugins = Gf,
            e.DedupesTagsPlugin = w,
            e.DeprecatedTagAttrPlugin = u,
            e.EventHandlersPlugin = y,
            e.ProvideTagHashPlugin = d,
            e.SortModifiers = a,
            e.SortTagsPlugin = l,
            e.TAG_ALIASES = s,
            e.TAG_WEIGHTS = i,
            e.TagEntityBits = Ue,
            e.TemplateParamsPlugin = g,
            e.TitleTemplatePlugin = c,
            e.composableNames = Xf,
            e.createHead = X0,
            e.createHeadCore = ml,
            e.createServerHead = K0,
            e.getActiveHead = E,
            e.normaliseClassProp = ze,
            e.normaliseEntryTags = kn,
            e.normaliseProps = $e,
            e.normaliseTag = De,
            e.packMeta = $,
            e.processTemplateParams = m,
            e.resolveMetaKeyType = me,
            e.resolveMetaKeyValue = Me,
            e.resolvePackedMetaObjectValue = Ie,
            e.setActiveHead = _,
            e.tagWeight = o,
            e.unheadComposablesImports = q0,
            e.unpackMeta = se,
            e.useBodyAttrs = de,
            e.useHead = T,
            e.useHeadSafe = P,
            e.useHtmlAttrs = ye,
            e.useSeoMeta = x,
            e.useServerBodyAttrs = R,
            e.useServerHead = I,
            e.useServerHeadSafe = L,
            e.useServerHtmlAttrs = C,
            e.useServerSeoMeta = A,
            e.useServerTagBase = _e,
            e.useServerTagLink = ee,
            e.useServerTagMeta = J,
            e.useServerTagMetaFlat = ne,
            e.useServerTagNoscript = M,
            e.useServerTagScript = ce,
            e.useServerTagStyle = Ce,
            e.useServerTagTitle = Pe,
            e.useServerTitleTemplate = F,
            e.useTagBase = O,
            e.useTagLink = W,
            e.useTagMeta = N,
            e.useTagMetaFlat = D,
            e.useTagNoscript = ge,
            e.useTagScript = G,
            e.useTagStyle = le,
            e.useTagTitle = k,
            e.useTitleTemplate = z,
            e.whitelistSafeInput = qi
    }
)(Qu);
var Zn = {};
const xv = Zu(fE)
    , zt = xv
    , tf = Qu
    , WC = ef;
function GC(e) {
    return typeof e == "function" ? e() : zt.unref(e)
}
function Ns(e, t="") {
    if (e instanceof Promise)
        return e;
    const n = GC(e);
    return !e || !n ? n : Array.isArray(n) ? n.map(r=>Ns(r, t)) : typeof n == "object" ? Object.fromEntries(Object.entries(n).map(([r,i])=>r === "titleTemplate" || r.startsWith("on") ? [r, zt.unref(i)] : [r, Ns(i, r)])) : n
}
const XC = zt.version.startsWith("3")
    , KC = typeof window < "u"
    , nf = "usehead";
function Ka() {
    return zt.getCurrentInstance() && zt.inject(nf) || tf.getActiveHead()
}
function Pv(e) {
    return {
        install(n) {
            XC && (n.config.globalProperties.$unhead = e,
                n.config.globalProperties.$head = e,
                n.provide(nf, e))
        }
    }.install
}
function YC(e={}) {
    const t = tf.createServerHead({
        ...e,
        plugins: [rf(), ...(e == null ? void 0 : e.plugins) || []]
    });
    return t.install = Pv(t),
        t
}
function qC(e={}) {
    const t = tf.createHead({
        ...e,
        domDelayFn: n=>setTimeout(()=>zt.nextTick(()=>n()), 10),
        plugins: [rf(), ...(e == null ? void 0 : e.plugins) || []]
    });
    return t.install = Pv(t),
        t
}
function rf() {
    return WC.defineHeadPlugin({
        hooks: {
            "entries:resolve": function(e) {
                for (const t of e.entries)
                    t.resolvedInput = Ns(t.input)
            }
        }
    })
}
function JC(e, t={}) {
    const n = Ka()
        , r = zt.ref(!1)
        , i = zt.ref({});
    zt.watchEffect(()=>{
            i.value = r.value ? {} : Ns(e)
        }
    );
    const s = n.push(i.value, t);
    return zt.watch(i, a=>{
            s.patch(a)
        }
    ),
    zt.getCurrentInstance() && (zt.onBeforeUnmount(()=>{
            s.dispose()
        }
    ),
        zt.onDeactivated(()=>{
                r.value = !0
            }
        ),
        zt.onActivated(()=>{
                r.value = !1
            }
        )),
        s
}
function kv(e, t={}) {
    return Ka().push(e, t)
}
function ZC(e, t={}) {
    var r;
    const n = Ka();
    if (n) {
        const i = KC || !!((r = n.resolvedOptions) != null && r.document);
        return t.mode === "server" && i || t.mode === "client" && !i ? void 0 : i ? JC(e, t) : kv(e, t)
    }
}
Zn.VueReactiveUseHeadPlugin = rf;
Zn.createHead = qC;
Zn.createServerHead = YC;
Zn.headSymbol = nf;
Zn.injectHead = Ka;
Zn.resolveUnrefHeadInput = Ns;
Zn.serverUseHead = kv;
Zn.useHead = ZC;
const Ya = Qu
    , qn = Zn
    , Bd = xv;
function QC(e, t) {
    const n = Bd.ref({});
    return Bd.watchEffect(()=>{
            const r = qn.resolveUnrefHeadInput(e)
                , {title: i, titleTemplate: s, ...o} = r;
            n.value = {
                title: i,
                titleTemplate: s,
                meta: Ya.unpackMeta(o)
            }
        }
    ),
        qn.useHead(n, t)
}
const eT = ["injectHead"];
[...eT, ...Ya.composableNames];
Ya.CapoPlugin;
Ya.createHeadCore;
qn.VueReactiveUseHeadPlugin;
var tT = qn.createHead;
qn.createServerHead;
qn.headSymbol;
qn.injectHead;
qn.resolveUnrefHeadInput;
var nT = qn.useHead
    , oF = QC;
const rT = {
    meta: [{
        charset: "utf-8"
    }, {
        name: "viewport",
        content: "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    }, {
        name: "apple-mobile-web-app-status-bar-style",
        content: "black-translucent"
    }],
    link: [{
        rel: "apple-touch-startup-image",
        href: "/splash/iphone5_splash.png",
        media: "(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)"
    }, {
        rel: "apple-touch-startup-image",
        href: "/splash/iphone6_splash.png",
        media: "(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2)"
    }, {
        rel: "apple-touch-startup-image",
        href: "/splash/iphoneplus_splash.png",
        media: "(device-width: 621px) and (device-height: 1104px) and (-webkit-device-pixel-ratio: 3)"
    }, {
        rel: "apple-touch-startup-image",
        href: "/splash/iphonex_splash.png",
        media: "(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)"
    }, {
        rel: "apple-touch-startup-image",
        href: "/splash/iphonexr_splash.png",
        media: "(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2)"
    }, {
        rel: "apple-touch-startup-image",
        href: "/splash/iphonexsmax_splash.png",
        media: "(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3)"
    }, {
        rel: "apple-touch-startup-image",
        href: "/splash/ipad_splash.png",
        media: "(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2)"
    }, {
        rel: "apple-touch-startup-image",
        href: "/splash/ipadpro1_splash.png",
        media: "(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2)"
    }, {
        rel: "apple-touch-startup-image",
        href: "/splash/ipadpro3_splash.png",
        media: "(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2)"
    }, {
        rel: "apple-touch-startup-image",
        href: "/splash/ipadpro2_splash.png",
        media: "(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2)"
    }, {
        rel: "icon",
        href: "/favicon.ico",
        sizes: "any"
    }, {
        rel: "icon",
        type: "image/svg+xml",
        href: "/blue-logo.svg"
    }, {
        rel: "apple-touch-icon",
        href: "/512.png"
    }, {
        rel: "preconnect",
        href: "https://fonts.googleapis.com"
    }, {
        rel: "preconnect",
        href: "https://fonts.gstatic.com"
    }, {
        rel: "stylesheet",
        href: "https://fonts.googleapis.com/css2?family=Roboto&display=swap",
        crossorigin: "anonymous"
    }],
    style: [],
    script: [{
        async: !0,
        src: "https://js.stripe.com/v3/buy-button.js"
    }],
    noscript: [],
    title: "Rulet TV",
    titleTemplate: "%pageTitle",
    charset: "utf-8",
    viewport: "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no",
    htmlAttrs: {
        lang: "en"
    }
}
    , iT = !1
    , _c = !1
    , sT = !1
    , oT = "__nuxt"
    , aT = !0;
async function lT(e) {
    try {
        return aT ? Rv(await fetch(e).then(t=>t.text())) : await at(()=>import(e), [], import.meta.url).then(t=>t.default || t)
    } catch (t) {
        console.warn("[nuxt] Cannot load payload ", e, t)
    }
    return null
}
let So = null;
async function cT() {
    if (So)
        return So;
    const e = document.getElementById("__NUXT_DATA__");
    if (!e)
        return {};
    const t = Rv(e.textContent || "")
        , n = e.dataset.src ? await lT(e.dataset.src) : void 0;
    return So = {
        ...t,
        ...n,
        ...window.__NUXT__
    },
        So
}
function Rv(e) {
    return RC(e, pt()._payloadRevivers)
}
function uT(e, t) {
    pt()._payloadRevivers[e] = t
}
const _o = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
function fT(e, t) {
    if (typeof e != "string")
        throw new TypeError("argument str must be a string");
    const n = {}
        , i = (t || {}).decode || hT;
    let s = 0;
    for (; s < e.length; ) {
        const o = e.indexOf("=", s);
        if (o === -1)
            break;
        let a = e.indexOf(";", s);
        if (a === -1)
            a = e.length;
        else if (a < o) {
            s = e.lastIndexOf(";", o - 1) + 1;
            continue
        }
        const l = e.slice(s, o).trim();
        if (n[l] === void 0) {
            let c = e.slice(o + 1, a).trim();
            c.codePointAt(0) === 34 && (c = c.slice(1, -1)),
                n[l] = pT(c, i)
        }
        s = a + 1
    }
    return n
}
function Vd(e, t, n) {
    const r = n || {}
        , i = r.encode || mT;
    if (typeof i != "function")
        throw new TypeError("option encode is invalid");
    if (!_o.test(e))
        throw new TypeError("argument name is invalid");
    const s = i(t);
    if (s && !_o.test(s))
        throw new TypeError("argument val is invalid");
    let o = e + "=" + s;
    if (r.maxAge !== void 0 && r.maxAge !== null) {
        const a = r.maxAge - 0;
        if (Number.isNaN(a) || !Number.isFinite(a))
            throw new TypeError("option maxAge is invalid");
        o += "; Max-Age=" + Math.floor(a)
    }
    if (r.domain) {
        if (!_o.test(r.domain))
            throw new TypeError("option domain is invalid");
        o += "; Domain=" + r.domain
    }
    if (r.path) {
        if (!_o.test(r.path))
            throw new TypeError("option path is invalid");
        o += "; Path=" + r.path
    }
    if (r.expires) {
        if (!dT(r.expires) || Number.isNaN(r.expires.valueOf()))
            throw new TypeError("option expires is invalid");
        o += "; Expires=" + r.expires.toUTCString()
    }
    if (r.httpOnly && (o += "; HttpOnly"),
    r.secure && (o += "; Secure"),
        r.priority)
        switch (typeof r.priority == "string" ? r.priority.toLowerCase() : r.priority) {
            case "low":
                o += "; Priority=Low";
                break;
            case "medium":
                o += "; Priority=Medium";
                break;
            case "high":
                o += "; Priority=High";
                break;
            default:
                throw new TypeError("option priority is invalid")
        }
    if (r.sameSite)
        switch (typeof r.sameSite == "string" ? r.sameSite.toLowerCase() : r.sameSite) {
            case !0:
                o += "; SameSite=Strict";
                break;
            case "lax":
                o += "; SameSite=Lax";
                break;
            case "strict":
                o += "; SameSite=Strict";
                break;
            case "none":
                o += "; SameSite=None";
                break;
            default:
                throw new TypeError("option sameSite is invalid")
        }
    return o
}
function dT(e) {
    return Object.prototype.toString.call(e) === "[object Date]" || e instanceof Date
}
function pT(e, t) {
    try {
        return t(e)
    } catch {
        return e
    }
}
function hT(e) {
    return e.includes("%") ? decodeURIComponent(e) : e
}
function mT(e) {
    return encodeURIComponent(e)
}
function xl(e) {
    return e !== null && typeof e == "object"
}
function Ec(e, t, n=".", r) {
    if (!xl(t))
        return Ec(e, {}, n, r);
    const i = Object.assign({}, t);
    for (const s in e) {
        if (s === "__proto__" || s === "constructor")
            continue;
        const o = e[s];
        o != null && (r && r(i, s, o, n) || (Array.isArray(o) && Array.isArray(i[s]) ? i[s] = [...o, ...i[s]] : xl(o) && xl(i[s]) ? i[s] = Ec(o, i[s], (n ? `${n}.` : "") + s.toString(), r) : i[s] = o))
    }
    return i
}
function gT(e) {
    return (...t)=>t.reduce((n,r)=>Ec(n, r, "", e), {})
}
const vT = gT();
class Cc extends Error {
    constructor() {
        super(...arguments),
            this.statusCode = 500,
            this.fatal = !1,
            this.unhandled = !1
    }
    toJSON() {
        const t = {
            message: this.message,
            statusCode: xc(this.statusCode, 500)
        };
        return this.statusMessage && (t.statusMessage = Lv(this.statusMessage)),
        this.data !== void 0 && (t.data = this.data),
            t
    }
}
Cc.__h3_error__ = !0;
function Tc(e) {
    if (typeof e == "string")
        return new Cc(e);
    if (yT(e))
        return e;
    const t = new Cc(e.message ?? e.statusMessage ?? "",e.cause ? {
        cause: e.cause
    } : void 0);
    if ("stack"in e)
        try {
            Object.defineProperty(t, "stack", {
                get() {
                    return e.stack
                }
            })
        } catch {
            try {
                t.stack = e.stack
            } catch {}
        }
    if (e.data && (t.data = e.data),
        e.statusCode ? t.statusCode = xc(e.statusCode, t.statusCode) : e.status && (t.statusCode = xc(e.status, t.statusCode)),
        e.statusMessage ? t.statusMessage = e.statusMessage : e.statusText && (t.statusMessage = e.statusText),
        t.statusMessage) {
        const n = t.statusMessage;
        Lv(t.statusMessage) !== n && console.warn("[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.")
    }
    return e.fatal !== void 0 && (t.fatal = e.fatal),
    e.unhandled !== void 0 && (t.unhandled = e.unhandled),
        t
}
function yT(e) {
    var t;
    return ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.__h3_error__) === !0
}
const bT = /[^\u0009\u0020-\u007E]/g;
function Lv(e="") {
    return e.replace(bT, "")
}
function xc(e, t=200) {
    return !e || (typeof e == "string" && (e = Number.parseInt(e, 10)),
    e < 100 || e > 999) ? t : e
}
const wT = "$s";
function sf(...e) {
    const t = typeof e[e.length - 1] == "string" ? e.pop() : void 0;
    typeof e[0] != "string" && e.unshift(t);
    const [n,r] = e;
    if (!n || typeof n != "string")
        throw new TypeError("[nuxt] [useState] key must be a string: " + n);
    if (r !== void 0 && typeof r != "function")
        throw new Error("[nuxt] [useState] init must be a function: " + r);
    const i = wT + n
        , s = pt()
        , o = Ri(s.payload.state, i);
    if (o.value === void 0 && r) {
        const a = r();
        if (Je(a))
            return s.payload.state[i] = a,
                a;
        o.value = a
    }
    return o
}
const Ov = Symbol("layout-meta")
    , to = Symbol("route")
    , Jr = ()=>{
    var e;
    return (e = pt()) == null ? void 0 : e.$router
}
    , of = ()=>Bu() ? vt(to, pt()._route) : pt()._route;
/*! @__NO_SIDE_EFFECTS__ */
const ST = (e,t,n={})=>{
    const r = pt()
        , i = n.global || typeof e != "string"
        , s = typeof e != "string" ? e : t;
    if (!s) {
        console.warn("[nuxt] No route middleware passed to `addRouteMiddleware`.", e);
        return
    }
    i ? r._middleware.global.push(s) : r._middleware.named[e] = s
}
    , _T = ()=>{
    try {
        if (pt()._processingMiddleware)
            return !0
    } catch {
        return !0
    }
    return !1
}
    , ET = (e,t)=>{
    e || (e = "/");
    const n = typeof e == "string" ? e : fv(e.path || "/", e.query || {}) + (e.hash || "");
    if (t != null && t.open) {
        {
            const {target: a="_blank", windowFeatures: l={}} = t.open
                , c = Object.entries(l).filter(([u,f])=>f !== void 0).map(([u,f])=>`${u.toLowerCase()}=${f}`).join(", ");
            open(n, a, c)
        }
        return Promise.resolve()
    }
    const r = (t == null ? void 0 : t.external) || Qs(n, {
        acceptRelative: !0
    });
    if (r && !(t != null && t.external))
        throw new Error("Navigating to external URL is not allowed by default. Use `navigateTo (url, { external: true })`.");
    if (r && Ju(n).protocol === "script:")
        throw new Error("Cannot navigate to an URL with script protocol.");
    const i = _T();
    if (!r && i)
        return e;
    const s = Jr()
        , o = pt();
    return r ? (t != null && t.replace ? location.replace(n) : location.href = n,
        i ? o.isHydrating ? new Promise(()=>{}
        ) : !1 : Promise.resolve()) : t != null && t.replace ? s.replace(e) : s.push(e)
}
    , qa = ()=>Ri(pt().payload, "error")
    , yi = e=>{
    const t = af(e);
    try {
        const n = pt()
            , r = qa();
        n.hooks.callHook("app:error", t),
            r.value = r.value || t
    } catch {
        throw t
    }
    return t
}
    , Av = async(e={})=>{
    const t = pt()
        , n = qa();
    t.callHook("app:error:cleared", e),
    e.redirect && await Jr().replace(e.redirect),
        n.value = null
}
    , CT = e=>!!(e && typeof e == "object" && "__nuxt_error"in e)
    , af = e=>{
    const t = Tc(e);
    return t.__nuxt_error = !0,
        t
}
    , zd = {
    NuxtError: e=>af(e),
    EmptyShallowRef: e=>gr(e === "_" ? void 0 : e === "0n" ? BigInt(0) : JSON.parse(e)),
    EmptyRef: e=>X(e === "_" ? void 0 : e === "0n" ? BigInt(0) : JSON.parse(e)),
    ShallowRef: e=>gr(e),
    ShallowReactive: e=>Ui(e),
    Ref: e=>X(e),
    Reactive: e=>nn(e)
}
    , TT = dn({
    name: "nuxt:revive-payload:client",
    order: -30,
    async setup(e) {
        let t, n;
        for (const r in zd)
            uT(r, zd[r]);
        Object.assign(e.payload, ([t,n] = jr(()=>e.runWithContext(cT)),
            t = await t,
            n(),
            t)),
            window.__NUXT__ = e.payload
    }
});
/*!
  * vue-router v4.2.4
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */
const gi = typeof window < "u";
function xT(e) {
    return e.__esModule || e[Symbol.toStringTag] === "Module"
}
const Ke = Object.assign;
function Pl(e, t) {
    const n = {};
    for (const r in t) {
        const i = t[r];
        n[r] = xn(i) ? i.map(e) : e(i)
    }
    return n
}
const ws = ()=>{}
    , xn = Array.isArray
    , PT = /\/$/
    , kT = e=>e.replace(PT, "");
function kl(e, t, n="/") {
    let r, i = {}, s = "", o = "";
    const a = t.indexOf("#");
    let l = t.indexOf("?");
    return a < l && a >= 0 && (l = -1),
    l > -1 && (r = t.slice(0, l),
        s = t.slice(l + 1, a > -1 ? a : t.length),
        i = e(s)),
    a > -1 && (r = r || t.slice(0, a),
        o = t.slice(a, t.length)),
        r = AT(r ?? t, n),
        {
            fullPath: r + (s && "?") + s + o,
            path: r,
            query: i,
            hash: o
        }
}
function RT(e, t) {
    const n = t.query ? e(t.query) : "";
    return t.path + (n && "?") + n + (t.hash || "")
}
function Ud(e, t) {
    return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || "/"
}
function LT(e, t, n) {
    const r = t.matched.length - 1
        , i = n.matched.length - 1;
    return r > -1 && r === i && Ii(t.matched[r], n.matched[i]) && Iv(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash
}
function Ii(e, t) {
    return (e.aliasOf || e) === (t.aliasOf || t)
}
function Iv(e, t) {
    if (Object.keys(e).length !== Object.keys(t).length)
        return !1;
    for (const n in e)
        if (!OT(e[n], t[n]))
            return !1;
    return !0
}
function OT(e, t) {
    return xn(e) ? Wd(e, t) : xn(t) ? Wd(t, e) : e === t
}
function Wd(e, t) {
    return xn(t) ? e.length === t.length && e.every((n,r)=>n === t[r]) : e.length === 1 && e[0] === t
}
function AT(e, t) {
    if (e.startsWith("/"))
        return e;
    if (!e)
        return t;
    const n = t.split("/")
        , r = e.split("/")
        , i = r[r.length - 1];
    (i === ".." || i === ".") && r.push("");
    let s = n.length - 1, o, a;
    for (o = 0; o < r.length; o++)
        if (a = r[o],
        a !== ".")
            if (a === "..")
                s > 1 && s--;
            else
                break;
    return n.slice(0, s).join("/") + "/" + r.slice(o - (o === r.length ? 1 : 0)).join("/")
}
var $s;
(function(e) {
        e.pop = "pop",
            e.push = "push"
    }
)($s || ($s = {}));
var Ss;
(function(e) {
        e.back = "back",
            e.forward = "forward",
            e.unknown = ""
    }
)(Ss || (Ss = {}));
function IT(e) {
    if (!e)
        if (gi) {
            const t = document.querySelector("base");
            e = t && t.getAttribute("href") || "/",
                e = e.replace(/^\w+:\/\/[^\/]+/, "")
        } else
            e = "/";
    return e[0] !== "/" && e[0] !== "#" && (e = "/" + e),
        kT(e)
}
const MT = /^[^#]+#/;
function DT(e, t) {
    return e.replace(MT, "#") + t
}
function NT(e, t) {
    const n = document.documentElement.getBoundingClientRect()
        , r = e.getBoundingClientRect();
    return {
        behavior: t.behavior,
        left: r.left - n.left - (t.left || 0),
        top: r.top - n.top - (t.top || 0)
    }
}
const Ja = ()=>({
    left: window.pageXOffset,
    top: window.pageYOffset
});
function $T(e) {
    let t;
    if ("el"in e) {
        const n = e.el
            , r = typeof n == "string" && n.startsWith("#")
            , i = typeof n == "string" ? r ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
        if (!i)
            return;
        t = NT(i, e)
    } else
        t = e;
    "scrollBehavior"in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(t.left != null ? t.left : window.pageXOffset, t.top != null ? t.top : window.pageYOffset)
}
function Gd(e, t) {
    return (history.state ? history.state.position - t : -1) + e
}
const Pc = new Map;
function FT(e, t) {
    Pc.set(e, t)
}
function jT(e) {
    const t = Pc.get(e);
    return Pc.delete(e),
        t
}
let HT = ()=>location.protocol + "//" + location.host;
function Mv(e, t) {
    const {pathname: n, search: r, hash: i} = t
        , s = e.indexOf("#");
    if (s > -1) {
        let a = i.includes(e.slice(s)) ? e.slice(s).length : 1
            , l = i.slice(a);
        return l[0] !== "/" && (l = "/" + l),
            Ud(l, "")
    }
    return Ud(n, e) + r + i
}
function BT(e, t, n, r) {
    let i = []
        , s = []
        , o = null;
    const a = ({state: d})=>{
            const h = Mv(e, location)
                , y = n.value
                , p = t.value;
            let w = 0;
            if (d) {
                if (n.value = h,
                    t.value = d,
                o && o === y) {
                    o = null;
                    return
                }
                w = p ? d.position - p.position : 0
            } else
                r(h);
            i.forEach(m=>{
                    m(n.value, y, {
                        delta: w,
                        type: $s.pop,
                        direction: w ? w > 0 ? Ss.forward : Ss.back : Ss.unknown
                    })
                }
            )
        }
    ;
    function l() {
        o = n.value
    }
    function c(d) {
        i.push(d);
        const h = ()=>{
                const y = i.indexOf(d);
                y > -1 && i.splice(y, 1)
            }
        ;
        return s.push(h),
            h
    }
    function u() {
        const {history: d} = window;
        d.state && d.replaceState(Ke({}, d.state, {
            scroll: Ja()
        }), "")
    }
    function f() {
        for (const d of s)
            d();
        s = [],
            window.removeEventListener("popstate", a),
            window.removeEventListener("beforeunload", u)
    }
    return window.addEventListener("popstate", a),
        window.addEventListener("beforeunload", u, {
            passive: !0
        }),
        {
            pauseListeners: l,
            listen: c,
            destroy: f
        }
}
function Xd(e, t, n, r=!1, i=!1) {
    return {
        back: e,
        current: t,
        forward: n,
        replaced: r,
        position: window.history.length,
        scroll: i ? Ja() : null
    }
}
function VT(e) {
    const {history: t, location: n} = window
        , r = {
        value: Mv(e, n)
    }
        , i = {
        value: t.state
    };
    i.value || s(r.value, {
        back: null,
        current: r.value,
        forward: null,
        position: t.length - 1,
        replaced: !0,
        scroll: null
    }, !0);
    function s(l, c, u) {
        const f = e.indexOf("#")
            , d = f > -1 ? (n.host && document.querySelector("base") ? e : e.slice(f)) + l : HT() + e + l;
        try {
            t[u ? "replaceState" : "pushState"](c, "", d),
                i.value = c
        } catch (h) {
            console.error(h),
                n[u ? "replace" : "assign"](d)
        }
    }
    function o(l, c) {
        const u = Ke({}, t.state, Xd(i.value.back, l, i.value.forward, !0), c, {
            position: i.value.position
        });
        s(l, u, !0),
            r.value = l
    }
    function a(l, c) {
        const u = Ke({}, i.value, t.state, {
            forward: l,
            scroll: Ja()
        });
        s(u.current, u, !0);
        const f = Ke({}, Xd(r.value, l, null), {
            position: u.position + 1
        }, c);
        s(l, f, !1),
            r.value = l
    }
    return {
        location: r,
        state: i,
        push: a,
        replace: o
    }
}
function Dv(e) {
    e = IT(e);
    const t = VT(e)
        , n = BT(e, t.state, t.location, t.replace);
    function r(s, o=!0) {
        o || n.pauseListeners(),
            history.go(s)
    }
    const i = Ke({
        location: "",
        base: e,
        go: r,
        createHref: DT.bind(null, e)
    }, t, n);
    return Object.defineProperty(i, "location", {
        enumerable: !0,
        get: ()=>t.location.value
    }),
        Object.defineProperty(i, "state", {
            enumerable: !0,
            get: ()=>t.state.value
        }),
        i
}
function zT(e) {
    return e = location.host ? e || location.pathname + location.search : "",
    e.includes("#") || (e += "#"),
        Dv(e)
}
function UT(e) {
    return typeof e == "string" || e && typeof e == "object"
}
function Nv(e) {
    return typeof e == "string" || typeof e == "symbol"
}
const On = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
}
    , $v = Symbol("");
var Kd;
(function(e) {
        e[e.aborted = 4] = "aborted",
            e[e.cancelled = 8] = "cancelled",
            e[e.duplicated = 16] = "duplicated"
    }
)(Kd || (Kd = {}));
function Mi(e, t) {
    return Ke(new Error, {
        type: e,
        [$v]: !0
    }, t)
}
function jn(e, t) {
    return e instanceof Error && $v in e && (t == null || !!(e.type & t))
}
const Yd = "[^/]+?"
    , WT = {
    sensitive: !1,
    strict: !1,
    start: !0,
    end: !0
}
    , GT = /[.+*?^${}()[\]/\\]/g;
function XT(e, t) {
    const n = Ke({}, WT, t)
        , r = [];
    let i = n.start ? "^" : "";
    const s = [];
    for (const c of e) {
        const u = c.length ? [] : [90];
        n.strict && !c.length && (i += "/");
        for (let f = 0; f < c.length; f++) {
            const d = c[f];
            let h = 40 + (n.sensitive ? .25 : 0);
            if (d.type === 0)
                f || (i += "/"),
                    i += d.value.replace(GT, "\\$&"),
                    h += 40;
            else if (d.type === 1) {
                const {value: y, repeatable: p, optional: w, regexp: m} = d;
                s.push({
                    name: y,
                    repeatable: p,
                    optional: w
                });
                const g = m || Yd;
                if (g !== Yd) {
                    h += 10;
                    try {
                        new RegExp(`(${g})`)
                    } catch (v) {
                        throw new Error(`Invalid custom RegExp for param "${y}" (${g}): ` + v.message)
                    }
                }
                let b = p ? `((?:${g})(?:/(?:${g}))*)` : `(${g})`;
                f || (b = w && c.length < 2 ? `(?:/${b})` : "/" + b),
                w && (b += "?"),
                    i += b,
                    h += 20,
                w && (h += -8),
                p && (h += -20),
                g === ".*" && (h += -50)
            }
            u.push(h)
        }
        r.push(u)
    }
    if (n.strict && n.end) {
        const c = r.length - 1;
        r[c][r[c].length - 1] += .7000000000000001
    }
    n.strict || (i += "/?"),
        n.end ? i += "$" : n.strict && (i += "(?:/|$)");
    const o = new RegExp(i,n.sensitive ? "" : "i");
    function a(c) {
        const u = c.match(o)
            , f = {};
        if (!u)
            return null;
        for (let d = 1; d < u.length; d++) {
            const h = u[d] || ""
                , y = s[d - 1];
            f[y.name] = h && y.repeatable ? h.split("/") : h
        }
        return f
    }
    function l(c) {
        let u = ""
            , f = !1;
        for (const d of e) {
            (!f || !u.endsWith("/")) && (u += "/"),
                f = !1;
            for (const h of d)
                if (h.type === 0)
                    u += h.value;
                else if (h.type === 1) {
                    const {value: y, repeatable: p, optional: w} = h
                        , m = y in c ? c[y] : "";
                    if (xn(m) && !p)
                        throw new Error(`Provided param "${y}" is an array but it is not repeatable (* or + modifiers)`);
                    const g = xn(m) ? m.join("/") : m;
                    if (!g)
                        if (w)
                            d.length < 2 && (u.endsWith("/") ? u = u.slice(0, -1) : f = !0);
                        else
                            throw new Error(`Missing required param "${y}"`);
                    u += g
                }
        }
        return u || "/"
    }
    return {
        re: o,
        score: r,
        keys: s,
        parse: a,
        stringify: l
    }
}
function KT(e, t) {
    let n = 0;
    for (; n < e.length && n < t.length; ) {
        const r = t[n] - e[n];
        if (r)
            return r;
        n++
    }
    return e.length < t.length ? e.length === 1 && e[0] === 40 + 40 ? -1 : 1 : e.length > t.length ? t.length === 1 && t[0] === 40 + 40 ? 1 : -1 : 0
}
function YT(e, t) {
    let n = 0;
    const r = e.score
        , i = t.score;
    for (; n < r.length && n < i.length; ) {
        const s = KT(r[n], i[n]);
        if (s)
            return s;
        n++
    }
    if (Math.abs(i.length - r.length) === 1) {
        if (qd(r))
            return 1;
        if (qd(i))
            return -1
    }
    return i.length - r.length
}
function qd(e) {
    const t = e[e.length - 1];
    return e.length > 0 && t[t.length - 1] < 0
}
const qT = {
    type: 0,
    value: ""
}
    , JT = /[a-zA-Z0-9_]/;
function ZT(e) {
    if (!e)
        return [[]];
    if (e === "/")
        return [[qT]];
    if (!e.startsWith("/"))
        throw new Error(`Invalid path "${e}"`);
    function t(h) {
        throw new Error(`ERR (${n})/"${c}": ${h}`)
    }
    let n = 0
        , r = n;
    const i = [];
    let s;
    function o() {
        s && i.push(s),
            s = []
    }
    let a = 0, l, c = "", u = "";
    function f() {
        c && (n === 0 ? s.push({
            type: 0,
            value: c
        }) : n === 1 || n === 2 || n === 3 ? (s.length > 1 && (l === "*" || l === "+") && t(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`),
            s.push({
                type: 1,
                value: c,
                regexp: u,
                repeatable: l === "*" || l === "+",
                optional: l === "*" || l === "?"
            })) : t("Invalid state to consume buffer"),
            c = "")
    }
    function d() {
        c += l
    }
    for (; a < e.length; ) {
        if (l = e[a++],
        l === "\\" && n !== 2) {
            r = n,
                n = 4;
            continue
        }
        switch (n) {
            case 0:
                l === "/" ? (c && f(),
                    o()) : l === ":" ? (f(),
                    n = 1) : d();
                break;
            case 4:
                d(),
                    n = r;
                break;
            case 1:
                l === "(" ? n = 2 : JT.test(l) ? d() : (f(),
                    n = 0,
                l !== "*" && l !== "?" && l !== "+" && a--);
                break;
            case 2:
                l === ")" ? u[u.length - 1] == "\\" ? u = u.slice(0, -1) + l : n = 3 : u += l;
                break;
            case 3:
                f(),
                    n = 0,
                l !== "*" && l !== "?" && l !== "+" && a--,
                    u = "";
                break;
            default:
                t("Unknown state");
                break
        }
    }
    return n === 2 && t(`Unfinished custom RegExp for param "${c}"`),
        f(),
        o(),
        i
}
function QT(e, t, n) {
    const r = XT(ZT(e.path), n)
        , i = Ke(r, {
        record: e,
        parent: t,
        children: [],
        alias: []
    });
    return t && !i.record.aliasOf == !t.record.aliasOf && t.children.push(i),
        i
}
function e1(e, t) {
    const n = []
        , r = new Map;
    t = Qd({
        strict: !1,
        end: !0,
        sensitive: !1
    }, t);
    function i(u) {
        return r.get(u)
    }
    function s(u, f, d) {
        const h = !d
            , y = t1(u);
        y.aliasOf = d && d.record;
        const p = Qd(t, u)
            , w = [y];
        if ("alias"in u) {
            const b = typeof u.alias == "string" ? [u.alias] : u.alias;
            for (const v of b)
                w.push(Ke({}, y, {
                    components: d ? d.record.components : y.components,
                    path: v,
                    aliasOf: d ? d.record : y
                }))
        }
        let m, g;
        for (const b of w) {
            const {path: v} = b;
            if (f && v[0] !== "/") {
                const S = f.record.path
                    , _ = S[S.length - 1] === "/" ? "" : "/";
                b.path = f.record.path + (v && _ + v)
            }
            if (m = QT(b, f, p),
                d ? d.alias.push(m) : (g = g || m,
                g !== m && g.alias.push(m),
                h && u.name && !Zd(m) && o(u.name)),
                y.children) {
                const S = y.children;
                for (let _ = 0; _ < S.length; _++)
                    s(S[_], m, d && d.children[_])
            }
            d = d || m,
            (m.record.components && Object.keys(m.record.components).length || m.record.name || m.record.redirect) && l(m)
        }
        return g ? ()=>{
                o(g)
            }
            : ws
    }
    function o(u) {
        if (Nv(u)) {
            const f = r.get(u);
            f && (r.delete(u),
                n.splice(n.indexOf(f), 1),
                f.children.forEach(o),
                f.alias.forEach(o))
        } else {
            const f = n.indexOf(u);
            f > -1 && (n.splice(f, 1),
            u.record.name && r.delete(u.record.name),
                u.children.forEach(o),
                u.alias.forEach(o))
        }
    }
    function a() {
        return n
    }
    function l(u) {
        let f = 0;
        for (; f < n.length && YT(u, n[f]) >= 0 && (u.record.path !== n[f].record.path || !Fv(u, n[f])); )
            f++;
        n.splice(f, 0, u),
        u.record.name && !Zd(u) && r.set(u.record.name, u)
    }
    function c(u, f) {
        let d, h = {}, y, p;
        if ("name"in u && u.name) {
            if (d = r.get(u.name),
                !d)
                throw Mi(1, {
                    location: u
                });
            p = d.record.name,
                h = Ke(Jd(f.params, d.keys.filter(g=>!g.optional).map(g=>g.name)), u.params && Jd(u.params, d.keys.map(g=>g.name))),
                y = d.stringify(h)
        } else if ("path"in u)
            y = u.path,
                d = n.find(g=>g.re.test(y)),
            d && (h = d.parse(y),
                p = d.record.name);
        else {
            if (d = f.name ? r.get(f.name) : n.find(g=>g.re.test(f.path)),
                !d)
                throw Mi(1, {
                    location: u,
                    currentLocation: f
                });
            p = d.record.name,
                h = Ke({}, f.params, u.params),
                y = d.stringify(h)
        }
        const w = [];
        let m = d;
        for (; m; )
            w.unshift(m.record),
                m = m.parent;
        return {
            name: p,
            path: y,
            params: h,
            matched: w,
            meta: r1(w)
        }
    }
    return e.forEach(u=>s(u)),
        {
            addRoute: s,
            resolve: c,
            removeRoute: o,
            getRoutes: a,
            getRecordMatcher: i
        }
}
function Jd(e, t) {
    const n = {};
    for (const r of t)
        r in e && (n[r] = e[r]);
    return n
}
function t1(e) {
    return {
        path: e.path,
        redirect: e.redirect,
        name: e.name,
        meta: e.meta || {},
        aliasOf: void 0,
        beforeEnter: e.beforeEnter,
        props: n1(e),
        children: e.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components"in e ? e.components || null : e.component && {
            default: e.component
        }
    }
}
function n1(e) {
    const t = {}
        , n = e.props || !1;
    if ("component"in e)
        t.default = n;
    else
        for (const r in e.components)
            t[r] = typeof n == "object" ? n[r] : n;
    return t
}
function Zd(e) {
    for (; e; ) {
        if (e.record.aliasOf)
            return !0;
        e = e.parent
    }
    return !1
}
function r1(e) {
    return e.reduce((t,n)=>Ke(t, n.meta), {})
}
function Qd(e, t) {
    const n = {};
    for (const r in e)
        n[r] = r in t ? t[r] : e[r];
    return n
}
function Fv(e, t) {
    return t.children.some(n=>n === e || Fv(e, n))
}
const jv = /#/g
    , i1 = /&/g
    , s1 = /\//g
    , o1 = /=/g
    , a1 = /\?/g
    , Hv = /\+/g
    , l1 = /%5B/g
    , c1 = /%5D/g
    , Bv = /%5E/g
    , u1 = /%60/g
    , Vv = /%7B/g
    , f1 = /%7C/g
    , zv = /%7D/g
    , d1 = /%20/g;
function lf(e) {
    return encodeURI("" + e).replace(f1, "|").replace(l1, "[").replace(c1, "]")
}
function p1(e) {
    return lf(e).replace(Vv, "{").replace(zv, "}").replace(Bv, "^")
}
function kc(e) {
    return lf(e).replace(Hv, "%2B").replace(d1, "+").replace(jv, "%23").replace(i1, "%26").replace(u1, "`").replace(Vv, "{").replace(zv, "}").replace(Bv, "^")
}
function h1(e) {
    return kc(e).replace(o1, "%3D")
}
function m1(e) {
    return lf(e).replace(jv, "%23").replace(a1, "%3F")
}
function g1(e) {
    return e == null ? "" : m1(e).replace(s1, "%2F")
}
function ua(e) {
    try {
        return decodeURIComponent("" + e)
    } catch {}
    return "" + e
}
function v1(e) {
    const t = {};
    if (e === "" || e === "?")
        return t;
    const r = (e[0] === "?" ? e.slice(1) : e).split("&");
    for (let i = 0; i < r.length; ++i) {
        const s = r[i].replace(Hv, " ")
            , o = s.indexOf("=")
            , a = ua(o < 0 ? s : s.slice(0, o))
            , l = o < 0 ? null : ua(s.slice(o + 1));
        if (a in t) {
            let c = t[a];
            xn(c) || (c = t[a] = [c]),
                c.push(l)
        } else
            t[a] = l
    }
    return t
}
function ep(e) {
    let t = "";
    for (let n in e) {
        const r = e[n];
        if (n = h1(n),
        r == null) {
            r !== void 0 && (t += (t.length ? "&" : "") + n);
            continue
        }
        (xn(r) ? r.map(s=>s && kc(s)) : [r && kc(r)]).forEach(s=>{
                s !== void 0 && (t += (t.length ? "&" : "") + n,
                s != null && (t += "=" + s))
            }
        )
    }
    return t
}
function y1(e) {
    const t = {};
    for (const n in e) {
        const r = e[n];
        r !== void 0 && (t[n] = xn(r) ? r.map(i=>i == null ? null : "" + i) : r == null ? r : "" + r)
    }
    return t
}
const b1 = Symbol("")
    , tp = Symbol("")
    , Za = Symbol("")
    , cf = Symbol("")
    , Rc = Symbol("");
function Qi() {
    let e = [];
    function t(r) {
        return e.push(r),
            ()=>{
                const i = e.indexOf(r);
                i > -1 && e.splice(i, 1)
            }
    }
    function n() {
        e = []
    }
    return {
        add: t,
        list: ()=>e.slice(),
        reset: n
    }
}
function lr(e, t, n, r, i) {
    const s = r && (r.enterCallbacks[i] = r.enterCallbacks[i] || []);
    return ()=>new Promise((o,a)=>{
            const l = f=>{
                f === !1 ? a(Mi(4, {
                    from: n,
                    to: t
                })) : f instanceof Error ? a(f) : UT(f) ? a(Mi(2, {
                    from: t,
                    to: f
                })) : (s && r.enterCallbacks[i] === s && typeof f == "function" && s.push(f),
                    o())
            }
                , c = e.call(r && r.instances[i], t, n, l);
            let u = Promise.resolve(c);
            e.length < 3 && (u = u.then(l)),
                u.catch(f=>a(f))
        }
    )
}
function Rl(e, t, n, r) {
    const i = [];
    for (const s of e)
        for (const o in s.components) {
            let a = s.components[o];
            if (!(t !== "beforeRouteEnter" && !s.instances[o]))
                if (w1(a)) {
                    const c = (a.__vccOpts || a)[t];
                    c && i.push(lr(c, n, r, s, o))
                } else {
                    let l = a();
                    i.push(()=>l.then(c=>{
                            if (!c)
                                return Promise.reject(new Error(`Couldn't resolve component "${o}" at "${s.path}"`));
                            const u = xT(c) ? c.default : c;
                            s.components[o] = u;
                            const d = (u.__vccOpts || u)[t];
                            return d && lr(d, n, r, s, o)()
                        }
                    ))
                }
        }
    return i
}
function w1(e) {
    return typeof e == "object" || "displayName"in e || "props"in e || "__vccOpts"in e
}
function np(e) {
    const t = vt(Za)
        , n = vt(cf)
        , r = fe(()=>t.resolve(we(e.to)))
        , i = fe(()=>{
            const {matched: l} = r.value
                , {length: c} = l
                , u = l[c - 1]
                , f = n.matched;
            if (!u || !f.length)
                return -1;
            const d = f.findIndex(Ii.bind(null, u));
            if (d > -1)
                return d;
            const h = rp(l[c - 2]);
            return c > 1 && rp(u) === h && f[f.length - 1].path !== h ? f.findIndex(Ii.bind(null, l[c - 2])) : d
        }
    )
        , s = fe(()=>i.value > -1 && C1(n.params, r.value.params))
        , o = fe(()=>i.value > -1 && i.value === n.matched.length - 1 && Iv(n.params, r.value.params));
    function a(l={}) {
        return E1(l) ? t[we(e.replace) ? "replace" : "push"](we(e.to)).catch(ws) : Promise.resolve()
    }
    return {
        route: r,
        href: fe(()=>r.value.href),
        isActive: s,
        isExactActive: o,
        navigate: a
    }
}
const S1 = Xe({
    name: "RouterLink",
    compatConfig: {
        MODE: 3
    },
    props: {
        to: {
            type: [String, Object],
            required: !0
        },
        replace: Boolean,
        activeClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
            type: String,
            default: "page"
        }
    },
    useLink: np,
    setup(e, {slots: t}) {
        const n = nn(np(e))
            , {options: r} = vt(Za)
            , i = fe(()=>({
            [ip(e.activeClass, r.linkActiveClass, "router-link-active")]: n.isActive,
            [ip(e.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
        }));
        return ()=>{
            const s = t.default && t.default(n);
            return e.custom ? s : yt("a", {
                "aria-current": n.isExactActive ? e.ariaCurrentValue : null,
                href: n.href,
                onClick: n.navigate,
                class: i.value
            }, s)
        }
    }
})
    , _1 = S1;
function E1(e) {
    if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && !e.defaultPrevented && !(e.button !== void 0 && e.button !== 0)) {
        if (e.currentTarget && e.currentTarget.getAttribute) {
            const t = e.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(t))
                return
        }
        return e.preventDefault && e.preventDefault(),
            !0
    }
}
function C1(e, t) {
    for (const n in t) {
        const r = t[n]
            , i = e[n];
        if (typeof r == "string") {
            if (r !== i)
                return !1
        } else if (!xn(i) || i.length !== r.length || r.some((s,o)=>s !== i[o]))
            return !1
    }
    return !0
}
function rp(e) {
    return e ? e.aliasOf ? e.aliasOf.path : e.path : ""
}
const ip = (e,t,n)=>e ?? t ?? n
    , T1 = Xe({
    name: "RouterView",
    inheritAttrs: !1,
    props: {
        name: {
            type: String,
            default: "default"
        },
        route: Object
    },
    compatConfig: {
        MODE: 3
    },
    setup(e, {attrs: t, slots: n}) {
        const r = vt(Rc)
            , i = fe(()=>e.route || r.value)
            , s = vt(tp, 0)
            , o = fe(()=>{
                let c = we(s);
                const {matched: u} = i.value;
                let f;
                for (; (f = u[c]) && !f.components; )
                    c++;
                return c
            }
        )
            , a = fe(()=>i.value.matched[o.value]);
        Dn(tp, fe(()=>o.value + 1)),
            Dn(b1, a),
            Dn(Rc, i);
        const l = X();
        return Se(()=>[l.value, a.value, e.name], ([c,u,f],[d,h,y])=>{
                u && (u.instances[f] = c,
                h && h !== u && c && c === d && (u.leaveGuards.size || (u.leaveGuards = h.leaveGuards),
                u.updateGuards.size || (u.updateGuards = h.updateGuards))),
                c && u && (!h || !Ii(u, h) || !d) && (u.enterCallbacks[f] || []).forEach(p=>p(c))
            }
            , {
                flush: "post"
            }),
            ()=>{
                const c = i.value
                    , u = e.name
                    , f = a.value
                    , d = f && f.components[u];
                if (!d)
                    return sp(n.default, {
                        Component: d,
                        route: c
                    });
                const h = f.props[u]
                    , y = h ? h === !0 ? c.params : typeof h == "function" ? h(c) : h : null
                    , w = yt(d, Ke({}, y, t, {
                    onVnodeUnmounted: m=>{
                        m.component.isUnmounted && (f.instances[u] = null)
                    }
                    ,
                    ref: l
                }));
                return sp(n.default, {
                    Component: w,
                    route: c
                }) || w
            }
    }
});
function sp(e, t) {
    if (!e)
        return null;
    const n = e(t);
    return n.length === 1 ? n[0] : n
}
const Uv = T1;
function x1(e) {
    const t = e1(e.routes, e)
        , n = e.parseQuery || v1
        , r = e.stringifyQuery || ep
        , i = e.history
        , s = Qi()
        , o = Qi()
        , a = Qi()
        , l = gr(On);
    let c = On;
    gi && e.scrollBehavior && "scrollRestoration"in history && (history.scrollRestoration = "manual");
    const u = Pl.bind(null, J=>"" + J)
        , f = Pl.bind(null, g1)
        , d = Pl.bind(null, ua);
    function h(J, ne) {
        let ee, ce;
        return Nv(J) ? (ee = t.getRecordMatcher(J),
            ce = ne) : ce = J,
            t.addRoute(ce, ee)
    }
    function y(J) {
        const ne = t.getRecordMatcher(J);
        ne && t.removeRoute(ne)
    }
    function p() {
        return t.getRoutes().map(J=>J.record)
    }
    function w(J) {
        return !!t.getRecordMatcher(J)
    }
    function m(J, ne) {
        if (ne = Ke({}, ne || l.value),
        typeof J == "string") {
            const R = kl(n, J, ne.path)
                , F = t.resolve({
                path: R.path
            }, ne)
                , V = i.createHref(R.fullPath);
            return Ke(R, F, {
                params: d(F.params),
                hash: ua(R.hash),
                redirectedFrom: void 0,
                href: V
            })
        }
        let ee;
        if ("path"in J)
            ee = Ke({}, J, {
                path: kl(n, J.path, ne.path).path
            });
        else {
            const R = Ke({}, J.params);
            for (const F in R)
                R[F] == null && delete R[F];
            ee = Ke({}, J, {
                params: f(R)
            }),
                ne.params = f(ne.params)
        }
        const ce = t.resolve(ee, ne)
            , Ce = J.hash || "";
        ce.params = u(d(ce.params));
        const M = RT(r, Ke({}, J, {
            hash: p1(Ce),
            path: ce.path
        }))
            , C = i.createHref(M);
        return Ke({
            fullPath: M,
            hash: Ce,
            query: r === ep ? y1(J.query) : J.query || {}
        }, ce, {
            redirectedFrom: void 0,
            href: C
        })
    }
    function g(J) {
        return typeof J == "string" ? kl(n, J, l.value.path) : Ke({}, J)
    }
    function b(J, ne) {
        if (c !== J)
            return Mi(8, {
                from: ne,
                to: J
            })
    }
    function v(J) {
        return E(J)
    }
    function S(J) {
        return v(Ke(g(J), {
            replace: !0
        }))
    }
    function _(J) {
        const ne = J.matched[J.matched.length - 1];
        if (ne && ne.redirect) {
            const {redirect: ee} = ne;
            let ce = typeof ee == "function" ? ee(J) : ee;
            return typeof ce == "string" && (ce = ce.includes("?") || ce.includes("#") ? ce = g(ce) : {
                path: ce
            },
                ce.params = {}),
                Ke({
                    query: J.query,
                    hash: J.hash,
                    params: "path"in ce ? {} : J.params
                }, ce)
        }
    }
    function E(J, ne) {
        const ee = c = m(J)
            , ce = l.value
            , Ce = J.state
            , M = J.force
            , C = J.replace === !0
            , R = _(ee);
        if (R)
            return E(Ke(g(R), {
                state: typeof R == "object" ? Ke({}, Ce, R.state) : Ce,
                force: M,
                replace: C
            }), ne || ee);
        const F = ee;
        F.redirectedFrom = ne;
        let V;
        return !M && LT(r, ce, ee) && (V = Mi(16, {
            to: F,
            from: ce
        }),
            ge(ce, ce, !0, !1)),
            (V ? Promise.resolve(V) : I(F, ce)).catch(Y=>jn(Y) ? jn(Y, 2) ? Y : le(Y) : W(Y, F, ce)).then(Y=>{
                    if (Y) {
                        if (jn(Y, 2))
                            return E(Ke({
                                replace: C
                            }, g(Y.to), {
                                state: typeof Y.to == "object" ? Ke({}, Ce, Y.to.state) : Ce,
                                force: M
                            }), ne || F)
                    } else
                        Y = x(F, ce, !0, C, Ce);
                    return L(F, ce, Y),
                        Y
                }
            )
    }
    function T(J, ne) {
        const ee = b(J, ne);
        return ee ? Promise.reject(ee) : Promise.resolve()
    }
    function P(J) {
        const ne = z.values().next().value;
        return ne && typeof ne.runWithContext == "function" ? ne.runWithContext(J) : J()
    }
    function I(J, ne) {
        let ee;
        const [ce,Ce,M] = P1(J, ne);
        ee = Rl(ce.reverse(), "beforeRouteLeave", J, ne);
        for (const R of ce)
            R.leaveGuards.forEach(F=>{
                    ee.push(lr(F, J, ne))
                }
            );
        const C = T.bind(null, J, ne);
        return ee.push(C),
            _e(ee).then(()=>{
                    ee = [];
                    for (const R of s.list())
                        ee.push(lr(R, J, ne));
                    return ee.push(C),
                        _e(ee)
                }
            ).then(()=>{
                    ee = Rl(Ce, "beforeRouteUpdate", J, ne);
                    for (const R of Ce)
                        R.updateGuards.forEach(F=>{
                                ee.push(lr(F, J, ne))
                            }
                        );
                    return ee.push(C),
                        _e(ee)
                }
            ).then(()=>{
                    ee = [];
                    for (const R of M)
                        if (R.beforeEnter)
                            if (xn(R.beforeEnter))
                                for (const F of R.beforeEnter)
                                    ee.push(lr(F, J, ne));
                            else
                                ee.push(lr(R.beforeEnter, J, ne));
                    return ee.push(C),
                        _e(ee)
                }
            ).then(()=>(J.matched.forEach(R=>R.enterCallbacks = {}),
                ee = Rl(M, "beforeRouteEnter", J, ne),
                ee.push(C),
                _e(ee))).then(()=>{
                    ee = [];
                    for (const R of o.list())
                        ee.push(lr(R, J, ne));
                    return ee.push(C),
                        _e(ee)
                }
            ).catch(R=>jn(R, 8) ? R : Promise.reject(R))
    }
    function L(J, ne, ee) {
        a.list().forEach(ce=>P(()=>ce(J, ne, ee)))
    }
    function x(J, ne, ee, ce, Ce) {
        const M = b(J, ne);
        if (M)
            return M;
        const C = ne === On
            , R = gi ? history.state : {};
        ee && (ce || C ? i.replace(J.fullPath, Ke({
            scroll: C && R && R.scroll
        }, Ce)) : i.push(J.fullPath, Ce)),
            l.value = J,
            ge(J, ne, ee, C),
            le()
    }
    let A;
    function k() {
        A || (A = i.listen((J,ne,ee)=>{
                if (!Pe.listening)
                    return;
                const ce = m(J)
                    , Ce = _(ce);
                if (Ce) {
                    E(Ke(Ce, {
                        replace: !0
                    }), ce).catch(ws);
                    return
                }
                c = ce;
                const M = l.value;
                gi && FT(Gd(M.fullPath, ee.delta), Ja()),
                    I(ce, M).catch(C=>jn(C, 12) ? C : jn(C, 2) ? (E(C.to, ce).then(R=>{
                            jn(R, 20) && !ee.delta && ee.type === $s.pop && i.go(-1, !1)
                        }
                    ).catch(ws),
                        Promise.reject()) : (ee.delta && i.go(-ee.delta, !1),
                        W(C, ce, M))).then(C=>{
                            C = C || x(ce, M, !1),
                            C && (ee.delta && !jn(C, 8) ? i.go(-ee.delta, !1) : ee.type === $s.pop && jn(C, 20) && i.go(-1, !1)),
                                L(ce, M, C)
                        }
                    ).catch(ws)
            }
        ))
    }
    let O = Qi(), N = Qi(), D;
    function W(J, ne, ee) {
        le(J);
        const ce = N.list();
        return ce.length ? ce.forEach(Ce=>Ce(J, ne, ee)) : console.error(J),
            Promise.reject(J)
    }
    function G() {
        return D && l.value !== On ? Promise.resolve() : new Promise((J,ne)=>{
                O.add([J, ne])
            }
        )
    }
    function le(J) {
        return D || (D = !J,
            k(),
            O.list().forEach(([ne,ee])=>J ? ee(J) : ne()),
            O.reset()),
            J
    }
    function ge(J, ne, ee, ce) {
        const {scrollBehavior: Ce} = e;
        if (!gi || !Ce)
            return Promise.resolve();
        const M = !ee && jT(Gd(J.fullPath, 0)) || (ce || !ee) && history.state && history.state.scroll || null;
        return ct().then(()=>Ce(J, ne, M)).then(C=>C && $T(C)).catch(C=>W(C, J, ne))
    }
    const ye = J=>i.go(J);
    let de;
    const z = new Set
        , Pe = {
        currentRoute: l,
        listening: !0,
        addRoute: h,
        removeRoute: y,
        hasRoute: w,
        getRoutes: p,
        resolve: m,
        options: e,
        push: v,
        replace: S,
        go: ye,
        back: ()=>ye(-1),
        forward: ()=>ye(1),
        beforeEach: s.add,
        beforeResolve: o.add,
        afterEach: a.add,
        onError: N.add,
        isReady: G,
        install(J) {
            const ne = this;
            J.component("RouterLink", _1),
                J.component("RouterView", Uv),
                J.config.globalProperties.$router = ne,
                Object.defineProperty(J.config.globalProperties, "$route", {
                    enumerable: !0,
                    get: ()=>we(l)
                }),
            gi && !de && l.value === On && (de = !0,
                v(i.location).catch(Ce=>{}
                ));
            const ee = {};
            for (const Ce in On)
                Object.defineProperty(ee, Ce, {
                    get: ()=>l.value[Ce],
                    enumerable: !0
                });
            J.provide(Za, ne),
                J.provide(cf, Ui(ee)),
                J.provide(Rc, l);
            const ce = J.unmount;
            z.add(J),
                J.unmount = function() {
                    z.delete(J),
                    z.size < 1 && (c = On,
                    A && A(),
                        A = null,
                        l.value = On,
                        de = !1,
                        D = !1),
                        ce()
                }
        }
    };
    function _e(J) {
        return J.reduce((ne,ee)=>ne.then(()=>P(ee)), Promise.resolve())
    }
    return Pe
}
function P1(e, t) {
    const n = []
        , r = []
        , i = []
        , s = Math.max(t.matched.length, e.matched.length);
    for (let o = 0; o < s; o++) {
        const a = t.matched[o];
        a && (e.matched.find(c=>Ii(c, a)) ? r.push(a) : n.push(a));
        const l = e.matched[o];
        l && (t.matched.find(c=>Ii(c, l)) || i.push(l))
    }
    return [n, r, i]
}
function Wv() {
    return vt(Za)
}
function uf() {
    return vt(cf)
}
const op = [{
    name: "index",
    path: "/",
    meta: {},
    alias: [],
    redirect: void 0,
    component: ()=>at(()=>import("./index.1e6fc611.js"), ["./index.1e6fc611.js", "./_plugin-vue_export-helper.c27b6911.js", "./premium.vue.bcace696.js", "./index.167e2652.css"], import.meta.url).then(e=>e.default || e)
}, {
    name: "info.ru",
    path: "/info.ru",
    meta: {},
    alias: [],
    redirect: void 0,
    component: ()=>at(()=>import("./info.ru.be52bc33.js"), ["./info.ru.be52bc33.js", "./_plugin-vue_export-helper.c27b6911.js", "./info.ru.3cde7fa6.css"], import.meta.url).then(e=>e.default || e)
}, {
    name: "info",
    path: "/info",
    meta: {},
    alias: [],
    redirect: void 0,
    component: ()=>at(()=>import("./info.9307420f.js"), ["./info.9307420f.js", "./_plugin-vue_export-helper.c27b6911.js", "./info.48eef1bb.css"], import.meta.url).then(e=>e.default || e)
}, {
    name: "obs",
    path: "/obs",
    meta: {},
    alias: [],
    redirect: void 0,
    component: ()=>at(()=>import("./obs.7d297c18.js"), ["./obs.7d297c18.js", "./_plugin-vue_export-helper.c27b6911.js", "./obs.be9da3fb.css"], import.meta.url).then(e=>e.default || e)
}, {
    name: "premium",
    path: "/premium",
    meta: {},
    alias: [],
    redirect: void 0,
    component: ()=>at(()=>import("./premium.ff0c78c9.js"), ["./premium.ff0c78c9.js", "./premium.vue.bcace696.js", "./_plugin-vue_export-helper.c27b6911.js"], import.meta.url).then(e=>e.default || e)
}, {
    name: "privacy.ru",
    path: "/privacy.ru",
    meta: {},
    alias: [],
    redirect: void 0,
    component: ()=>at(()=>import("./privacy.ru.513a3b77.js"), ["./privacy.ru.513a3b77.js", "./_plugin-vue_export-helper.c27b6911.js", "./privacy.ru.901d3bb5.css"], import.meta.url).then(e=>e.default || e)
}, {
    name: "privacy",
    path: "/privacy",
    meta: {},
    alias: [],
    redirect: void 0,
    component: ()=>at(()=>import("./privacy.bb9e96dc.js"), ["./privacy.bb9e96dc.js", "./_plugin-vue_export-helper.c27b6911.js", "./privacy.7c92e9bd.css"], import.meta.url).then(e=>e.default || e)
}, {
    name: "rules.ru",
    path: "/rules.ru",
    meta: {},
    alias: [],
    redirect: void 0,
    component: ()=>at(()=>import("./rules.ru.d7bd911d.js"), ["./rules.ru.d7bd911d.js", "./_plugin-vue_export-helper.c27b6911.js", "./rules.ru.2cb99779.css"], import.meta.url).then(e=>e.default || e)
}, {
    name: "rules",
    path: "/rules",
    meta: {},
    alias: [],
    redirect: void 0,
    component: ()=>at(()=>import("./rules.d0e1e75b.js"), ["./rules.d0e1e75b.js", "./_plugin-vue_export-helper.c27b6911.js", "./rules.888bbdd4.css"], import.meta.url).then(e=>e.default || e)
}, {
    name: "user-agreement.ru",
    path: "/user-agreement.ru",
    meta: {},
    alias: [],
    redirect: void 0,
    component: ()=>at(()=>import("./user-agreement.ru.3cc11961.js"), ["./user-agreement.ru.3cc11961.js", "./_plugin-vue_export-helper.c27b6911.js", "./user-agreement.ru.a9462cd8.css"], import.meta.url).then(e=>e.default || e)
}, {
    name: "user-agreement",
    path: "/user-agreement",
    meta: {},
    alias: [],
    redirect: void 0,
    component: ()=>at(()=>import("./user-agreement.b726f023.js"), ["./user-agreement.b726f023.js", "./_plugin-vue_export-helper.c27b6911.js", "./user-agreement.b17d481c.css"], import.meta.url).then(e=>e.default || e)
}]
    , k1 = {
    scrollBehavior(e, t, n) {
        const r = pt();
        let i = n || void 0;
        if (!i && t && e && e.meta.scrollToTop !== !1 && R1(t, e) && (i = {
            left: 0,
            top: 0
        }),
        e.path === t.path) {
            if (t.hash && !e.hash)
                return {
                    left: 0,
                    top: 0
                };
            if (e.hash)
                return {
                    el: e.hash,
                    top: ap(e.hash)
                }
        }
        const s = a=>!!(a.meta.pageTransition ?? _c)
            , o = s(t) && s(e) ? "page:transition:finish" : "page:finish";
        return new Promise(a=>{
                r.hooks.hookOnce(o, async()=>{
                        await ct(),
                        e.hash && (i = {
                            el: e.hash,
                            top: ap(e.hash)
                        }),
                            a(i)
                    }
                )
            }
        )
    }
};
function ap(e) {
    try {
        const t = document.querySelector(e);
        if (t)
            return parseFloat(getComputedStyle(t).scrollMarginTop)
    } catch {}
    return 0
}
function R1(e, t) {
    const n = t.matched.every((r,i)=>{
            var s, o, a;
            return ((s = r.components) == null ? void 0 : s.default) === ((a = (o = e.matched[i]) == null ? void 0 : o.components) == null ? void 0 : a.default)
        }
    );
    return !!(!n || n && JSON.stringify(e.params) !== JSON.stringify(t.params))
}
const L1 = {}
    , jt = {
    ...L1,
    ...k1
}
    , O1 = async e=>{
    var l;
    let t, n;
    if (!((l = e.meta) != null && l.validate))
        return;
    const r = pt()
        , i = Jr();
    if (([t,n] = jr(()=>Promise.resolve(e.meta.validate(e))),
        t = await t,
        n(),
        t) === !0)
        return;
    const o = af({
        statusCode: 404,
        statusMessage: `Page Not Found: ${e.fullPath}`
    })
        , a = i.beforeResolve(c=>{
            if (a(),
            c === e) {
                const u = i.afterEach(async()=>{
                        u(),
                            await r.runWithContext(()=>yi(o)),
                            window.history.pushState({}, "", e.fullPath)
                    }
                );
                return !1
            }
        }
    )
}
    , A1 = [O1]
    , _s = {};
function I1(e, t, n) {
    const {pathname: r, search: i, hash: s} = t
        , o = e.indexOf("#");
    if (o > -1) {
        const c = s.includes(e.slice(o)) ? e.slice(o).length : 1;
        let u = s.slice(c);
        return u[0] !== "/" && (u = "/" + u),
            Md(u, "")
    }
    const a = Md(r, e)
        , l = !n || pv(a, n, {
        trailingSlash: !0
    }) ? a : n;
    return l + (l.includes("?") ? "" : i) + s
}
const M1 = dn({
    name: "nuxt:router",
    enforce: "pre",
    async setup(e) {
        var p, w;
        let t, n, r = Cr().app.baseURL;
        jt.hashMode && !r.includes("#") && (r += "#");
        const i = ((p = jt.history) == null ? void 0 : p.call(jt, r)) ?? (jt.hashMode ? zT(r) : Dv(r))
            , s = ((w = jt.routes) == null ? void 0 : w.call(jt, op)) ?? op;
        let o;
        const a = I1(r, window.location, e.payload.path)
            , l = x1({
            ...jt,
            scrollBehavior: (m,g,b)=>{
                var v;
                if (g === On) {
                    o = b;
                    return
                }
                return l.options.scrollBehavior = jt.scrollBehavior,
                    (v = jt.scrollBehavior) == null ? void 0 : v.call(jt, m, On, o || b)
            }
            ,
            history: i,
            routes: s
        });
        e.vueApp.use(l);
        const c = gr(l.currentRoute.value);
        l.afterEach((m,g)=>{
                c.value = g
            }
        ),
            Object.defineProperty(e.vueApp.config.globalProperties, "previousRoute", {
                get: ()=>c.value
            });
        const u = gr(l.resolve(a))
            , f = ()=>{
                u.value = l.currentRoute.value
            }
        ;
        e.hook("page:finish", f),
            l.afterEach((m,g)=>{
                    var b, v, S, _;
                    ((v = (b = m.matched[0]) == null ? void 0 : b.components) == null ? void 0 : v.default) === ((_ = (S = g.matched[0]) == null ? void 0 : S.components) == null ? void 0 : _.default) && f()
                }
            );
        const d = {};
        for (const m in u.value)
            Object.defineProperty(d, m, {
                get: ()=>u.value[m]
            });
        e._route = Ui(d),
            e._middleware = e._middleware || {
                global: [],
                named: {}
            };
        const h = qa();
        try {
            [t,n] = jr(()=>l.isReady()),
                await t,
                n()
        } catch (m) {
            [t,n] = jr(()=>e.runWithContext(()=>yi(m))),
                await t,
                n()
        }
        const y = sf("_layout");
        return l.beforeEach(async(m,g)=>{
                var b;
                m.meta = nn(m.meta),
                e.isHydrating && y.value && !mr(m.meta.layout) && (m.meta.layout = y.value),
                    e._processingMiddleware = !0;
                {
                    const v = new Set([...A1, ...e._middleware.global]);
                    for (const S of m.matched) {
                        const _ = S.meta.middleware;
                        if (_)
                            if (Array.isArray(_))
                                for (const E of _)
                                    v.add(E);
                            else
                                v.add(_)
                    }
                    for (const S of v) {
                        const _ = typeof S == "string" ? e._middleware.named[S] || await ((b = _s[S]) == null ? void 0 : b.call(_s).then(T=>T.default || T)) : S;
                        if (!_)
                            throw new Error(`Unknown route middleware: '${S}'.`);
                        const E = await e.runWithContext(()=>_(m, g));
                        if (!e.payload.serverRendered && e.isHydrating && (E === !1 || E instanceof Error)) {
                            const T = E || Tc({
                                statusCode: 404,
                                statusMessage: `Page Not Found: ${a}`
                            });
                            return await e.runWithContext(()=>yi(T)),
                                !1
                        }
                        if (E || E === !1)
                            return E
                    }
                }
            }
        ),
            l.onError(()=>{
                    delete e._processingMiddleware
                }
            ),
            l.afterEach(async(m,g,b)=>{
                    delete e._processingMiddleware,
                    !e.isHydrating && h.value && await e.runWithContext(Av),
                    m.matched.length === 0 && await e.runWithContext(()=>yi(Tc({
                        statusCode: 404,
                        fatal: !1,
                        statusMessage: `Page not found: ${m.fullPath}`
                    })))
                }
            ),
            e.hooks.hookOnce("app:created", async()=>{
                    try {
                        await l.replace({
                            ...l.resolve(a),
                            name: void 0,
                            force: !0
                        }),
                            l.options.scrollBehavior = jt.scrollBehavior
                    } catch (m) {
                        await e.runWithContext(()=>yi(m))
                    }
                }
            ),
            {
                provide: {
                    router: l
                }
            }
    }
})
    , D1 = dn({
    name: "nuxt:global-Components"
})
    , N1 = dn({
    name: "nuxt:head",
    setup(e) {
        const n = tT();
        n.push(rT),
            e.vueApp.use(n);
        {
            let r = !0;
            const i = ()=>{
                    r = !1,
                        n.hooks.callHook("entries:updated", n)
                }
            ;
            n.hooks.hook("dom:beforeRender", s=>{
                    s.shouldRender = !r
                }
            ),
                e.hooks.hook("page:start", ()=>{
                        r = !0
                    }
                ),
                e.hooks.hook("page:finish", i),
                e.hooks.hook("app:suspense:resolve", i)
        }
    }
})
    , Mr = {
    default: ()=>at(()=>import("./default.e8969530.js"), [], import.meta.url).then(e=>e.default || e)
}
    , $1 = dn({
    name: "nuxt:prefetch",
    setup(e) {
        const t = Jr();
        e.hooks.hook("app:mounted", ()=>{
                t.beforeEach(async n=>{
                        var i;
                        const r = (i = n == null ? void 0 : n.meta) == null ? void 0 : i.layout;
                        r && typeof Mr[r] == "function" && await Mr[r]()
                    }
                )
            }
        ),
            e.hooks.hook("link:prefetch", n=>{
                    var o, a, l, c;
                    if (Qs(n))
                        return;
                    const r = t.resolve(n);
                    if (!r)
                        return;
                    const i = (o = r == null ? void 0 : r.meta) == null ? void 0 : o.layout;
                    let s = Array.isArray((a = r == null ? void 0 : r.meta) == null ? void 0 : a.middleware) ? (l = r == null ? void 0 : r.meta) == null ? void 0 : l.middleware : [(c = r == null ? void 0 : r.meta) == null ? void 0 : c.middleware];
                    s = s.filter(u=>typeof u == "string");
                    for (const u of s)
                        typeof _s[u] == "function" && _s[u]();
                    i && typeof Mr[i] == "function" && Mr[i]()
                }
            )
    }
})
    , F1 = {
    ignoreUnknown: !1,
    respectType: !1,
    respectFunctionNames: !1,
    respectFunctionProperties: !1,
    unorderedObjects: !0,
    unorderedArrays: !1,
    unorderedSets: !1
};
function lp(e, t={}) {
    t = {
        ...F1,
        ...t
    };
    const n = Gv(t);
    return n.dispatch(e),
        n.toString()
}
function Gv(e) {
    const t = [];
    let n = [];
    const r = i=>{
            t.push(i)
        }
    ;
    return {
        toString() {
            return t.join("")
        },
        getContext() {
            return n
        },
        dispatch(i) {
            return e.replacer && (i = e.replacer(i)),
                this["_" + (i === null ? "null" : typeof i)](i)
        },
        _object(i) {
            if (i && typeof i.toJSON == "function")
                return this._object(i.toJSON());
            const s = /\[object (.*)]/i
                , o = Object.prototype.toString.call(i)
                , a = s.exec(o)
                , l = a ? a[1].toLowerCase() : "unknown:[" + o.toLowerCase() + "]";
            let c = null;
            if ((c = n.indexOf(i)) >= 0)
                return this.dispatch("[CIRCULAR:" + c + "]");
            if (n.push(i),
            typeof Buffer < "u" && Buffer.isBuffer && Buffer.isBuffer(i))
                return r("buffer:"),
                    r(i.toString("utf8"));
            if (l !== "object" && l !== "function" && l !== "asyncfunction")
                this["_" + l] ? this["_" + l](i) : e.ignoreUnknown || this._unkown(i, l);
            else {
                let u = Object.keys(i);
                e.unorderedObjects && (u = u.sort()),
                e.respectType !== !1 && !cp(i) && u.splice(0, 0, "prototype", "__proto__", "letructor"),
                e.excludeKeys && (u = u.filter(function(f) {
                    return !e.excludeKeys(f)
                })),
                    r("object:" + u.length + ":");
                for (const f of u)
                    this.dispatch(f),
                        r(":"),
                    e.excludeValues || this.dispatch(i[f]),
                        r(",")
            }
        },
        _array(i, s) {
            if (s = typeof s < "u" ? s : e.unorderedArrays !== !1,
                r("array:" + i.length + ":"),
            !s || i.length <= 1) {
                for (const l of i)
                    this.dispatch(l);
                return
            }
            const o = []
                , a = i.map(l=>{
                    const c = Gv(e);
                    return c.dispatch(l),
                        o.push(c.getContext()),
                        c.toString()
                }
            );
            return n = [...n, ...o],
                a.sort(),
                this._array(a, !1)
        },
        _date(i) {
            return r("date:" + i.toJSON())
        },
        _symbol(i) {
            return r("symbol:" + i.toString())
        },
        _unkown(i, s) {
            if (r(s),
            !!i && (r(":"),
            i && typeof i.entries == "function"))
                return this._array(Array.from(i.entries()), !0)
        },
        _error(i) {
            return r("error:" + i.toString())
        },
        _boolean(i) {
            return r("bool:" + i.toString())
        },
        _string(i) {
            r("string:" + i.length + ":"),
                r(i.toString())
        },
        _function(i) {
            r("fn:"),
                cp(i) ? this.dispatch("[native]") : this.dispatch(i.toString()),
            e.respectFunctionNames !== !1 && this.dispatch("function-name:" + String(i.name)),
            e.respectFunctionProperties && this._object(i)
        },
        _number(i) {
            return r("number:" + i.toString())
        },
        _xml(i) {
            return r("xml:" + i.toString())
        },
        _null() {
            return r("Null")
        },
        _undefined() {
            return r("Undefined")
        },
        _regexp(i) {
            return r("regex:" + i.toString())
        },
        _uint8array(i) {
            return r("uint8array:"),
                this.dispatch(Array.prototype.slice.call(i))
        },
        _uint8clampedarray(i) {
            return r("uint8clampedarray:"),
                this.dispatch(Array.prototype.slice.call(i))
        },
        _int8array(i) {
            return r("int8array:"),
                this.dispatch(Array.prototype.slice.call(i))
        },
        _uint16array(i) {
            return r("uint16array:"),
                this.dispatch(Array.prototype.slice.call(i))
        },
        _int16array(i) {
            return r("int16array:"),
                this.dispatch(Array.prototype.slice.call(i))
        },
        _uint32array(i) {
            return r("uint32array:"),
                this.dispatch(Array.prototype.slice.call(i))
        },
        _int32array(i) {
            return r("int32array:"),
                this.dispatch(Array.prototype.slice.call(i))
        },
        _float32array(i) {
            return r("float32array:"),
                this.dispatch(Array.prototype.slice.call(i))
        },
        _float64array(i) {
            return r("float64array:"),
                this.dispatch(Array.prototype.slice.call(i))
        },
        _arraybuffer(i) {
            return r("arraybuffer:"),
                this.dispatch(new Uint8Array(i))
        },
        _url(i) {
            return r("url:" + i.toString())
        },
        _map(i) {
            r("map:");
            const s = [...i];
            return this._array(s, e.unorderedSets !== !1)
        },
        _set(i) {
            r("set:");
            const s = [...i];
            return this._array(s, e.unorderedSets !== !1)
        },
        _file(i) {
            return r("file:"),
                this.dispatch([i.name, i.size, i.type, i.lastModfied])
        },
        _blob() {
            if (e.ignoreUnknown)
                return r("[blob]");
            throw new Error(`Hashing Blob objects is currently not supported
Use "options.replacer" or "options.ignoreUnknown"
`)
        },
        _domwindow() {
            return r("domwindow")
        },
        _bigint(i) {
            return r("bigint:" + i.toString())
        },
        _process() {
            return r("process")
        },
        _timer() {
            return r("timer")
        },
        _pipe() {
            return r("pipe")
        },
        _tcp() {
            return r("tcp")
        },
        _udp() {
            return r("udp")
        },
        _tty() {
            return r("tty")
        },
        _statwatcher() {
            return r("statwatcher")
        },
        _securecontext() {
            return r("securecontext")
        },
        _connection() {
            return r("connection")
        },
        _zlib() {
            return r("zlib")
        },
        _context() {
            return r("context")
        },
        _nodescript() {
            return r("nodescript")
        },
        _httpparser() {
            return r("httpparser")
        },
        _dataview() {
            return r("dataview")
        },
        _signal() {
            return r("signal")
        },
        _fsevent() {
            return r("fsevent")
        },
        _tlswrap() {
            return r("tlswrap")
        }
    }
}
function cp(e) {
    return typeof e != "function" ? !1 : /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code]\s+}$/i.exec(Function.prototype.toString.call(e)) != null
}
function j1(e, t, n={}) {
    return e === t || lp(e, n) === lp(t, n)
}
const H1 = {
    path: "/",
    watch: !0,
    decode: e=>cv(decodeURIComponent(e)),
    encode: e=>encodeURIComponent(typeof e == "string" ? e : JSON.stringify(e))
};
function fa(e, t) {
    var s;
    const n = {
        ...H1,
        ...t
    }
        , r = B1(n) || {}
        , i = X(r[e] ?? ((s = n.default) == null ? void 0 : s.call(n)));
    {
        const o = typeof BroadcastChannel > "u" ? null : new BroadcastChannel(`nuxt:cookies:${e}`);
        Ot() && Kt(()=>{
                o == null || o.close()
            }
        );
        const a = ()=>{
                z1(e, i.value, n),
                o == null || o.postMessage(ke(i.value))
            }
        ;
        let l = !1;
        o && (o.onmessage = c=>{
                l = !0,
                    i.value = c.data,
                    ct(()=>{
                            l = !1
                        }
                    )
            }
        ),
            n.watch ? Se(i, (c,u)=>{
                    l || j1(c, u) || a()
                }
                , {
                    deep: n.watch !== "shallow"
                }) : a()
    }
    return i
}
function B1(e={}) {
    return fT(document.cookie, e)
}
function V1(e, t, n={}) {
    return t == null ? Vd(e, t, {
        ...n,
        maxAge: -1
    }) : Vd(e, t, n)
}
function z1(e, t, n={}) {
    document.cookie = V1(e, t, n)
}
function U1(e={}) {
    const t = e.path || window.location.pathname;
    let n = {};
    try {
        n = JSON.parse(sessionStorage.getItem("nuxt:reload") || "{}")
    } catch {}
    if (e.force || (n == null ? void 0 : n.path) !== t || (n == null ? void 0 : n.expires) < Date.now()) {
        try {
            sessionStorage.setItem("nuxt:reload", JSON.stringify({
                path: t,
                expires: Date.now() + (e.ttl ?? 1e4)
            }))
        } catch {}
        if (e.persistState)
            try {
                sessionStorage.setItem("nuxt:reload:state", JSON.stringify({
                    state: pt().payload.state
                }))
            } catch {}
        window.location.pathname !== t ? window.location.href = t : window.location.reload()
    }
}
const W1 = dn(()=>{}
);
/*!
  * shared v9.3.0-beta.24
  * (c) 2023 kazuya kawaguchi
  * Released under the MIT License.
  */
const Lc = typeof window < "u"
    , Zr = (e,t=!1)=>t ? Symbol.for(e) : Symbol(e)
    , G1 = (e,t,n)=>X1({
    l: e,
    k: t,
    s: n
})
    , X1 = e=>JSON.stringify(e).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027")
    , wt = e=>typeof e == "number" && isFinite(e)
    , K1 = e=>Kv(e) === "[object Date]"
    , da = e=>Kv(e) === "[object RegExp]"
    , Qa = e=>je(e) && Object.keys(e).length === 0;
function Y1(e, t) {
    typeof console < "u" && (console.warn("[intlify] " + e),
    t && console.warn(t.stack))
}
const Et = Object.assign;
let up;
const ff = ()=>up || (up = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function fp(e) {
    return e.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;")
}
const q1 = Object.prototype.hasOwnProperty;
function df(e, t) {
    return q1.call(e, t)
}
const st = Array.isArray
    , ut = e=>typeof e == "function"
    , ve = e=>typeof e == "string"
    , it = e=>typeof e == "boolean"
    , Be = e=>e !== null && typeof e == "object"
    , Xv = Object.prototype.toString
    , Kv = e=>Xv.call(e)
    , je = e=>{
    if (!Be(e))
        return !1;
    const t = Object.getPrototypeOf(e);
    return t === null || t.constructor === Object
}
    , J1 = e=>e == null ? "" : st(e) || je(e) && e.toString === Xv ? JSON.stringify(e, null, 2) : String(e);
function pf(e, t="") {
    return e.reduce((n,r,i)=>i === 0 ? n + r : n + t + r, "")
}
/*!
  * message-compiler v9.3.0-beta.24
  * (c) 2023 kazuya kawaguchi
  * Released under the MIT License.
  */
function Z1(e, t, n) {
    return {
        line: e,
        column: t,
        offset: n
    }
}
function Oc(e, t, n) {
    const r = {
        start: e,
        end: t
    };
    return n != null && (r.source = n),
        r
}
const We = {
    EXPECTED_TOKEN: 1,
    INVALID_TOKEN_IN_PLACEHOLDER: 2,
    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
    UNKNOWN_ESCAPE_SEQUENCE: 4,
    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
    UNBALANCED_CLOSING_BRACE: 6,
    UNTERMINATED_CLOSING_BRACE: 7,
    EMPTY_PLACEHOLDER: 8,
    NOT_ALLOW_NEST_PLACEHOLDER: 9,
    INVALID_LINKED_FORMAT: 10,
    MUST_HAVE_MESSAGES_IN_PLURAL: 11,
    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
    UNEXPECTED_EMPTY_LINKED_KEY: 13,
    UNEXPECTED_LEXICAL_ANALYSIS: 14,
    __EXTEND_POINT__: 15
};
function el(e, t, n={}) {
    const {domain: r, messages: i, args: s} = n
        , o = e
        , a = new SyntaxError(String(o));
    return a.code = e,
    t && (a.location = t),
        a.domain = r,
        a
}
function Q1(e) {
    throw e
}
const Hn = " "
    , ex = "\r"
    , Dt = `
`
    , tx = String.fromCharCode(8232)
    , nx = String.fromCharCode(8233);
function rx(e) {
    const t = e;
    let n = 0
        , r = 1
        , i = 1
        , s = 0;
    const o = E=>t[E] === ex && t[E + 1] === Dt
        , a = E=>t[E] === Dt
        , l = E=>t[E] === nx
        , c = E=>t[E] === tx
        , u = E=>o(E) || a(E) || l(E) || c(E)
        , f = ()=>n
        , d = ()=>r
        , h = ()=>i
        , y = ()=>s
        , p = E=>o(E) || l(E) || c(E) ? Dt : t[E]
        , w = ()=>p(n)
        , m = ()=>p(n + s);
    function g() {
        return s = 0,
        u(n) && (r++,
            i = 0),
        o(n) && n++,
            n++,
            i++,
            t[n]
    }
    function b() {
        return o(n + s) && s++,
            s++,
            t[n + s]
    }
    function v() {
        n = 0,
            r = 1,
            i = 1,
            s = 0
    }
    function S(E=0) {
        s = E
    }
    function _() {
        const E = n + s;
        for (; E !== n; )
            g();
        s = 0
    }
    return {
        index: f,
        line: d,
        column: h,
        peekOffset: y,
        charAt: p,
        currentChar: w,
        currentPeek: m,
        next: g,
        peek: b,
        reset: v,
        resetPeek: S,
        skipToPeek: _
    }
}
const ir = void 0
    , dp = "'"
    , ix = "tokenizer";
function sx(e, t={}) {
    const n = t.location !== !1
        , r = rx(e)
        , i = ()=>r.index()
        , s = ()=>Z1(r.line(), r.column(), r.index())
        , o = s()
        , a = i()
        , l = {
        currentType: 14,
        offset: a,
        startLoc: o,
        endLoc: o,
        lastType: 14,
        lastOffset: a,
        lastStartLoc: o,
        lastEndLoc: o,
        braceNest: 0,
        inLinked: !1,
        text: ""
    }
        , c = ()=>l
        , {onError: u} = t;
    function f(C, R, F, ...V) {
        const Y = c();
        if (R.column += F,
            R.offset += F,
            u) {
            const re = n ? Oc(Y.startLoc, R) : null
                , ie = el(C, re, {
                domain: ix,
                args: V
            });
            u(ie)
        }
    }
    function d(C, R, F) {
        C.endLoc = s(),
            C.currentType = R;
        const V = {
            type: R
        };
        return n && (V.loc = Oc(C.startLoc, C.endLoc)),
        F != null && (V.value = F),
            V
    }
    const h = C=>d(C, 14);
    function y(C, R) {
        return C.currentChar() === R ? (C.next(),
            R) : (f(We.EXPECTED_TOKEN, s(), 0, R),
            "")
    }
    function p(C) {
        let R = "";
        for (; C.currentPeek() === Hn || C.currentPeek() === Dt; )
            R += C.currentPeek(),
                C.peek();
        return R
    }
    function w(C) {
        const R = p(C);
        return C.skipToPeek(),
            R
    }
    function m(C) {
        if (C === ir)
            return !1;
        const R = C.charCodeAt(0);
        return R >= 97 && R <= 122 || R >= 65 && R <= 90 || R === 95
    }
    function g(C) {
        if (C === ir)
            return !1;
        const R = C.charCodeAt(0);
        return R >= 48 && R <= 57
    }
    function b(C, R) {
        const {currentType: F} = R;
        if (F !== 2)
            return !1;
        p(C);
        const V = m(C.currentPeek());
        return C.resetPeek(),
            V
    }
    function v(C, R) {
        const {currentType: F} = R;
        if (F !== 2)
            return !1;
        p(C);
        const V = C.currentPeek() === "-" ? C.peek() : C.currentPeek()
            , Y = g(V);
        return C.resetPeek(),
            Y
    }
    function S(C, R) {
        const {currentType: F} = R;
        if (F !== 2)
            return !1;
        p(C);
        const V = C.currentPeek() === dp;
        return C.resetPeek(),
            V
    }
    function _(C, R) {
        const {currentType: F} = R;
        if (F !== 8)
            return !1;
        p(C);
        const V = C.currentPeek() === ".";
        return C.resetPeek(),
            V
    }
    function E(C, R) {
        const {currentType: F} = R;
        if (F !== 9)
            return !1;
        p(C);
        const V = m(C.currentPeek());
        return C.resetPeek(),
            V
    }
    function T(C, R) {
        const {currentType: F} = R;
        if (!(F === 8 || F === 12))
            return !1;
        p(C);
        const V = C.currentPeek() === ":";
        return C.resetPeek(),
            V
    }
    function P(C, R) {
        const {currentType: F} = R;
        if (F !== 10)
            return !1;
        const V = ()=>{
            const re = C.currentPeek();
            return re === "{" ? m(C.peek()) : re === "@" || re === "%" || re === "|" || re === ":" || re === "." || re === Hn || !re ? !1 : re === Dt ? (C.peek(),
                V()) : m(re)
        }
            , Y = V();
        return C.resetPeek(),
            Y
    }
    function I(C) {
        p(C);
        const R = C.currentPeek() === "|";
        return C.resetPeek(),
            R
    }
    function L(C) {
        const R = p(C)
            , F = C.currentPeek() === "%" && C.peek() === "{";
        return C.resetPeek(),
            {
                isModulo: F,
                hasSpace: R.length > 0
            }
    }
    function x(C, R=!0) {
        const F = (Y=!1,re="",ie=!1)=>{
            const ae = C.currentPeek();
            return ae === "{" ? re === "%" ? !1 : Y : ae === "@" || !ae ? re === "%" ? !0 : Y : ae === "%" ? (C.peek(),
                F(Y, "%", !0)) : ae === "|" ? re === "%" || ie ? !0 : !(re === Hn || re === Dt) : ae === Hn ? (C.peek(),
                F(!0, Hn, ie)) : ae === Dt ? (C.peek(),
                F(!0, Dt, ie)) : !0
        }
            , V = F();
        return R && C.resetPeek(),
            V
    }
    function A(C, R) {
        const F = C.currentChar();
        return F === ir ? ir : R(F) ? (C.next(),
            F) : null
    }
    function k(C) {
        return A(C, F=>{
                const V = F.charCodeAt(0);
                return V >= 97 && V <= 122 || V >= 65 && V <= 90 || V >= 48 && V <= 57 || V === 95 || V === 36
            }
        )
    }
    function O(C) {
        return A(C, F=>{
                const V = F.charCodeAt(0);
                return V >= 48 && V <= 57
            }
        )
    }
    function N(C) {
        return A(C, F=>{
                const V = F.charCodeAt(0);
                return V >= 48 && V <= 57 || V >= 65 && V <= 70 || V >= 97 && V <= 102
            }
        )
    }
    function D(C) {
        let R = ""
            , F = "";
        for (; R = O(C); )
            F += R;
        return F
    }
    function W(C) {
        w(C);
        const R = C.currentChar();
        return R !== "%" && f(We.EXPECTED_TOKEN, s(), 0, R),
            C.next(),
            "%"
    }
    function G(C) {
        let R = "";
        for (; ; ) {
            const F = C.currentChar();
            if (F === "{" || F === "}" || F === "@" || F === "|" || !F)
                break;
            if (F === "%")
                if (x(C))
                    R += F,
                        C.next();
                else
                    break;
            else if (F === Hn || F === Dt)
                if (x(C))
                    R += F,
                        C.next();
                else {
                    if (I(C))
                        break;
                    R += F,
                        C.next()
                }
            else
                R += F,
                    C.next()
        }
        return R
    }
    function le(C) {
        w(C);
        let R = ""
            , F = "";
        for (; R = k(C); )
            F += R;
        return C.currentChar() === ir && f(We.UNTERMINATED_CLOSING_BRACE, s(), 0),
            F
    }
    function ge(C) {
        w(C);
        let R = "";
        return C.currentChar() === "-" ? (C.next(),
            R += `-${D(C)}`) : R += D(C),
        C.currentChar() === ir && f(We.UNTERMINATED_CLOSING_BRACE, s(), 0),
            R
    }
    function ye(C) {
        w(C),
            y(C, "'");
        let R = ""
            , F = "";
        const V = re=>re !== dp && re !== Dt;
        for (; R = A(C, V); )
            R === "\\" ? F += de(C) : F += R;
        const Y = C.currentChar();
        return Y === Dt || Y === ir ? (f(We.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, s(), 0),
        Y === Dt && (C.next(),
            y(C, "'")),
            F) : (y(C, "'"),
            F)
    }
    function de(C) {
        const R = C.currentChar();
        switch (R) {
            case "\\":
            case "'":
                return C.next(),
                    `\\${R}`;
            case "u":
                return z(C, R, 4);
            case "U":
                return z(C, R, 6);
            default:
                return f(We.UNKNOWN_ESCAPE_SEQUENCE, s(), 0, R),
                    ""
        }
    }
    function z(C, R, F) {
        y(C, R);
        let V = "";
        for (let Y = 0; Y < F; Y++) {
            const re = N(C);
            if (!re) {
                f(We.INVALID_UNICODE_ESCAPE_SEQUENCE, s(), 0, `\\${R}${V}${C.currentChar()}`);
                break
            }
            V += re
        }
        return `\\${R}${V}`
    }
    function Pe(C) {
        w(C);
        let R = ""
            , F = "";
        const V = Y=>Y !== "{" && Y !== "}" && Y !== Hn && Y !== Dt;
        for (; R = A(C, V); )
            F += R;
        return F
    }
    function _e(C) {
        let R = ""
            , F = "";
        for (; R = k(C); )
            F += R;
        return F
    }
    function J(C) {
        const R = (F=!1,V)=>{
                const Y = C.currentChar();
                return Y === "{" || Y === "%" || Y === "@" || Y === "|" || !Y || Y === Hn ? V : Y === Dt ? (V += Y,
                    C.next(),
                    R(F, V)) : (V += Y,
                    C.next(),
                    R(!0, V))
            }
        ;
        return R(!1, "")
    }
    function ne(C) {
        w(C);
        const R = y(C, "|");
        return w(C),
            R
    }
    function ee(C, R) {
        let F = null;
        switch (C.currentChar()) {
            case "{":
                return R.braceNest >= 1 && f(We.NOT_ALLOW_NEST_PLACEHOLDER, s(), 0),
                    C.next(),
                    F = d(R, 2, "{"),
                    w(C),
                    R.braceNest++,
                    F;
            case "}":
                return R.braceNest > 0 && R.currentType === 2 && f(We.EMPTY_PLACEHOLDER, s(), 0),
                    C.next(),
                    F = d(R, 3, "}"),
                    R.braceNest--,
                R.braceNest > 0 && w(C),
                R.inLinked && R.braceNest === 0 && (R.inLinked = !1),
                    F;
            case "@":
                return R.braceNest > 0 && f(We.UNTERMINATED_CLOSING_BRACE, s(), 0),
                    F = ce(C, R) || h(R),
                    R.braceNest = 0,
                    F;
            default:
                let Y = !0
                    , re = !0
                    , ie = !0;
                if (I(C))
                    return R.braceNest > 0 && f(We.UNTERMINATED_CLOSING_BRACE, s(), 0),
                        F = d(R, 1, ne(C)),
                        R.braceNest = 0,
                        R.inLinked = !1,
                        F;
                if (R.braceNest > 0 && (R.currentType === 5 || R.currentType === 6 || R.currentType === 7))
                    return f(We.UNTERMINATED_CLOSING_BRACE, s(), 0),
                        R.braceNest = 0,
                        Ce(C, R);
                if (Y = b(C, R))
                    return F = d(R, 5, le(C)),
                        w(C),
                        F;
                if (re = v(C, R))
                    return F = d(R, 6, ge(C)),
                        w(C),
                        F;
                if (ie = S(C, R))
                    return F = d(R, 7, ye(C)),
                        w(C),
                        F;
                if (!Y && !re && !ie)
                    return F = d(R, 13, Pe(C)),
                        f(We.INVALID_TOKEN_IN_PLACEHOLDER, s(), 0, F.value),
                        w(C),
                        F;
                break
        }
        return F
    }
    function ce(C, R) {
        const {currentType: F} = R;
        let V = null;
        const Y = C.currentChar();
        switch ((F === 8 || F === 9 || F === 12 || F === 10) && (Y === Dt || Y === Hn) && f(We.INVALID_LINKED_FORMAT, s(), 0),
            Y) {
            case "@":
                return C.next(),
                    V = d(R, 8, "@"),
                    R.inLinked = !0,
                    V;
            case ".":
                return w(C),
                    C.next(),
                    d(R, 9, ".");
            case ":":
                return w(C),
                    C.next(),
                    d(R, 10, ":");
            default:
                return I(C) ? (V = d(R, 1, ne(C)),
                    R.braceNest = 0,
                    R.inLinked = !1,
                    V) : _(C, R) || T(C, R) ? (w(C),
                    ce(C, R)) : E(C, R) ? (w(C),
                    d(R, 12, _e(C))) : P(C, R) ? (w(C),
                    Y === "{" ? ee(C, R) || V : d(R, 11, J(C))) : (F === 8 && f(We.INVALID_LINKED_FORMAT, s(), 0),
                    R.braceNest = 0,
                    R.inLinked = !1,
                    Ce(C, R))
        }
    }
    function Ce(C, R) {
        let F = {
            type: 14
        };
        if (R.braceNest > 0)
            return ee(C, R) || h(R);
        if (R.inLinked)
            return ce(C, R) || h(R);
        switch (C.currentChar()) {
            case "{":
                return ee(C, R) || h(R);
            case "}":
                return f(We.UNBALANCED_CLOSING_BRACE, s(), 0),
                    C.next(),
                    d(R, 3, "}");
            case "@":
                return ce(C, R) || h(R);
            default:
                if (I(C))
                    return F = d(R, 1, ne(C)),
                        R.braceNest = 0,
                        R.inLinked = !1,
                        F;
                const {isModulo: Y, hasSpace: re} = L(C);
                if (Y)
                    return re ? d(R, 0, G(C)) : d(R, 4, W(C));
                if (x(C))
                    return d(R, 0, G(C));
                break
        }
        return F
    }
    function M() {
        const {currentType: C, offset: R, startLoc: F, endLoc: V} = l;
        return l.lastType = C,
            l.lastOffset = R,
            l.lastStartLoc = F,
            l.lastEndLoc = V,
            l.offset = i(),
            l.startLoc = s(),
            r.currentChar() === ir ? d(l, 14) : Ce(r, l)
    }
    return {
        nextToken: M,
        currentOffset: i,
        currentPosition: s,
        context: c
    }
}
const ox = "parser"
    , ax = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function lx(e, t, n) {
    switch (e) {
        case "\\\\":
            return "\\";
        case "\\'":
            return "'";
        default:
        {
            const r = parseInt(t || n, 16);
            return r <= 55295 || r >= 57344 ? String.fromCodePoint(r) : "�"
        }
    }
}
function cx(e={}) {
    const t = e.location !== !1
        , {onError: n} = e;
    function r(m, g, b, v, ...S) {
        const _ = m.currentPosition();
        if (_.offset += v,
            _.column += v,
            n) {
            const E = t ? Oc(b, _) : null
                , T = el(g, E, {
                domain: ox,
                args: S
            });
            n(T)
        }
    }
    function i(m, g, b) {
        const v = {
            type: m
        };
        return t && (v.start = g,
            v.end = g,
            v.loc = {
                start: b,
                end: b
            }),
            v
    }
    function s(m, g, b, v) {
        v && (m.type = v),
        t && (m.end = g,
        m.loc && (m.loc.end = b))
    }
    function o(m, g) {
        const b = m.context()
            , v = i(3, b.offset, b.startLoc);
        return v.value = g,
            s(v, m.currentOffset(), m.currentPosition()),
            v
    }
    function a(m, g) {
        const b = m.context()
            , {lastOffset: v, lastStartLoc: S} = b
            , _ = i(5, v, S);
        return _.index = parseInt(g, 10),
            m.nextToken(),
            s(_, m.currentOffset(), m.currentPosition()),
            _
    }
    function l(m, g) {
        const b = m.context()
            , {lastOffset: v, lastStartLoc: S} = b
            , _ = i(4, v, S);
        return _.key = g,
            m.nextToken(),
            s(_, m.currentOffset(), m.currentPosition()),
            _
    }
    function c(m, g) {
        const b = m.context()
            , {lastOffset: v, lastStartLoc: S} = b
            , _ = i(9, v, S);
        return _.value = g.replace(ax, lx),
            m.nextToken(),
            s(_, m.currentOffset(), m.currentPosition()),
            _
    }
    function u(m) {
        const g = m.nextToken()
            , b = m.context()
            , {lastOffset: v, lastStartLoc: S} = b
            , _ = i(8, v, S);
        return g.type !== 12 ? (r(m, We.UNEXPECTED_EMPTY_LINKED_MODIFIER, b.lastStartLoc, 0),
            _.value = "",
            s(_, v, S),
            {
                nextConsumeToken: g,
                node: _
            }) : (g.value == null && r(m, We.UNEXPECTED_LEXICAL_ANALYSIS, b.lastStartLoc, 0, Ln(g)),
            _.value = g.value || "",
            s(_, m.currentOffset(), m.currentPosition()),
            {
                node: _
            })
    }
    function f(m, g) {
        const b = m.context()
            , v = i(7, b.offset, b.startLoc);
        return v.value = g,
            s(v, m.currentOffset(), m.currentPosition()),
            v
    }
    function d(m) {
        const g = m.context()
            , b = i(6, g.offset, g.startLoc);
        let v = m.nextToken();
        if (v.type === 9) {
            const S = u(m);
            b.modifier = S.node,
                v = S.nextConsumeToken || m.nextToken()
        }
        switch (v.type !== 10 && r(m, We.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, Ln(v)),
            v = m.nextToken(),
        v.type === 2 && (v = m.nextToken()),
            v.type) {
            case 11:
                v.value == null && r(m, We.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, Ln(v)),
                    b.key = f(m, v.value || "");
                break;
            case 5:
                v.value == null && r(m, We.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, Ln(v)),
                    b.key = l(m, v.value || "");
                break;
            case 6:
                v.value == null && r(m, We.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, Ln(v)),
                    b.key = a(m, v.value || "");
                break;
            case 7:
                v.value == null && r(m, We.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, Ln(v)),
                    b.key = c(m, v.value || "");
                break;
            default:
                r(m, We.UNEXPECTED_EMPTY_LINKED_KEY, g.lastStartLoc, 0);
                const S = m.context()
                    , _ = i(7, S.offset, S.startLoc);
                return _.value = "",
                    s(_, S.offset, S.startLoc),
                    b.key = _,
                    s(b, S.offset, S.startLoc),
                    {
                        nextConsumeToken: v,
                        node: b
                    }
        }
        return s(b, m.currentOffset(), m.currentPosition()),
            {
                node: b
            }
    }
    function h(m) {
        const g = m.context()
            , b = g.currentType === 1 ? m.currentOffset() : g.offset
            , v = g.currentType === 1 ? g.endLoc : g.startLoc
            , S = i(2, b, v);
        S.items = [];
        let _ = null;
        do {
            const P = _ || m.nextToken();
            switch (_ = null,
                P.type) {
                case 0:
                    P.value == null && r(m, We.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, Ln(P)),
                        S.items.push(o(m, P.value || ""));
                    break;
                case 6:
                    P.value == null && r(m, We.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, Ln(P)),
                        S.items.push(a(m, P.value || ""));
                    break;
                case 5:
                    P.value == null && r(m, We.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, Ln(P)),
                        S.items.push(l(m, P.value || ""));
                    break;
                case 7:
                    P.value == null && r(m, We.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, Ln(P)),
                        S.items.push(c(m, P.value || ""));
                    break;
                case 8:
                    const I = d(m);
                    S.items.push(I.node),
                        _ = I.nextConsumeToken || null;
                    break
            }
        } while (g.currentType !== 14 && g.currentType !== 1);
        const E = g.currentType === 1 ? g.lastOffset : m.currentOffset()
            , T = g.currentType === 1 ? g.lastEndLoc : m.currentPosition();
        return s(S, E, T),
            S
    }
    function y(m, g, b, v) {
        const S = m.context();
        let _ = v.items.length === 0;
        const E = i(1, g, b);
        E.cases = [],
            E.cases.push(v);
        do {
            const T = h(m);
            _ || (_ = T.items.length === 0),
                E.cases.push(T)
        } while (S.currentType !== 14);
        return _ && r(m, We.MUST_HAVE_MESSAGES_IN_PLURAL, b, 0),
            s(E, m.currentOffset(), m.currentPosition()),
            E
    }
    function p(m) {
        const g = m.context()
            , {offset: b, startLoc: v} = g
            , S = h(m);
        return g.currentType === 14 ? S : y(m, b, v, S)
    }
    function w(m) {
        const g = sx(m, Et({}, e))
            , b = g.context()
            , v = i(0, b.offset, b.startLoc);
        return t && v.loc && (v.loc.source = m),
            v.body = p(g),
        e.onCacheKey && (v.cacheKey = e.onCacheKey(m)),
        b.currentType !== 14 && r(g, We.UNEXPECTED_LEXICAL_ANALYSIS, b.lastStartLoc, 0, m[b.offset] || ""),
            s(v, g.currentOffset(), g.currentPosition()),
            v
    }
    return {
        parse: w
    }
}
function Ln(e) {
    if (e.type === 14)
        return "EOF";
    const t = (e.value || "").replace(/\r?\n/gu, "\\n");
    return t.length > 10 ? t.slice(0, 9) + "…" : t
}
function ux(e, t={}) {
    const n = {
        ast: e,
        helpers: new Set
    };
    return {
        context: ()=>n,
        helper: s=>(n.helpers.add(s),
            s)
    }
}
function pp(e, t) {
    for (let n = 0; n < e.length; n++)
        hf(e[n], t)
}
function hf(e, t) {
    switch (e.type) {
        case 1:
            pp(e.cases, t),
                t.helper("plural");
            break;
        case 2:
            pp(e.items, t);
            break;
        case 6:
            hf(e.key, t),
                t.helper("linked"),
                t.helper("type");
            break;
        case 5:
            t.helper("interpolate"),
                t.helper("list");
            break;
        case 4:
            t.helper("interpolate"),
                t.helper("named");
            break
    }
}
function fx(e, t={}) {
    const n = ux(e);
    n.helper("normalize"),
    e.body && hf(e.body, n);
    const r = n.context();
    e.helpers = Array.from(r.helpers)
}
function dx(e) {
    const t = e.body;
    return t.type === 2 ? hp(t) : t.cases.forEach(n=>hp(n)),
        e
}
function hp(e) {
    if (e.items.length === 1) {
        const t = e.items[0];
        (t.type === 3 || t.type === 9) && (e.static = t.value,
            delete t.value)
    } else {
        const t = [];
        for (let n = 0; n < e.items.length; n++) {
            const r = e.items[n];
            if (!(r.type === 3 || r.type === 9) || r.value == null)
                break;
            t.push(r.value)
        }
        if (t.length === e.items.length) {
            e.static = pf(t);
            for (let n = 0; n < e.items.length; n++) {
                const r = e.items[n];
                (r.type === 3 || r.type === 9) && delete r.value
            }
        }
    }
}
function px(e, t) {
    const {sourceMap: n, filename: r, breakLineCode: i, needIndent: s} = t
        , o = t.location !== !1
        , a = {
        filename: r,
        code: "",
        column: 1,
        line: 1,
        offset: 0,
        map: void 0,
        breakLineCode: i,
        needIndent: s,
        indentLevel: 0
    };
    o && e.loc && (a.source = e.loc.source);
    const l = ()=>a;
    function c(w, m) {
        a.code += w
    }
    function u(w, m=!0) {
        const g = m ? i : "";
        c(s ? g + "  ".repeat(w) : g)
    }
    function f(w=!0) {
        const m = ++a.indentLevel;
        w && u(m)
    }
    function d(w=!0) {
        const m = --a.indentLevel;
        w && u(m)
    }
    function h() {
        u(a.indentLevel)
    }
    return {
        context: l,
        push: c,
        indent: f,
        deindent: d,
        newline: h,
        helper: w=>`_ ${w}`,
        needIndent: ()=>a.needIndent
    }
}
function hx(e, t) {
    const {helper: n} = e;
    e.push(`${n("linked")}(`),
        Di(e, t.key),
        t.modifier ? (e.push(", "),
            Di(e, t.modifier),
            e.push(", _type")) : e.push(", undefined, _type"),
        e.push(")")
}
function mx(e, t) {
    const {helper: n, needIndent: r} = e;
    e.push(`${n("normalize")}([`),
        e.indent(r());
    const i = t.items.length;
    for (let s = 0; s < i && (Di(e, t.items[s]),
    s !== i - 1); s++)
        e.push(", ");
    e.deindent(r()),
        e.push("])")
}
function gx(e, t) {
    const {helper: n, needIndent: r} = e;
    if (t.cases.length > 1) {
        e.push(`${n("plural")}([`),
            e.indent(r());
        const i = t.cases.length;
        for (let s = 0; s < i && (Di(e, t.cases[s]),
        s !== i - 1); s++)
            e.push(", ");
        e.deindent(r()),
            e.push("])")
    }
}
function vx(e, t) {
    t.body ? Di(e, t.body) : e.push("null")
}
function Di(e, t) {
    const {helper: n} = e;
    switch (t.type) {
        case 0:
            vx(e, t);
            break;
        case 1:
            gx(e, t);
            break;
        case 2:
            mx(e, t);
            break;
        case 6:
            hx(e, t);
            break;
        case 8:
            e.push(JSON.stringify(t.value), t);
            break;
        case 7:
            e.push(JSON.stringify(t.value), t);
            break;
        case 5:
            e.push(`${n("interpolate")}(${n("list")}(${t.index}))`, t);
            break;
        case 4:
            e.push(`${n("interpolate")}(${n("named")}(${JSON.stringify(t.key)}))`, t);
            break;
        case 9:
            e.push(JSON.stringify(t.value), t);
            break;
        case 3:
            e.push(JSON.stringify(t.value), t);
            break
    }
}
const yx = (e,t={})=>{
        const n = ve(t.mode) ? t.mode : "normal"
            , r = ve(t.filename) ? t.filename : "message.intl"
            , i = !!t.sourceMap
            , s = t.breakLineCode != null ? t.breakLineCode : n === "arrow" ? ";" : `
`
            , o = t.needIndent ? t.needIndent : n !== "arrow"
            , a = e.helpers || []
            , l = px(e, {
            mode: n,
            filename: r,
            sourceMap: i,
            breakLineCode: s,
            needIndent: o
        });
        l.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"),
            l.indent(o),
        a.length > 0 && (l.push(`const { ${pf(a.map(f=>`${f}: _ ${f}`), ", ")} } = ctx`),
            l.newline()),
            l.push("return "),
            Di(l, e),
            l.deindent(o),
            l.push("}"),
            delete e.helpers;
        const {code: c, map: u} = l.context();
        return {
            ast: e,
            code: c,
            map: u ? u.toJSON() : void 0
        }
    }
;
function bx(e, t={}) {
    const n = Et({}, t)
        , r = !!n.jit
        , i = n.optimize == null ? !0 : n.optimize
        , o = cx(n).parse(e);
    return r ? (i && dx(o),
        {
            ast: o,
            code: ""
        }) : (fx(o, n),
        yx(o, n))
}
/*!
  * devtools-if v9.3.0-beta.24
  * (c) 2023 kazuya kawaguchi
  * Released under the MIT License.
  */
const Yv = {
    I18nInit: "i18n:init",
    FunctionTranslate: "function:translate"
};
/*!
  * core-base v9.3.0-beta.24
  * (c) 2023 kazuya kawaguchi
  * Released under the MIT License.
  */
function wx() {
    typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (ff().__INTLIFY_PROD_DEVTOOLS__ = !1)
}
const Tr = [];
Tr[0] = {
    w: [0],
    i: [3, 0],
    ["["]: [4],
    o: [7]
};
Tr[1] = {
    w: [1],
    ["."]: [2],
    ["["]: [4],
    o: [7]
};
Tr[2] = {
    w: [2],
    i: [3, 0],
    [0]: [3, 0]
};
Tr[3] = {
    i: [3, 0],
    [0]: [3, 0],
    w: [1, 1],
    ["."]: [2, 1],
    ["["]: [4, 1],
    o: [7, 1]
};
Tr[4] = {
    ["'"]: [5, 0],
    ['"']: [6, 0],
    ["["]: [4, 2],
    ["]"]: [1, 3],
    o: 8,
    l: [4, 0]
};
Tr[5] = {
    ["'"]: [4, 0],
    o: 8,
    l: [5, 0]
};
Tr[6] = {
    ['"']: [4, 0],
    o: 8,
    l: [6, 0]
};
const Sx = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function _x(e) {
    return Sx.test(e)
}
function Ex(e) {
    const t = e.charCodeAt(0)
        , n = e.charCodeAt(e.length - 1);
    return t === n && (t === 34 || t === 39) ? e.slice(1, -1) : e
}
function Cx(e) {
    if (e == null)
        return "o";
    switch (e.charCodeAt(0)) {
        case 91:
        case 93:
        case 46:
        case 34:
        case 39:
            return e;
        case 95:
        case 36:
        case 45:
            return "i";
        case 9:
        case 10:
        case 13:
        case 160:
        case 65279:
        case 8232:
        case 8233:
            return "w"
    }
    return "i"
}
function Tx(e) {
    const t = e.trim();
    return e.charAt(0) === "0" && isNaN(parseInt(e)) ? !1 : _x(t) ? Ex(t) : "*" + t
}
function xx(e) {
    const t = [];
    let n = -1, r = 0, i = 0, s, o, a, l, c, u, f;
    const d = [];
    d[0] = ()=>{
        o === void 0 ? o = a : o += a
    }
        ,
        d[1] = ()=>{
            o !== void 0 && (t.push(o),
                o = void 0)
        }
        ,
        d[2] = ()=>{
            d[0](),
                i++
        }
        ,
        d[3] = ()=>{
            if (i > 0)
                i--,
                    r = 4,
                    d[0]();
            else {
                if (i = 0,
                o === void 0 || (o = Tx(o),
                o === !1))
                    return !1;
                d[1]()
            }
        }
    ;
    function h() {
        const y = e[n + 1];
        if (r === 5 && y === "'" || r === 6 && y === '"')
            return n++,
                a = "\\" + y,
                d[0](),
                !0
    }
    for (; r !== null; )
        if (n++,
            s = e[n],
            !(s === "\\" && h())) {
            if (l = Cx(s),
                f = Tr[r],
                c = f[l] || f.l || 8,
            c === 8 || (r = c[0],
            c[1] !== void 0 && (u = d[c[1]],
            u && (a = s,
            u() === !1))))
                return;
            if (r === 7)
                return t
        }
}
const mp = new Map;
function Px(e, t) {
    return Be(e) ? e[t] : null
}
function kx(e, t) {
    if (!Be(e))
        return null;
    let n = mp.get(t);
    if (n || (n = xx(t),
    n && mp.set(t, n)),
        !n)
        return null;
    const r = n.length;
    let i = e
        , s = 0;
    for (; s < r; ) {
        const o = i[n[s]];
        if (o === void 0)
            return null;
        i = o,
            s++
    }
    return i
}
const Rx = e=>e
    , Lx = e=>""
    , Ox = "text"
    , Ax = e=>e.length === 0 ? "" : pf(e)
    , Ix = J1;
function gp(e, t) {
    return e = Math.abs(e),
        t === 2 ? e ? e > 1 ? 1 : 0 : 1 : e ? Math.min(e, 2) : 0
}
function Mx(e) {
    const t = wt(e.pluralIndex) ? e.pluralIndex : -1;
    return e.named && (wt(e.named.count) || wt(e.named.n)) ? wt(e.named.count) ? e.named.count : wt(e.named.n) ? e.named.n : t : t
}
function Dx(e, t) {
    t.count || (t.count = e),
    t.n || (t.n = e)
}
function Nx(e={}) {
    const t = e.locale
        , n = Mx(e)
        , r = Be(e.pluralRules) && ve(t) && ut(e.pluralRules[t]) ? e.pluralRules[t] : gp
        , i = Be(e.pluralRules) && ve(t) && ut(e.pluralRules[t]) ? gp : void 0
        , s = m=>m[r(n, m.length, i)]
        , o = e.list || []
        , a = m=>o[m]
        , l = e.named || {};
    wt(e.pluralIndex) && Dx(n, l);
    const c = m=>l[m];
    function u(m) {
        const g = ut(e.messages) ? e.messages(m) : Be(e.messages) ? e.messages[m] : !1;
        return g || (e.parent ? e.parent.message(m) : Lx)
    }
    const f = m=>e.modifiers ? e.modifiers[m] : Rx
        , d = je(e.processor) && ut(e.processor.normalize) ? e.processor.normalize : Ax
        , h = je(e.processor) && ut(e.processor.interpolate) ? e.processor.interpolate : Ix
        , y = je(e.processor) && ve(e.processor.type) ? e.processor.type : Ox
        , w = {
        list: a,
        named: c,
        plural: s,
        linked: (m,...g)=>{
            const [b,v] = g;
            let S = "text"
                , _ = "";
            g.length === 1 ? Be(b) ? (_ = b.modifier || _,
                S = b.type || S) : ve(b) && (_ = b || _) : g.length === 2 && (ve(b) && (_ = b || _),
            ve(v) && (S = v || S));
            const E = u(m)(w)
                , T = S === "vnode" && st(E) && _ ? E[0] : E;
            return _ ? f(_)(T, S) : T
        }
        ,
        message: u,
        type: y,
        interpolate: h,
        normalize: d
    };
    return w
}
let Fs = null;
function $x(e) {
    Fs = e
}
function Fx(e, t, n) {
    Fs && Fs.emit(Yv.I18nInit, {
        timestamp: Date.now(),
        i18n: e,
        version: t,
        meta: n
    })
}
const jx = Hx(Yv.FunctionTranslate);
function Hx(e) {
    return t=>Fs && Fs.emit(e, t)
}
function Bx(e, t, n) {
    return [...new Set([n, ...st(t) ? t : Be(t) ? Object.keys(t) : ve(t) ? [t] : [n]])]
}
function qv(e, t, n) {
    const r = ve(n) ? n : mf
        , i = e;
    i.__localeChainCache || (i.__localeChainCache = new Map);
    let s = i.__localeChainCache.get(r);
    if (!s) {
        s = [];
        let o = [n];
        for (; st(o); )
            o = vp(s, o, t);
        const a = st(t) || !je(t) ? t : t.default ? t.default : null;
        o = ve(a) ? [a] : a,
        st(o) && vp(s, o, !1),
            i.__localeChainCache.set(r, s)
    }
    return s
}
function vp(e, t, n) {
    let r = !0;
    for (let i = 0; i < t.length && it(r); i++) {
        const s = t[i];
        ve(s) && (r = Vx(e, t[i], n))
    }
    return r
}
function Vx(e, t, n) {
    let r;
    const i = t.split("-");
    do {
        const s = i.join("-");
        r = zx(e, s, n),
            i.splice(-1, 1)
    } while (i.length && r === !0);
    return r
}
function zx(e, t, n) {
    let r = !1;
    if (!e.includes(t) && (r = !0,
        t)) {
        r = t[t.length - 1] !== "!";
        const i = t.replace(/!/g, "");
        e.push(i),
        (st(n) || je(n)) && n[i] && (r = n[i])
    }
    return r
}
const Ux = "9.3.0-beta.24"
    , tl = -1
    , mf = "en-US"
    , yp = ""
    , bp = e=>`${e.charAt(0).toLocaleUpperCase()}${e.substr(1)}`;
function Wx() {
    return {
        upper: (e,t)=>t === "text" && ve(e) ? e.toUpperCase() : t === "vnode" && Be(e) && "__v_isVNode"in e ? e.children.toUpperCase() : e,
        lower: (e,t)=>t === "text" && ve(e) ? e.toLowerCase() : t === "vnode" && Be(e) && "__v_isVNode"in e ? e.children.toLowerCase() : e,
        capitalize: (e,t)=>t === "text" && ve(e) ? bp(e) : t === "vnode" && Be(e) && "__v_isVNode"in e ? bp(e.children) : e
    }
}
let Jv;
function Gx(e) {
    Jv = e
}
let Zv;
function Xx(e) {
    Zv = e
}
let Qv;
function Kx(e) {
    Qv = e
}
let ey = null;
const wp = e=>{
    ey = e
}
    , Yx = ()=>ey;
let ty = null;
const Sp = e=>{
    ty = e
}
    , qx = ()=>ty;
let _p = 0;
function Jx(e={}) {
    const t = ve(e.version) ? e.version : Ux
        , n = ve(e.locale) ? e.locale : mf
        , r = st(e.fallbackLocale) || je(e.fallbackLocale) || ve(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : n
        , i = je(e.messages) ? e.messages : {
        [n]: {}
    }
        , s = je(e.datetimeFormats) ? e.datetimeFormats : {
        [n]: {}
    }
        , o = je(e.numberFormats) ? e.numberFormats : {
        [n]: {}
    }
        , a = Et({}, e.modifiers || {}, Wx())
        , l = e.pluralRules || {}
        , c = ut(e.missing) ? e.missing : null
        , u = it(e.missingWarn) || da(e.missingWarn) ? e.missingWarn : !0
        , f = it(e.fallbackWarn) || da(e.fallbackWarn) ? e.fallbackWarn : !0
        , d = !!e.fallbackFormat
        , h = !!e.unresolving
        , y = ut(e.postTranslation) ? e.postTranslation : null
        , p = je(e.processor) ? e.processor : null
        , w = it(e.warnHtmlMessage) ? e.warnHtmlMessage : !0
        , m = !!e.escapeParameter
        , g = ut(e.messageCompiler) ? e.messageCompiler : Jv
        , b = ut(e.messageResolver) ? e.messageResolver : Zv || Px
        , v = ut(e.localeFallbacker) ? e.localeFallbacker : Qv || Bx
        , S = Be(e.fallbackContext) ? e.fallbackContext : void 0
        , _ = ut(e.onWarn) ? e.onWarn : Y1
        , E = e
        , T = Be(E.__datetimeFormatters) ? E.__datetimeFormatters : new Map
        , P = Be(E.__numberFormatters) ? E.__numberFormatters : new Map
        , I = Be(E.__meta) ? E.__meta : {};
    _p++;
    const L = {
        version: t,
        cid: _p,
        locale: n,
        fallbackLocale: r,
        messages: i,
        modifiers: a,
        pluralRules: l,
        missing: c,
        missingWarn: u,
        fallbackWarn: f,
        fallbackFormat: d,
        unresolving: h,
        postTranslation: y,
        processor: p,
        warnHtmlMessage: w,
        escapeParameter: m,
        messageCompiler: g,
        messageResolver: b,
        localeFallbacker: v,
        fallbackContext: S,
        onWarn: _,
        __meta: I
    };
    return L.datetimeFormats = s,
        L.numberFormats = o,
        L.__datetimeFormatters = T,
        L.__numberFormatters = P,
    __INTLIFY_PROD_DEVTOOLS__ && Fx(L, t, I),
        L
}
function gf(e, t, n, r, i) {
    const {missing: s, onWarn: o} = e;
    if (s !== null) {
        const a = s(e, n, t, i);
        return ve(a) ? a : t
    } else
        return t
}
function es(e, t, n) {
    const r = e;
    r.__localeChainCache = new Map,
        e.localeFallbacker(e, n, t)
}
function Ll(e) {
    return n=>Zx(n, e)
}
function Zx(e, t) {
    return t.body.type === 1 ? e.plural(t.body.cases.reduce((n,r)=>[...n, Ep(e, r)], [])) : Ep(e, t.body)
}
function Ep(e, t) {
    if (t.static)
        return e.type === "text" ? t.static : e.normalize([t.static]);
    {
        const n = t.items.reduce((r,i)=>[...r, Ac(e, i)], []);
        return e.normalize(n)
    }
}
function Ac(e, t) {
    switch (t.type) {
        case 3:
            return t.value;
        case 9:
            return t.value;
        case 4:
            return e.interpolate(e.named(t.key));
        case 5:
            return e.interpolate(e.list(t.index));
        case 6:
            return e.linked(Ac(e, t.key), t.modifier ? Ac(e, t.modifier) : void 0, e.type);
        case 7:
            return t.value;
        case 8:
            return t.value;
        default:
            throw new Error(`unhandled node type on format message part: ${t.type}`)
    }
}
let ny = We.__EXTEND_POINT__;
const Eo = ()=>++ny
    , bi = {
    INVALID_ARGUMENT: ny,
    INVALID_DATE_ARGUMENT: Eo(),
    INVALID_ISO_DATE_ARGUMENT: Eo(),
    NOT_SUPPORT_AST: Eo(),
    __EXTEND_POINT__: Eo()
};
function wi(e) {
    return el(e, null, void 0)
}
const Qx = e=>e;
let Co = Object.create(null);
function eP(e, t={}) {
    let n = !1;
    const r = t.onError || Q1;
    return t.onError = i=>{
        n = !0,
            r(i)
    }
        ,
        {
            ...bx(e, t),
            detectError: n
        }
}
function tP(e, t={}) {
    if (ve(e)) {
        it(t.warnHtmlMessage) && t.warnHtmlMessage;
        const r = (t.onCacheKey || Qx)(e)
            , i = Co[r];
        if (i)
            return i;
        const {ast: s, detectError: o} = eP(e, {
            ...t,
            location: !1,
            jit: !0
        })
            , a = Ll(s);
        return o ? a : Co[r] = a
    } else {
        const n = e.cacheKey;
        if (n) {
            const r = Co[n];
            return r || (Co[n] = Ll(e))
        } else
            return Ll(e)
    }
}
const Cp = ()=>""
    , vn = e=>ut(e)
    , js = e=>Be(e) && e.type === 0 && "body"in e;
function Tp(e, ...t) {
    const {fallbackFormat: n, postTranslation: r, unresolving: i, messageCompiler: s, fallbackLocale: o, messages: a} = e
        , [l,c] = Ic(...t)
        , u = it(c.missingWarn) ? c.missingWarn : e.missingWarn
        , f = it(c.fallbackWarn) ? c.fallbackWarn : e.fallbackWarn
        , d = it(c.escapeParameter) ? c.escapeParameter : e.escapeParameter
        , h = !!c.resolvedMessage
        , y = ve(c.default) || it(c.default) ? it(c.default) ? s ? l : ()=>l : c.default : n ? s ? l : ()=>l : ""
        , p = n || y !== ""
        , w = ve(c.locale) ? c.locale : e.locale;
    d && nP(c);
    let[m,g,b] = h ? [l, w, a[w] || {}] : ry(e, l, w, o, f, u)
        , v = m
        , S = l;
    if (!h && !(ve(v) || js(v) || vn(v)) && p && (v = y,
        S = v),
    !h && (!(ve(v) || js(v) || vn(v)) || !ve(g)))
        return i ? tl : l;
    let _ = !1;
    const E = ()=>{
        _ = !0
    }
        , T = vn(v) ? v : iy(e, l, g, v, S, E);
    if (_)
        return v;
    const P = sP(e, g, b, c)
        , I = Nx(P)
        , L = rP(e, T, I)
        , x = r ? r(L, l) : L;
    if (__INTLIFY_PROD_DEVTOOLS__) {
        const A = {
            timestamp: Date.now(),
            key: ve(l) ? l : vn(v) ? v.key : "",
            locale: g || (vn(v) ? v.locale : ""),
            format: ve(v) ? v : vn(v) ? v.source : "",
            message: x
        };
        A.meta = Et({}, e.__meta, Yx() || {}),
            jx(A)
    }
    return x
}
function nP(e) {
    st(e.list) ? e.list = e.list.map(t=>ve(t) ? fp(t) : t) : Be(e.named) && Object.keys(e.named).forEach(t=>{
            ve(e.named[t]) && (e.named[t] = fp(e.named[t]))
        }
    )
}
function ry(e, t, n, r, i, s) {
    const {messages: o, onWarn: a, messageResolver: l, localeFallbacker: c} = e
        , u = c(e, r, n);
    let f = {}, d, h = null;
    const y = "translate";
    for (let p = 0; p < u.length && (d = u[p],
        f = o[d] || {},
    (h = l(f, t)) === null && (h = f[t]),
        !(ve(h) || js(h) || vn(h))); p++) {
        const w = gf(e, t, d, s, y);
        w !== t && (h = w)
    }
    return [h, d, f]
}
function iy(e, t, n, r, i, s) {
    const {messageCompiler: o, warnHtmlMessage: a} = e;
    if (vn(r)) {
        const c = r;
        return c.locale = c.locale || n,
            c.key = c.key || t,
            c
    }
    if (o == null) {
        const c = ()=>r;
        return c.locale = n,
            c.key = t,
            c
    }
    const l = o(r, iP(e, n, i, r, a, s));
    return l.locale = n,
        l.key = t,
        l.source = r,
        l
}
function rP(e, t, n) {
    return t(n)
}
function Ic(...e) {
    const [t,n,r] = e
        , i = {};
    if (!ve(t) && !wt(t) && !vn(t) && !js(t))
        throw wi(bi.INVALID_ARGUMENT);
    const s = wt(t) ? String(t) : (vn(t),
        t);
    return wt(n) ? i.plural = n : ve(n) ? i.default = n : je(n) && !Qa(n) ? i.named = n : st(n) && (i.list = n),
        wt(r) ? i.plural = r : ve(r) ? i.default = r : je(r) && Et(i, r),
        [s, i]
}
function iP(e, t, n, r, i, s) {
    return {
        warnHtmlMessage: i,
        onError: o=>{
            throw s && s(o),
                o
        }
        ,
        onCacheKey: o=>G1(t, n, o)
    }
}
function sP(e, t, n, r) {
    const {modifiers: i, pluralRules: s, messageResolver: o, fallbackLocale: a, fallbackWarn: l, missingWarn: c, fallbackContext: u} = e
        , d = {
        locale: t,
        modifiers: i,
        pluralRules: s,
        messages: h=>{
            let y = o(n, h);
            if (y == null && u) {
                const [,,p] = ry(u, h, t, a, l, c);
                y = o(p, h)
            }
            if (ve(y) || js(y)) {
                let p = !1;
                const m = iy(e, h, t, y, h, ()=>{
                        p = !0
                    }
                );
                return p ? Cp : m
            } else
                return vn(y) ? y : Cp
        }
    };
    return e.processor && (d.processor = e.processor),
    r.list && (d.list = r.list),
    r.named && (d.named = r.named),
    wt(r.plural) && (d.pluralIndex = r.plural),
        d
}
function xp(e, ...t) {
    const {datetimeFormats: n, unresolving: r, fallbackLocale: i, onWarn: s, localeFallbacker: o} = e
        , {__datetimeFormatters: a} = e
        , [l,c,u,f] = Mc(...t)
        , d = it(u.missingWarn) ? u.missingWarn : e.missingWarn;
    it(u.fallbackWarn) ? u.fallbackWarn : e.fallbackWarn;
    const h = !!u.part
        , y = ve(u.locale) ? u.locale : e.locale
        , p = o(e, i, y);
    if (!ve(l) || l === "")
        return new Intl.DateTimeFormat(y,f).format(c);
    let w = {}, m, g = null;
    const b = "datetime format";
    for (let _ = 0; _ < p.length && (m = p[_],
        w = n[m] || {},
        g = w[l],
        !je(g)); _++)
        gf(e, l, m, d, b);
    if (!je(g) || !ve(m))
        return r ? tl : l;
    let v = `${m}__ ${l}`;
    Qa(f) || (v = `${v}__ ${JSON.stringify(f)}`);
    let S = a.get(v);
    return S || (S = new Intl.DateTimeFormat(m,Et({}, g, f)),
        a.set(v, S)),
        h ? S.formatToParts(c) : S.format(c)
}
const sy = ["localeMatcher", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "formatMatcher", "hour12", "timeZone", "dateStyle", "timeStyle", "calendar", "dayPeriod", "numberingSystem", "hourCycle", "fractionalSecondDigits"];
function Mc(...e) {
    const [t,n,r,i] = e
        , s = {};
    let o = {}, a;
    if (ve(t)) {
        const l = t.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
        if (!l)
            throw wi(bi.INVALID_ISO_DATE_ARGUMENT);
        const c = l[3] ? l[3].trim().startsWith("T") ? `${l[1].trim()}${l[3].trim()}` : `${l[1].trim()}T ${l[3].trim()}` : l[1].trim();
        a = new Date(c);
        try {
            a.toISOString()
        } catch {
            throw wi(bi.INVALID_ISO_DATE_ARGUMENT)
        }
    } else if (K1(t)) {
        if (isNaN(t.getTime()))
            throw wi(bi.INVALID_DATE_ARGUMENT);
        a = t
    } else if (wt(t))
        a = t;
    else
        throw wi(bi.INVALID_ARGUMENT);
    return ve(n) ? s.key = n : je(n) && Object.keys(n).forEach(l=>{
            sy.includes(l) ? o[l] = n[l] : s[l] = n[l]
        }
    ),
        ve(r) ? s.locale = r : je(r) && (o = r),
    je(i) && (o = i),
        [s.key || "", a, s, o]
}
function Pp(e, t, n) {
    const r = e;
    for (const i in n) {
        const s = `${t}__ ${i}`;
        r.__datetimeFormatters.has(s) && r.__datetimeFormatters.delete(s)
    }
}
function kp(e, ...t) {
    const {numberFormats: n, unresolving: r, fallbackLocale: i, onWarn: s, localeFallbacker: o} = e
        , {__numberFormatters: a} = e
        , [l,c,u,f] = Dc(...t)
        , d = it(u.missingWarn) ? u.missingWarn : e.missingWarn;
    it(u.fallbackWarn) ? u.fallbackWarn : e.fallbackWarn;
    const h = !!u.part
        , y = ve(u.locale) ? u.locale : e.locale
        , p = o(e, i, y);
    if (!ve(l) || l === "")
        return new Intl.NumberFormat(y,f).format(c);
    let w = {}, m, g = null;
    const b = "number format";
    for (let _ = 0; _ < p.length && (m = p[_],
        w = n[m] || {},
        g = w[l],
        !je(g)); _++)
        gf(e, l, m, d, b);
    if (!je(g) || !ve(m))
        return r ? tl : l;
    let v = `${m}__ ${l}`;
    Qa(f) || (v = `${v}__ ${JSON.stringify(f)}`);
    let S = a.get(v);
    return S || (S = new Intl.NumberFormat(m,Et({}, g, f)),
        a.set(v, S)),
        h ? S.formatToParts(c) : S.format(c)
}
const oy = ["localeMatcher", "style", "currency", "currencyDisplay", "currencySign", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "compactDisplay", "notation", "signDisplay", "unit", "unitDisplay", "roundingMode", "roundingPriority", "roundingIncrement", "trailingZeroDisplay"];
function Dc(...e) {
    const [t,n,r,i] = e
        , s = {};
    let o = {};
    if (!wt(t))
        throw wi(bi.INVALID_ARGUMENT);
    const a = t;
    return ve(n) ? s.key = n : je(n) && Object.keys(n).forEach(l=>{
            oy.includes(l) ? o[l] = n[l] : s[l] = n[l]
        }
    ),
        ve(r) ? s.locale = r : je(r) && (o = r),
    je(i) && (o = i),
        [s.key || "", a, s, o]
}
function Rp(e, t, n) {
    const r = e;
    for (const i in n) {
        const s = `${t}__ ${i}`;
        r.__numberFormatters.has(s) && r.__numberFormatters.delete(s)
    }
}
wx();
/*!
  * vue-i18n v9.3.0-beta.24
  * (c) 2023 kazuya kawaguchi
  * Released under the MIT License.
  */
const oP = "9.3.0-beta.24";
function aP() {
    typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (ff().__INTLIFY_PROD_DEVTOOLS__ = !1)
}
let ay = We.__EXTEND_POINT__;
const Ht = ()=>++ay
    , rn = {
    UNEXPECTED_RETURN_TYPE: ay,
    INVALID_ARGUMENT: Ht(),
    MUST_BE_CALL_SETUP_TOP: Ht(),
    NOT_INSTALLED: Ht(),
    NOT_AVAILABLE_IN_LEGACY_MODE: Ht(),
    REQUIRED_VALUE: Ht(),
    INVALID_VALUE: Ht(),
    CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: Ht(),
    NOT_INSTALLED_WITH_PROVIDE: Ht(),
    UNEXPECTED_ERROR: Ht(),
    NOT_COMPATIBLE_LEGACY_VUE_I18N: Ht(),
    BRIDGE_SUPPORT_VUE_2_ONLY: Ht(),
    MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: Ht(),
    NOT_AVAILABLE_COMPOSITION_IN_LEGACY: Ht(),
    __EXTEND_POINT__: Ht()
};
function fn(e, ...t) {
    return el(e, null, void 0)
}
const Nc = Zr("__translateVNode")
    , $c = Zr("__datetimeParts")
    , Fc = Zr("__numberParts")
    , lP = Zr("__setPluralRules")
    , cP = Zr("__injectWithOption");
function jc(e) {
    if (!Be(e))
        return e;
    for (const t in e)
        if (df(e, t))
            if (!t.includes("."))
                Be(e[t]) && jc(e[t]);
            else {
                const n = t.split(".")
                    , r = n.length - 1;
                let i = e
                    , s = !1;
                for (let o = 0; o < r; o++) {
                    if (n[o]in i || (i[n[o]] = {}),
                        !Be(i[n[o]])) {
                        s = !0;
                        break
                    }
                    i = i[n[o]]
                }
                s || (i[n[r]] = e[t],
                    delete e[t]),
                Be(i[n[r]]) && jc(i[n[r]])
            }
    return e
}
function ly(e, t) {
    const {messages: n, __i18n: r, messageResolver: i, flatJson: s} = t
        , o = je(n) ? n : st(r) ? {} : {
        [e]: {}
    };
    if (st(r) && r.forEach(a=>{
            if ("locale"in a && "resource"in a) {
                const {locale: l, resource: c} = a;
                l ? (o[l] = o[l] || {},
                    Es(c, o[l])) : Es(c, o)
            } else
                ve(a) && Es(JSON.parse(a), o)
        }
    ),
    i == null && s)
        for (const a in o)
            df(o, a) && jc(o[a]);
    return o
}
const To = e=>!Be(e) || st(e);
function Es(e, t) {
    if (To(e) || To(t))
        throw fn(rn.INVALID_VALUE);
    for (const n in e)
        df(e, n) && (To(e[n]) || To(t[n]) ? t[n] = e[n] : Es(e[n], t[n]))
}
function cy(e) {
    return e.type
}
function uP(e, t, n) {
    let r = Be(t.messages) ? t.messages : {};
    "__i18nGlobal"in n && (r = ly(e.locale.value, {
        messages: r,
        __i18n: n.__i18nGlobal
    }));
    const i = Object.keys(r);
    i.length && i.forEach(s=>{
            e.mergeLocaleMessage(s, r[s])
        }
    );
    {
        if (Be(t.datetimeFormats)) {
            const s = Object.keys(t.datetimeFormats);
            s.length && s.forEach(o=>{
                    e.mergeDateTimeFormat(o, t.datetimeFormats[o])
                }
            )
        }
        if (Be(t.numberFormats)) {
            const s = Object.keys(t.numberFormats);
            s.length && s.forEach(o=>{
                    e.mergeNumberFormat(o, t.numberFormats[o])
                }
            )
        }
    }
}
function Lp(e) {
    return Re(vr, null, e, 0)
}
const Op = "__INTLIFY_META__";
let Ap = 0;
function Ip(e) {
    return (t,n,r,i)=>e(n, r, Ot() || void 0, i)
}
const fP = ()=>{
        const e = Ot();
        let t = null;
        return e && (t = cy(e)[Op]) ? {
            [Op]: t
        } : null
    }
;
function uy(e={}, t) {
    const {__root: n} = e
        , r = n === void 0;
    let i = it(e.inheritLocale) ? e.inheritLocale : !0;
    const s = X(n && i ? n.locale.value : ve(e.locale) ? e.locale : mf)
        , o = X(n && i ? n.fallbackLocale.value : ve(e.fallbackLocale) || st(e.fallbackLocale) || je(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : s.value)
        , a = X(ly(s.value, e))
        , l = X(je(e.datetimeFormats) ? e.datetimeFormats : {
        [s.value]: {}
    })
        , c = X(je(e.numberFormats) ? e.numberFormats : {
        [s.value]: {}
    });
    let u = n ? n.missingWarn : it(e.missingWarn) || da(e.missingWarn) ? e.missingWarn : !0
        , f = n ? n.fallbackWarn : it(e.fallbackWarn) || da(e.fallbackWarn) ? e.fallbackWarn : !0
        , d = n ? n.fallbackRoot : it(e.fallbackRoot) ? e.fallbackRoot : !0
        , h = !!e.fallbackFormat
        , y = ut(e.missing) ? e.missing : null
        , p = ut(e.missing) ? Ip(e.missing) : null
        , w = ut(e.postTranslation) ? e.postTranslation : null
        , m = n ? n.warnHtmlMessage : it(e.warnHtmlMessage) ? e.warnHtmlMessage : !0
        , g = !!e.escapeParameter;
    const b = n ? n.modifiers : je(e.modifiers) ? e.modifiers : {};
    let v = e.pluralRules || n && n.pluralRules, S;
    S = (()=>{
            r && Sp(null);
            const U = {
                version: oP,
                locale: s.value,
                fallbackLocale: o.value,
                messages: a.value,
                modifiers: b,
                pluralRules: v,
                missing: p === null ? void 0 : p,
                missingWarn: u,
                fallbackWarn: f,
                fallbackFormat: h,
                unresolving: !0,
                postTranslation: w === null ? void 0 : w,
                warnHtmlMessage: m,
                escapeParameter: g,
                messageResolver: e.messageResolver,
                __meta: {
                    framework: "vue"
                }
            };
            U.datetimeFormats = l.value,
                U.numberFormats = c.value,
                U.__datetimeFormatters = je(S) ? S.__datetimeFormatters : void 0,
                U.__numberFormatters = je(S) ? S.__numberFormatters : void 0;
            const $ = Jx(U);
            return r && Sp($),
                $
        }
    )(),
        es(S, s.value, o.value);
    function E() {
        return [s.value, o.value, a.value, l.value, c.value]
    }
    const T = fe({
        get: ()=>s.value,
        set: U=>{
            s.value = U,
                S.locale = s.value
        }
    })
        , P = fe({
        get: ()=>o.value,
        set: U=>{
            o.value = U,
                S.fallbackLocale = o.value,
                es(S, s.value, U)
        }
    })
        , I = fe(()=>a.value)
        , L = fe(()=>l.value)
        , x = fe(()=>c.value);
    function A() {
        return ut(w) ? w : null
    }
    function k(U) {
        w = U,
            S.postTranslation = U
    }
    function O() {
        return y
    }
    function N(U) {
        U !== null && (p = Ip(U)),
            y = U,
            S.missing = p
    }
    const D = (U,$,Z,te,pe,oe)=>{
            E();
            let me;
            if (__INTLIFY_PROD_DEVTOOLS__)
                try {
                    wp(fP()),
                    r || (S.fallbackContext = n ? qx() : void 0),
                        me = U(S)
                } finally {
                    wp(null),
                    r || (S.fallbackContext = void 0)
                }
            else
                me = U(S);
            if (wt(me) && me === tl) {
                const [Me,Ne] = $();
                return n && d ? te(n) : pe(Me)
            } else {
                if (oe(me))
                    return me;
                throw fn(rn.UNEXPECTED_RETURN_TYPE)
            }
        }
    ;
    function W(...U) {
        return D($=>Reflect.apply(Tp, null, [$, ...U]), ()=>Ic(...U), "translate", $=>Reflect.apply($.t, $, [...U]), $=>$, $=>ve($))
    }
    function G(...U) {
        const [$,Z,te] = U;
        if (te && !Be(te))
            throw fn(rn.INVALID_ARGUMENT);
        return W($, Z, Et({
            resolvedMessage: !0
        }, te || {}))
    }
    function le(...U) {
        return D($=>Reflect.apply(xp, null, [$, ...U]), ()=>Mc(...U), "datetime format", $=>Reflect.apply($.d, $, [...U]), ()=>yp, $=>ve($))
    }
    function ge(...U) {
        return D($=>Reflect.apply(kp, null, [$, ...U]), ()=>Dc(...U), "number format", $=>Reflect.apply($.n, $, [...U]), ()=>yp, $=>ve($))
    }
    function ye(U) {
        return U.map($=>ve($) || wt($) || it($) ? Lp(String($)) : $)
    }
    const z = {
        normalize: ye,
        interpolate: U=>U,
        type: "vnode"
    };
    function Pe(...U) {
        return D($=>{
                let Z;
                const te = $;
                try {
                    te.processor = z,
                        Z = Reflect.apply(Tp, null, [te, ...U])
                } finally {
                    te.processor = null
                }
                return Z
            }
            , ()=>Ic(...U), "translate", $=>$[Nc](...U), $=>[Lp($)], $=>st($))
    }
    function _e(...U) {
        return D($=>Reflect.apply(kp, null, [$, ...U]), ()=>Dc(...U), "number format", $=>$[Fc](...U), ()=>[], $=>ve($) || st($))
    }
    function J(...U) {
        return D($=>Reflect.apply(xp, null, [$, ...U]), ()=>Mc(...U), "datetime format", $=>$[$c](...U), ()=>[], $=>ve($) || st($))
    }
    function ne(U) {
        v = U,
            S.pluralRules = v
    }
    function ee(U, $) {
        const Z = ve($) ? $ : s.value
            , te = M(Z);
        return S.messageResolver(te, U) !== null
    }
    function ce(U) {
        let $ = null;
        const Z = qv(S, o.value, s.value);
        for (let te = 0; te < Z.length; te++) {
            const pe = a.value[Z[te]] || {}
                , oe = S.messageResolver(pe, U);
            if (oe != null) {
                $ = oe;
                break
            }
        }
        return $
    }
    function Ce(U) {
        const $ = ce(U);
        return $ ?? (n ? n.tm(U) || {} : {})
    }
    function M(U) {
        return a.value[U] || {}
    }
    function C(U, $) {
        a.value[U] = $,
            S.messages = a.value
    }
    function R(U, $) {
        a.value[U] = a.value[U] || {},
            Es($, a.value[U]),
            S.messages = a.value
    }
    function F(U) {
        return l.value[U] || {}
    }
    function V(U, $) {
        l.value[U] = $,
            S.datetimeFormats = l.value,
            Pp(S, U, $)
    }
    function Y(U, $) {
        l.value[U] = Et(l.value[U] || {}, $),
            S.datetimeFormats = l.value,
            Pp(S, U, $)
    }
    function re(U) {
        return c.value[U] || {}
    }
    function ie(U, $) {
        c.value[U] = $,
            S.numberFormats = c.value,
            Rp(S, U, $)
    }
    function ae(U, $) {
        c.value[U] = Et(c.value[U] || {}, $),
            S.numberFormats = c.value,
            Rp(S, U, $)
    }
    Ap++,
    n && Lc && (Se(n.locale, U=>{
            i && (s.value = U,
                S.locale = U,
                es(S, s.value, o.value))
        }
    ),
        Se(n.fallbackLocale, U=>{
                i && (o.value = U,
                    S.fallbackLocale = U,
                    es(S, s.value, o.value))
            }
        ));
    const Q = {
        id: Ap,
        locale: T,
        fallbackLocale: P,
        get inheritLocale() {
            return i
        },
        set inheritLocale(U) {
            i = U,
            U && n && (s.value = n.locale.value,
                o.value = n.fallbackLocale.value,
                es(S, s.value, o.value))
        },
        get availableLocales() {
            return Object.keys(a.value).sort()
        },
        messages: I,
        get modifiers() {
            return b
        },
        get pluralRules() {
            return v || {}
        },
        get isGlobal() {
            return r
        },
        get missingWarn() {
            return u
        },
        set missingWarn(U) {
            u = U,
                S.missingWarn = u
        },
        get fallbackWarn() {
            return f
        },
        set fallbackWarn(U) {
            f = U,
                S.fallbackWarn = f
        },
        get fallbackRoot() {
            return d
        },
        set fallbackRoot(U) {
            d = U
        },
        get fallbackFormat() {
            return h
        },
        set fallbackFormat(U) {
            h = U,
                S.fallbackFormat = h
        },
        get warnHtmlMessage() {
            return m
        },
        set warnHtmlMessage(U) {
            m = U,
                S.warnHtmlMessage = U
        },
        get escapeParameter() {
            return g
        },
        set escapeParameter(U) {
            g = U,
                S.escapeParameter = U
        },
        t: W,
        getLocaleMessage: M,
        setLocaleMessage: C,
        mergeLocaleMessage: R,
        getPostTranslationHandler: A,
        setPostTranslationHandler: k,
        getMissingHandler: O,
        setMissingHandler: N,
        [lP]: ne
    };
    return Q.datetimeFormats = L,
        Q.numberFormats = x,
        Q.rt = G,
        Q.te = ee,
        Q.tm = Ce,
        Q.d = le,
        Q.n = ge,
        Q.getDateTimeFormat = F,
        Q.setDateTimeFormat = V,
        Q.mergeDateTimeFormat = Y,
        Q.getNumberFormat = re,
        Q.setNumberFormat = ie,
        Q.mergeNumberFormat = ae,
        Q[cP] = e.__injectWithOption,
        Q[Nc] = Pe,
        Q[$c] = J,
        Q[Fc] = _e,
        Q
}
const vf = {
    tag: {
        type: [String, Object]
    },
    locale: {
        type: String
    },
    scope: {
        type: String,
        validator: e=>e === "parent" || e === "global",
        default: "parent"
    },
    i18n: {
        type: Object
    }
};
function dP({slots: e}, t) {
    return t.length === 1 && t[0] === "default" ? (e.default ? e.default() : []).reduce((r,i)=>[...r, ...i.type === nt ? i.children : [i]], []) : t.reduce((n,r)=>{
            const i = e[r];
            return i && (n[r] = i()),
                n
        }
        , {})
}
function fy(e) {
    return nt
}
const pP = Xe({
    name: "i18n-t",
    props: Et({
        keypath: {
            type: String,
            required: !0
        },
        plural: {
            type: [Number, String],
            validator: e=>wt(e) || !isNaN(e)
        }
    }, vf),
    setup(e, t) {
        const {slots: n, attrs: r} = t
            , i = e.i18n || $n({
            useScope: e.scope,
            __useComponent: !0
        });
        return ()=>{
            const s = Object.keys(n).filter(f=>f !== "_")
                , o = {};
            e.locale && (o.locale = e.locale),
            e.plural !== void 0 && (o.plural = ve(e.plural) ? +e.plural : e.plural);
            const a = dP(t, s)
                , l = i[Nc](e.keypath, a, o)
                , c = Et({}, r)
                , u = ve(e.tag) || Be(e.tag) ? e.tag : fy();
            return yt(u, c, l)
        }
    }
})
    , Mp = pP;
function hP(e) {
    return st(e) && !ve(e[0])
}
function dy(e, t, n, r) {
    const {slots: i, attrs: s} = t;
    return ()=>{
        const o = {
            part: !0
        };
        let a = {};
        e.locale && (o.locale = e.locale),
            ve(e.format) ? o.key = e.format : Be(e.format) && (ve(e.format.key) && (o.key = e.format.key),
                a = Object.keys(e.format).reduce((d,h)=>n.includes(h) ? Et({}, d, {
                    [h]: e.format[h]
                }) : d, {}));
        const l = r(e.value, o, a);
        let c = [o.key];
        st(l) ? c = l.map((d,h)=>{
                const y = i[d.type]
                    , p = y ? y({
                    [d.type]: d.value,
                    index: h,
                    parts: l
                }) : [d.value];
                return hP(p) && (p[0].key = `${d.type}-${h}`),
                    p
            }
        ) : ve(l) && (c = [l]);
        const u = Et({}, s)
            , f = ve(e.tag) || Be(e.tag) ? e.tag : fy();
        return yt(f, u, c)
    }
}
const mP = Xe({
    name: "i18n-n",
    props: Et({
        value: {
            type: Number,
            required: !0
        },
        format: {
            type: [String, Object]
        }
    }, vf),
    setup(e, t) {
        const n = e.i18n || $n({
            useScope: "parent",
            __useComponent: !0
        });
        return dy(e, t, oy, (...r)=>n[Fc](...r))
    }
})
    , Dp = mP
    , gP = Xe({
    name: "i18n-d",
    props: Et({
        value: {
            type: [Number, Date],
            required: !0
        },
        format: {
            type: [String, Object]
        }
    }, vf),
    setup(e, t) {
        const n = e.i18n || $n({
            useScope: "parent",
            __useComponent: !0
        });
        return dy(e, t, sy, (...r)=>n[$c](...r))
    }
})
    , Np = gP;
function vP(e, t) {
    const n = e;
    if (e.mode === "composition")
        return n.__getInstance(t) || e.global;
    {
        const r = n.__getInstance(t);
        return r != null ? r.__composer : e.global.__composer
    }
}
function yP(e) {
    const t = o=>{
            const {instance: a, modifiers: l, value: c} = o;
            if (!a || !a.$)
                throw fn(rn.UNEXPECTED_ERROR);
            const u = vP(e, a.$)
                , f = $p(c);
            return [Reflect.apply(u.t, u, [...Fp(f)]), u]
        }
    ;
    return {
        created: (o,a)=>{
            const [l,c] = t(a);
            Lc && e.global === c && (o.__i18nWatcher = Se(c.locale, ()=>{
                    a.instance && a.instance.$forceUpdate()
                }
            )),
                o.__composer = c,
                o.textContent = l
        }
        ,
        unmounted: o=>{
            Lc && o.__i18nWatcher && (o.__i18nWatcher(),
                o.__i18nWatcher = void 0,
                delete o.__i18nWatcher),
            o.__composer && (o.__composer = void 0,
                delete o.__composer)
        }
        ,
        beforeUpdate: (o,{value: a})=>{
            if (o.__composer) {
                const l = o.__composer
                    , c = $p(a);
                o.textContent = Reflect.apply(l.t, l, [...Fp(c)])
            }
        }
        ,
        getSSRProps: o=>{
            const [a] = t(o);
            return {
                textContent: a
            }
        }
    }
}
function $p(e) {
    if (ve(e))
        return {
            path: e
        };
    if (je(e)) {
        if (!("path"in e))
            throw fn(rn.REQUIRED_VALUE, "path");
        return e
    } else
        throw fn(rn.INVALID_VALUE)
}
function Fp(e) {
    const {path: t, locale: n, args: r, choice: i, plural: s} = e
        , o = {}
        , a = r || {};
    return ve(n) && (o.locale = n),
    wt(i) && (o.plural = i),
    wt(s) && (o.plural = s),
        [t, a, o]
}
function bP(e, t, ...n) {
    const r = je(n[0]) ? n[0] : {}
        , i = !!r.useI18nComponentName;
    (it(r.globalInstall) ? r.globalInstall : !0) && ([i ? "i18n" : Mp.name, "I18nT"].forEach(o=>e.component(o, Mp)),
        [Dp.name, "I18nN"].forEach(o=>e.component(o, Dp)),
        [Np.name, "I18nD"].forEach(o=>e.component(o, Np))),
        e.directive("t", yP(t))
}
const wP = Zr("global-vue-i18n");
function SP(e={}, t) {
    const n = it(e.globalInjection) ? e.globalInjection : !0
        , r = !0
        , i = new Map
        , [s,o] = _P(e)
        , a = Zr("");
    function l(f) {
        return i.get(f) || null
    }
    function c(f, d) {
        i.set(f, d)
    }
    function u(f) {
        i.delete(f)
    }
    {
        const f = {
            get mode() {
                return "composition"
            },
            get allowComposition() {
                return r
            },
            async install(d, ...h) {
                if (d.__VUE_I18N_SYMBOL__ = a,
                    d.provide(d.__VUE_I18N_SYMBOL__, f),
                    je(h[0])) {
                    const p = h[0];
                    f.__composerExtend = p.__composerExtend,
                        f.__vueI18nExtend = p.__vueI18nExtend
                }
                n && OP(d, f.global),
                    bP(d, f, ...h);
                const y = d.unmount;
                d.unmount = ()=>{
                    f.dispose(),
                        y()
                }
            },
            get global() {
                return o
            },
            dispose() {
                s.stop()
            },
            __instances: i,
            __getInstance: l,
            __setInstance: c,
            __deleteInstance: u
        };
        return f
    }
}
function $n(e={}) {
    const t = Ot();
    if (t == null)
        throw fn(rn.MUST_BE_CALL_SETUP_TOP);
    if (!t.isCE && t.appContext.app != null && !t.appContext.app.__VUE_I18N_SYMBOL__)
        throw fn(rn.NOT_INSTALLED);
    const n = EP(t)
        , r = TP(n)
        , i = cy(t)
        , s = CP(e, i);
    if (s === "global")
        return uP(r, e, i),
            r;
    if (s === "parent") {
        let l = xP(n, t, e.__useComponent);
        return l == null && (l = r),
            l
    }
    const o = n;
    let a = o.__getInstance(t);
    if (a == null) {
        const l = Et({}, e);
        "__i18n"in i && (l.__i18n = i.__i18n),
        r && (l.__root = r),
            a = uy(l),
        o.__composerExtend && o.__composerExtend(a),
            kP(o, t),
            o.__setInstance(t, a)
    }
    return a
}
function _P(e, t, n) {
    const r = La();
    {
        const i = r.run(()=>uy(e));
        if (i == null)
            throw fn(rn.UNEXPECTED_ERROR);
        return [r, i]
    }
}
function EP(e) {
    {
        const t = vt(e.isCE ? wP : e.appContext.app.__VUE_I18N_SYMBOL__);
        if (!t)
            throw fn(e.isCE ? rn.NOT_INSTALLED_WITH_PROVIDE : rn.UNEXPECTED_ERROR);
        return t
    }
}
function CP(e, t) {
    return Qa(e) ? "__i18n"in t ? "local" : "global" : e.useScope ? e.useScope : "local"
}
function TP(e) {
    return e.mode === "composition" ? e.global : e.global.__composer
}
function xP(e, t, n=!1) {
    let r = null;
    const i = t.root;
    let s = PP(t, n);
    for (; s != null; ) {
        const o = e;
        if (e.mode === "composition" && (r = o.__getInstance(s)),
        r != null || i === s)
            break;
        s = s.parent
    }
    return r
}
function PP(e, t=!1) {
    return e == null ? null : t && e.vnode.ctx || e.parent
}
function kP(e, t, n) {
    Ve(()=>{}
        , t),
        Kt(()=>{
                e.__deleteInstance(t)
            }
            , t)
}
const RP = ["locale", "fallbackLocale", "availableLocales"]
    , LP = ["t", "rt", "d", "n", "tm", "te"];
function OP(e, t) {
    const n = Object.create(null);
    RP.forEach(r=>{
            const i = Object.getOwnPropertyDescriptor(t, r);
            if (!i)
                throw fn(rn.UNEXPECTED_ERROR);
            const s = Je(i.value) ? {
                get() {
                    return i.value.value
                },
                set(o) {
                    i.value.value = o
                }
            } : {
                get() {
                    return i.get && i.get()
                }
            };
            Object.defineProperty(n, r, s)
        }
    ),
        e.config.globalProperties.$i18n = n,
        LP.forEach(r=>{
                const i = Object.getOwnPropertyDescriptor(t, r);
                if (!i || !i.value)
                    throw fn(rn.UNEXPECTED_ERROR);
                Object.defineProperty(e.config.globalProperties, `$ ${r}`, i)
            }
        )
}
aP();
Gx(tP);
Xx(kx);
Kx(qv);
if (__INTLIFY_PROD_DEVTOOLS__) {
    const e = ff();
    e.__INTLIFY__ = !0,
        $x(e.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__)
}
const AP = !0
    , py = {
    PREFIX: "prefix",
    PREFIX_EXCEPT_DEFAULT: "prefix_except_default",
    PREFIX_AND_DEFAULT: "prefix_and_default",
    NO_PREFIX: "no_prefix"
}
    , IP = ""
    , MP = py.PREFIX_EXCEPT_DEFAULT
    , DP = !1
    , NP = "___"
    , $P = "default"
    , FP = "ltr"
    , jP = ""
    , hy = "";
/*!
  * shared v9.3.0-beta.16
  * (c) 2023 kazuya kawaguchi
  * Released under the MIT License.
  */
const HP = (e,t=!1)=>t ? Symbol.for(e) : Symbol(e)
    , nl = Object.assign
    , my = Array.isArray
    , Hc = e=>typeof e == "function"
    , Ni = e=>typeof e == "string"
    , BP = e=>typeof e == "symbol"
    , yf = e=>e !== null && typeof e == "object"
    , VP = /\/$|\/\?/;
function Bc(e="", t=!1) {
    return t ? VP.test(e) : e.endsWith("/")
}
function zP(e="", t=!1) {
    if (!t)
        return (Bc(e) ? e.slice(0, -1) : e) || "/";
    if (!Bc(e, !0))
        return e || "/";
    const [n,...r] = e.split("?");
    return (n.slice(0, -1) || "/") + (r.length > 0 ? `?${r.join("?")}` : "")
}
function UP(e="", t=!1) {
    if (!t)
        return e.endsWith("/") ? e : e + "/";
    if (Bc(e, !0))
        return e || "/";
    const [n,...r] = e.split("?");
    return n + "/" + (r.length > 0 ? `?${r.join("?")}` : "")
}
const gy = typeof window < "u";
function vy(e, t) {
    typeof console < "u" && (console.warn("[vue-i18n-routing] " + e),
    t && console.warn(t.stack))
}
function WP(e) {
    e = e || [];
    const t = [];
    for (const n of e)
        Ni(n) ? t.push({
            code: n
        }) : t.push(n);
    return t
}
function Qr(e) {
    return e != null && "global"in e && "mode"in e
}
function Gi(e) {
    return e != null && !("__composer"in e) && Je(e.locale)
}
function Sr(e) {
    return e != null && "__composer"in e
}
function no(e) {
    return e != null && !("__composer"in e) && !Je(e.locale)
}
function rl(e) {
    return e != null && ("__VUE_I18N_BRIDGE__"in e || "_sync"in e)
}
function Hs(e) {
    return Qr(e) ? Gi(e.global) ? e.global : e.global.__composer : Sr(e) ? e.__composer : e
}
function il(e) {
    const t = Qr(e) ? e.global : e;
    return Gi(t) ? t.locale.value : (no(t) || Sr(t) || rl(t),
        t.locale)
}
function GP(e) {
    const t = Qr(e) ? e.global : e;
    return Gi(t) ? t.locales.value : (no(t) || Sr(t) || rl(t),
        t.locales)
}
function XP(e) {
    const t = Qr(e) ? e.global : e;
    return Gi(t) ? t.localeCodes.value : (no(t) || Sr(t) || rl(t),
        t.localeCodes)
}
function yy(e, t) {
    const n = Qr(e) ? e.global : e;
    if (Gi(n))
        n.locale.value = t;
    else if (no(n) || Sr(n) || rl(n))
        n.locale = t;
    else
        throw new Error("TODO:")
}
function jp(e) {
    return Je(e) ? e.value : e
}
function by(e) {
    return Ni(e) ? e : BP(e) ? e.toString() : "(null)"
}
function Hp(e, t, {defaultLocale: n, strategy: r, routesNameSeparator: i, defaultLocaleRouteNameSuffix: s}) {
    let o = by(e) + (r === "no_prefix" ? "" : i + t);
    return t === n && r === "prefix_and_default" && (o += i + s),
        o
}
function Bp(e, t) {
    return Hc(e) ? e(t) : e
}
function KP(e, t) {
    const n = [];
    for (const [r,i] of t.entries()) {
        const s = e.find(o=>o.iso.toLowerCase() === i.toLowerCase());
        if (s) {
            n.push({
                code: s.code,
                score: 1 - r / t.length
            });
            break
        }
    }
    for (const [r,i] of t.entries()) {
        const s = i.split("-")[0].toLowerCase()
            , o = e.find(a=>a.iso.split("-")[0].toLowerCase() === s);
        if (o) {
            n.push({
                code: o.code,
                score: .999 - r / t.length
            });
            break
        }
    }
    return n
}
const YP = KP;
function qP(e, t) {
    return e.score === t.score ? t.code.length - e.code.length : t.score - e.score
}
const JP = qP;
function ZP(e, t, {matcher: n=YP, comparer: r=JP}={}) {
    const i = [];
    for (const o of e) {
        const {code: a} = o
            , l = o.iso || a;
        i.push({
            code: a,
            iso: l
        })
    }
    const s = n(i, t);
    return s.length > 1 && s.sort(r),
        s.length ? s[0].code : ""
}
function Rr(e) {
    return function() {
        return Reflect.apply(e, {
            getRouteBaseName: this.getRouteBaseName,
            localePath: this.localePath,
            localeRoute: this.localeRoute,
            localeLocation: this.localeLocation,
            resolveRoute: this.resolveRoute,
            switchLocalePath: this.switchLocalePath,
            localeHead: this.localeHead,
            i18n: this.$i18n,
            route: this.$route,
            router: this.$router
        }, arguments)
    }
}
function QP(e, {locales: t=[], localeCodes: n=[], baseUrl: r=jP, hooks: i={}, context: s={}}={}) {
    const o = La()
        , a = e.install;
    return e.install = (l,...c)=>{
        const u = nk(c[0]) ? nl({}, c[0]) : {
            inject: !0
        };
        u.inject == null && (u.inject = !0);
        const f = u.__composerExtend;
        if (u.__composerExtend = p=>{
            const w = Hs(e);
            p.locales = fe(()=>w.locales.value),
                p.localeCodes = fe(()=>w.localeCodes.value),
                p.baseUrl = fe(()=>w.baseUrl.value),
            Hc(f) && Reflect.apply(f, u, [p])
        }
            ,
            Sr(e.global)) {
            const p = u.__vueI18nExtend;
            u.__vueI18nExtend = w=>{
                Vp(w, i.onExtendVueI18n),
                Hc(p) && Reflect.apply(p, u, [w])
            }
        }
        c[0] = u,
            Reflect.apply(a, e, [l, ...c]);
        const d = Hs(e);
        o.run(()=>ek(d, {
            locales: t,
            localeCodes: n,
            baseUrl: r,
            hooks: i,
            context: s
        })),
        Sr(e.global) && Vp(e.global, i.onExtendVueI18n);
        const h = l
            , y = e.mode === "composition" ? h.config.globalProperties.$i18n : null;
        if (y && tk(y, d, i.onExtendExportedGlobal),
        u.inject && l.mixin({
            methods: {
                resolveRoute: Rr(sl),
                localePath: Rr(bf),
                localeRoute: Rr(wf),
                localeLocation: Rr(uk),
                switchLocalePath: Rr(Bs),
                getRouteBaseName: Rr($i),
                localeHead: Rr(Sf)
            }
        }),
            h.unmount) {
            const p = h.unmount;
            h.unmount = ()=>{
                o.stop(),
                    p()
            }
        }
    }
        ,
        o
}
function ek(e, t) {
    const {locales: n, localeCodes: r, baseUrl: i, context: s} = t
        , o = X(n)
        , a = X(r)
        , l = X("");
    e.locales = fe(()=>o.value),
        e.localeCodes = fe(()=>a.value),
        e.baseUrl = fe(()=>l.value),
        gy ? Se(e.locale, ()=>{
                l.value = Bp(i, s)
            }
            , {
                immediate: !0
            }) : l.value = Bp(i, s),
    t.hooks && t.hooks.onExtendComposer && t.hooks.onExtendComposer(e)
}
function tk(e, t, n) {
    const r = [{
        locales: {
            get() {
                return t.locales.value
            }
        },
        localeCodes: {
            get() {
                return t.localeCodes.value
            }
        },
        baseUrl: {
            get() {
                return t.baseUrl.value
            }
        }
    }];
    n && r.push(n(t));
    for (const i of r)
        for (const [s,o] of Object.entries(i))
            Object.defineProperty(e, s, o)
}
function Vp(e, t) {
    const n = Hs(e)
        , r = [{
        locales: {
            get() {
                return n.locales.value
            }
        },
        localeCodes: {
            get() {
                return n.localeCodes.value
            }
        },
        baseUrl: {
            get() {
                return n.baseUrl.value
            }
        }
    }];
    t && r.push(t(n));
    for (const i of r)
        for (const [s,o] of Object.entries(i))
            Object.defineProperty(e, s, o)
}
function nk(e) {
    return yf(e) && ("inject"in e || "__composerExtend"in e || "__vueI18nExtend"in e)
}
const Vc = HP("vue-i18n-routing-gor");
function rk(e, t) {
    e[Vc] ? vy("already registered global options") : e[Vc] = t
}
function ik(e) {
    var t;
    return (t = e[Vc]) != null ? t : {}
}
function zc(e) {
    return new RegExp(`^/(${e.join("|")})(?:/|$)`,"i")
}
function sk(e, t, n) {
    const r = `(${e.join("|")})`
        , i = `(?:${t}${n})?`
        , s = new RegExp(`${t}${r}${i}$`,"i")
        , o = zc(e);
    return l=>{
        if (yf(l)) {
            if (l.name) {
                const u = (Ni(l.name) ? l.name : l.name.toString()).match(s);
                if (u && u.length > 1)
                    return u[1]
            } else if (l.path) {
                const c = l.path.match(o);
                if (c && c.length > 1)
                    return c[1]
            }
        } else if (Ni(l)) {
            const c = l.match(o);
            if (c && c.length > 1)
                return c[1]
        }
        return ""
    }
}
function ro(e, t, {defaultLocale: n=IP, defaultDirection: r=FP, defaultLocaleRouteNameSuffix: i=$P, routesNameSeparator: s=NP, strategy: o=MP, trailingSlash: a=DP, localeCodes: l=[], prefixable: c=wy, switchLocalePathIntercepter: u=Sy, dynamicRouteParamsKey: f=hy}={}) {
    const d = ik(e);
    return {
        defaultLocale: t.defaultLocale || d.defaultLocale || n,
        defaultDirection: t.defaultDirection || d.defaultDirection || r,
        defaultLocaleRouteNameSuffix: t.defaultLocaleRouteNameSuffix || d.defaultLocaleRouteNameSuffix || i,
        routesNameSeparator: t.routesNameSeparator || d.routesNameSeparator || s,
        strategy: t.strategy || d.strategy || o,
        trailingSlash: t.trailingSlash || d.trailingSlash || a,
        localeCodes: t.localeCodes || d.localeCodes || l,
        prefixable: t.prefixable || d.prefixable || c,
        switchLocalePathIntercepter: t.switchLocalePathIntercepter || d.switchLocalePathIntercepter || u,
        dynamicRouteParamsKey: t.dynamicRouteParamsKey || d.dynamicRouteParamsKey || f
    }
}
function ok(e, t) {
    return [e.slice(0, t), e.slice(t)]
}
function ak(e, t, n, r) {
    if (n === "prefix") {
        if (my(t.matched) && t.matched.length > 0)
            return t.matched[0];
        const [i,s] = ok(t.path, 1)
            , o = `${i}${r}${s === "" ? s : `/${s}`}`
            , a = e.options.routes.find(l=>l.path === o);
        if (a == null)
            return t;
        {
            const l = nl({}, t, a);
            return l.path = o,
                e.resolve(l)
        }
    } else
        return e.resolve(t)
}
const lk = new Set(["prefix_and_default", "prefix_except_default"]);
function ck(e) {
    const {currentLocale: t, defaultLocale: n, strategy: r} = e;
    return !(t === n && lk.has(r)) && r !== "no_prefix"
}
const wy = ck;
function $i(e) {
    const t = this.router
        , {routesNameSeparator: n} = ro(t, this)
        , r = e != null ? Je(e) ? we(e) : e : this.route;
    return r == null || !r.name ? void 0 : by(r.name).split(n)[0]
}
function bf(e, t) {
    const n = sl.call(this, e, t);
    return n == null ? "" : n.redirectedFrom || n.fullPath
}
function wf(e, t) {
    const n = sl.call(this, e, t);
    return n ?? void 0
}
function uk(e, t) {
    const n = sl.call(this, e, t);
    return n ?? void 0
}
function sl(e, t) {
    const n = this.router
        , r = this.i18n
        , i = t || il(r)
        , {routesNameSeparator: s, defaultLocale: o, defaultLocaleRouteNameSuffix: a, strategy: l, trailingSlash: c, prefixable: u} = ro(n, this);
    let f = e;
    Ni(e) && (f[0] === "/" ? f = {
        path: e
    } : f = {
        name: e
    });
    let d = nl({}, f);
    if (d.path && !d.name) {
        let h = null;
        try {
            h = ak(n, d, l, i)
        } catch {}
        const y = h
            , p = $i.call(this, y);
        Ni(p) ? (d = {
            name: Hp(p, i, {
                defaultLocale: o,
                strategy: l,
                routesNameSeparator: s,
                defaultLocaleRouteNameSuffix: a
            }),
            params: y.params,
            query: y.query,
            hash: y.hash
        },
            d.state = y.state) : (u({
            currentLocale: i,
            defaultLocale: o,
            strategy: l
        }) && (d.path = `/${i}${d.path}`),
            d.path = c ? UP(d.path, !0) : zP(d.path, !0))
    } else
        !d.name && !d.path && (d.name = $i.call(this, this.route)),
            d.name = Hp(d.name, i, {
                defaultLocale: o,
                strategy: l,
                routesNameSeparator: s,
                defaultLocaleRouteNameSuffix: a
            });
    try {
        const h = n.resolve(d);
        return (AP ? h.name : h.route.name) ? h : n.resolve(e)
    } catch (h) {
        if (h.type === 1)
            return null
    }
}
const Sy = e=>e;
function fk(e, t) {
    const n = {};
    if (t === hy)
        return n;
    const r = e.meta;
    return Je(r) ? r.value[t] || n : r[t] || n
}
function Bs(e) {
    const t = this.route
        , n = $i.call(this, t);
    if (!n)
        return "";
    const {switchLocalePathIntercepter: r, dynamicRouteParamsKey: i} = ro(this.router, this)
        , {params: s, ...o} = t
        , a = fk(t, i)[e] || {}
        , l = {
        name: n,
        params: {
            ...s,
            ...a
        }
    }
        , c = nl({}, o, l);
    let u = bf.call(this, c, e);
    return u = r(u, e),
        u
}
function Sf({addDirAttribute: e=!1, addSeoAttributes: t=!1, identifierAttribute: n="hid"}={}) {
    const r = this.router
        , i = this.i18n
        , {defaultDirection: s} = ro(r, this)
        , o = {
        htmlAttrs: {},
        link: [],
        meta: []
    };
    if (i.locales == null || i.baseUrl == null)
        return o;
    const a = il(i)
        , l = GP(i)
        , c = WP(l).find(d=>d.code === a) || {
        code: a
    }
        , u = c.iso
        , f = c.dir || s;
    return e && (o.htmlAttrs.dir = f),
    t && a && i.locales && (u && (o.htmlAttrs.lang = u),
        dk.call(this, l, we(i.baseUrl), o.link, n),
        pk.call(this, we(i.baseUrl), o.link, o.meta, n, t),
        hk(c, u, o.meta, n),
        mk(l, u, o.meta, n)),
        o
}
function dk(e, t, n, r) {
    const i = this.router
        , {defaultLocale: s, strategy: o} = ro(i, this);
    if (o === py.NO_PREFIX)
        return;
    const a = new Map;
    for (const l of e) {
        const c = l.iso;
        if (!c) {
            vy("Locale ISO code is required to generate alternate link");
            continue
        }
        const [u,f] = c.split("-");
        u && f && (l.isCatchallLocale || !a.has(u)) && a.set(u, l),
            a.set(c, l)
    }
    for (const [l,c] of a.entries()) {
        const u = Bs.call(this, c.code);
        u && n.push({
            [r]: `i18n-alt-${l}`,
            rel: "alternate",
            href: Uc(u, t),
            hreflang: l
        })
    }
    if (s) {
        const l = Bs.call(this, s);
        l && n.push({
            [r]: "i18n-xd",
            rel: "alternate",
            href: Uc(l, t),
            hreflang: "x-default"
        })
    }
}
function pk(e, t, n, r, i) {
    const s = this.route
        , o = wf.call(this, {
        ...s,
        name: $i.call(this, s)
    });
    if (o) {
        let a = Uc(o.path, e);
        const l = yf(i) && i.canonicalQueries || [];
        if (l.length) {
            const c = o.query
                , u = new URLSearchParams;
            for (const d of l)
                if (d in c) {
                    const h = c[d];
                    my(h) ? h.forEach(y=>u.append(d, y || "")) : u.append(d, h || "")
                }
            const f = u.toString();
            f && (a = `${a}?${f}`)
        }
        t.push({
            [r]: "i18n-can",
            rel: "canonical",
            href: a
        }),
            n.push({
                [r]: "i18n-og-url",
                property: "og:url",
                content: a
            })
    }
}
function hk(e, t, n, r) {
    e && t && n.push({
        [r]: "i18n-og",
        property: "og:locale",
        content: _y(t)
    })
}
function mk(e, t, n, r) {
    const i = e.filter(s=>{
            const o = s.iso;
            return o && o !== t
        }
    );
    if (i.length) {
        const s = i.map(o=>({
            [r]: `i18n-og-alt-${o.iso}`,
            property: "og:locale:alternate",
            content: _y(o.iso)
        }));
        n.push(...s)
    }
}
function _y(e) {
    return (e || "").replace(/-/g, "_")
}
function Uc(e, t) {
    return e.match(/^https?:\/\//) ? e : t + e
}
function gk(e, t) {
    const {router: n, route: r, i18n: i, defaultLocale: s, strategy: o, defaultLocaleRouteNameSuffix: a, trailingSlash: l, routesNameSeparator: c} = e;
    return function(...u) {
        return Reflect.apply(t, {
            router: n,
            route: r,
            i18n: i,
            defaultLocale: s,
            strategy: o,
            defaultLocaleRouteNameSuffix: a,
            trailingSlash: l,
            routesNameSeparator: c
        }, u)
    }
}
function vk({router: e=Wv(), route: t=uf(), i18n: n=$n(), defaultLocale: r=void 0, defaultLocaleRouteNameSuffix: i=void 0, routesNameSeparator: s=void 0, strategy: o=void 0, trailingSlash: a=void 0}={}) {
    return gk({
        router: e,
        route: t,
        i18n: n,
        defaultLocale: r,
        defaultLocaleRouteNameSuffix: i,
        routesNameSeparator: s,
        strategy: o,
        trailingSlash: a
    }, Bs)
}
function aF({addDirAttribute: e=!1, addSeoAttributes: t=!1, identifierAttribute: n="hid", strategy: r=void 0, defaultLocale: i=void 0, route: s=uf(), router: o=Wv(), i18n: a=$n()}={}) {
    const l = o
        , c = X({
        htmlAttrs: {},
        link: [],
        meta: []
    });
    function u() {
        c.value = {
            htmlAttrs: {},
            link: [],
            meta: []
        }
    }
    function f(d) {
        c.value = Reflect.apply(Sf, {
            router: o,
            route: d,
            i18n: a,
            defaultLocale: i,
            strategy: r
        }, [{
            addDirAttribute: e,
            addSeoAttributes: t,
            identifierAttribute: n
        }])
    }
    if (gy) {
        const d = Er(()=>{
                u(),
                    f(jp(l.currentRoute))
            }
        );
        Kt(()=>d())
    } else
        f(jp(l.currentRoute));
    return c
}
const oi = ["en", "ru", "uk"]
    , yk = {
    en: [{
        key: "../locales/en.yaml",
        load: ()=>at(()=>import("./en.989409ce.js"), [], import.meta.url)
    }],
    ru: [{
        key: "../locales/ru.yaml",
        load: ()=>at(()=>import("./ru.adc4cc73.js"), [], import.meta.url)
    }],
    uk: [{
        key: "../locales/uk.yaml",
        load: ()=>at(()=>import("./uk.550bbef7.js"), [], import.meta.url)
    }]
}
    , bk = async e=>{
    const t = Object({});
    return t.experimental = Object({
        jsTsFormatResource: !1
    }),
        t.compilation = Object({
            jit: !0,
            strictMessage: !0,
            escapeHtml: !1
        }),
        t.vueI18n = Object({}),
        t.locales = [Object({
            code: "en",
            iso: "en-US",
            file: "en.yaml",
            hash: "d9cae4c3",
            type: "static"
        }), Object({
            code: "ru",
            iso: "ru-RU",
            file: "ru.yaml",
            hash: "9baa2f0b",
            type: "static"
        }), Object({
            code: "uk",
            iso: "uk-UK",
            file: "uk.yaml",
            hash: "1f8bf1f3",
            type: "static"
        })],
        t.defaultLocale = "en",
        t.defaultDirection = "ltr",
        t.routesNameSeparator = "___",
        t.trailingSlash = !1,
        t.defaultLocaleRouteNameSuffix = "default",
        t.strategy = "no_prefix",
        t.lazy = !0,
        t.langDir = "locales",
        t.rootRedirect = null,
        t.detectBrowserLanguage = Object({
            alwaysRedirect: !1,
            cookieCrossOrigin: !1,
            cookieDomain: null,
            cookieKey: "i18n_redirected",
            cookieSecure: !1,
            fallbackLocale: "",
            redirectOn: "root",
            useCookie: !0
        }),
        t.differentDomains = !1,
        t.baseUrl = "https://rulet.tv",
        t.dynamicRouteParams = !1,
        t.customRoutes = "page",
        t.pages = Object({}),
        t.skipSettingLocaleOnNavigate = !1,
        t.types = "composition",
        t.debug = !1,
        t
}
    , en = Object({
    experimental: Object({
        jsTsFormatResource: !1
    }),
    compilation: Object({
        jit: !0,
        strictMessage: !0,
        escapeHtml: !1
    }),
    vueI18n: "",
    locales: [],
    defaultLocale: "",
    defaultDirection: "ltr",
    routesNameSeparator: "___",
    trailingSlash: !1,
    defaultLocaleRouteNameSuffix: "default",
    strategy: "prefix_except_default",
    lazy: !1,
    langDir: null,
    rootRedirect: null,
    detectBrowserLanguage: Object({
        alwaysRedirect: !1,
        cookieCrossOrigin: !1,
        cookieDomain: null,
        cookieKey: "i18n_redirected",
        cookieSecure: !1,
        fallbackLocale: "",
        redirectOn: "root",
        useCookie: !0
    }),
    differentDomains: !1,
    baseUrl: "",
    dynamicRouteParams: !1,
    customRoutes: "page",
    pages: Object({}),
    skipSettingLocaleOnNavigate: !1,
    types: "composition",
    debug: !1
})
    , Wc = Object({
    __normalizedLocales: [Object({
        code: "en",
        iso: "en-US",
        file: "en.yaml",
        hash: "d9cae4c3",
        type: "static"
    }), Object({
        code: "ru",
        iso: "ru-RU",
        file: "ru.yaml",
        hash: "9baa2f0b",
        type: "static"
    }), Object({
        code: "uk",
        iso: "uk-UK",
        file: "uk.yaml",
        hash: "1f8bf1f3",
        type: "static"
    })]
})
    , Ey = "@nuxtjs/i18n"
    , wk = !1;
/*! js-cookie v3.0.5 | MIT */
function xo(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];
        for (var r in n)
            e[r] = n[r]
    }
    return e
}
var Sk = {
    read: function(e) {
        return e[0] === '"' && (e = e.slice(1, -1)),
            e.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent)
    },
    write: function(e) {
        return encodeURIComponent(e).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent)
    }
};
function Gc(e, t) {
    function n(i, s, o) {
        if (!(typeof document > "u")) {
            o = xo({}, t, o),
            typeof o.expires == "number" && (o.expires = new Date(Date.now() + o.expires * 864e5)),
            o.expires && (o.expires = o.expires.toUTCString()),
                i = encodeURIComponent(i).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
            var a = "";
            for (var l in o)
                o[l] && (a += "; " + l,
                o[l] !== !0 && (a += "=" + o[l].split(";")[0]));
            return document.cookie = i + "=" + e.write(s, i) + a
        }
    }
    function r(i) {
        if (!(typeof document > "u" || arguments.length && !i)) {
            for (var s = document.cookie ? document.cookie.split("; ") : [], o = {}, a = 0; a < s.length; a++) {
                var l = s[a].split("=")
                    , c = l.slice(1).join("=");
                try {
                    var u = decodeURIComponent(l[0]);
                    if (o[u] = e.read(c, u),
                    i === u)
                        break
                } catch {}
            }
            return i ? o[i] : o
        }
    }
    return Object.create({
        set: n,
        get: r,
        remove: function(i, s) {
            n(i, "", xo({}, s, {
                expires: -1
            }))
        },
        withAttributes: function(i) {
            return Gc(this.converter, xo({}, this.attributes, i))
        },
        withConverter: function(i) {
            return Gc(xo({}, this.converter, i), this.attributes)
        }
    }, {
        attributes: {
            value: Object.freeze(t)
        },
        converter: {
            value: Object.freeze(e)
        }
    })
}
var Cy = Gc(Sk, {
    path: "/"
});
function pa(e) {
    return Ey + " " + e
}
function _k(e) {
    return e != null && ("__VUE_I18N_BRIDGE__"in e || "_sync"in e)
}
function ol(e, t, ...n) {
    const r = Qr(e) ? e.global : e
        , [i,s] = [r, r[t]];
    return Reflect.apply(s, i, [...n])
}
function Ek(e, t) {
    const n = Qr(e) ? e.global : e;
    return Gi(n) ? n[t].value : (no(n) || Sr(n) || _k(n),
        n[t])
}
function zp(e, t, n) {
    Object.defineProperty(e, t, {
        get: ()=>n
    })
}
function Ck(e, t) {
    return function() {
        return Reflect.apply(t, {
            i18n: e.$i18n,
            getRouteBaseName: e.$getRouteBaseName,
            localePath: e.$localePath,
            localeRoute: e.$localeRoute,
            switchLocalePath: e.$switchLocalePath,
            localeHead: e.$localeHead,
            route: e.$router.currentRoute.value,
            router: e.$router
        }, arguments)
    }
}
function Xc(e, t, n) {
    for (const r in e)
        st(e[r]) ? (st(t[r]) || (t[r] = []),
            e[r].forEach((i,s)=>{
                    if (!t[r][s]) {
                        const o = {};
                        Xc(i, o, n),
                            t[r].push(o)
                    }
                }
            )) : Be(e[r]) ? (Be(t[r]) || (t[r] = {}),
            Xc(e[r], t[r], n)) : n ? n(e[r], t[r]) && (t[r] = e[r]) : t[r] = e[r]
}
async function Up(e, t, n) {
    var s, o;
    const r = (s = e.$config.public) == null ? void 0 : s.i18n;
    let i = null;
    try {
        const a = await t().then(l=>l.default || l);
        ut(a) ? (o = r.experimental) != null && o.jsTsFormatResource ? i = await a(n) : console.warn(pa("Not support js / ts extension format as default. you can do enable with `i18n.experimental.jsTsFormatResource: true` (experimental)")) : i = a
    } catch (a) {
        console.error(pa("Failed locale loading: " + a.message))
    }
    return i
}
const Po = []
    , ai = new Map;
async function ha(e, t, n) {
    if (Po.includes(t))
        Po.includes(t) || console.warn(pa("Could not find " + t + " locale code in localeMessages"));
    else {
        const r = yk[t];
        if (r != null) {
            if (r.length === 1) {
                const {key: i, load: s} = r[0];
                let o = null;
                ai.has(i) ? o = ai.get(i) : (o = await Up(e, s, t),
                o != null && ai.set(i, o)),
                o != null && (n(t, o),
                    Po.push(t))
            } else if (r.length > 1) {
                const i = {};
                for (const {key: s, load: o} of r) {
                    let a = null;
                    ai.has(s) ? a = ai.get(s) : (a = await Up(e, o, t),
                    a != null && ai.set(s, a)),
                    a != null && Xc(a, i)
                }
                n(t, i),
                    Po.push(t)
            }
        }
    }
}
function Ty(e, t) {
    let n;
    return navigator.languages && (n = ZP(e.__normalizedLocales, navigator.languages)),
        n
}
function _f(e, {useCookie: t=en.detectBrowserLanguage.useCookie, cookieKey: n=en.detectBrowserLanguage.cookieKey, localeCodes: r=[]}={}) {
    if (t) {
        let i;
        if (i = Cy.get(n),
        i && r.includes(i))
            return i
    }
}
function Tk(e, t, {useCookie: n=en.detectBrowserLanguage.useCookie, cookieKey: r=en.detectBrowserLanguage.cookieKey, cookieDomain: i=en.detectBrowserLanguage.cookieDomain, cookieSecure: s=en.detectBrowserLanguage.cookieSecure, cookieCrossOrigin: o=en.detectBrowserLanguage.cookieCrossOrigin}={}) {
    if (!n)
        return;
    const a = new Date
        , l = {
        expires: new Date(a.setDate(a.getDate() + 365)),
        path: "/",
        sameSite: o ? "none" : "lax",
        secure: o || s
    };
    i && (l.domain = i),
        Cy.set(r, e, l)
}
const xk = {
    locale: "",
    stat: !1,
    reason: "unknown",
    from: "unknown"
};
function Pk(e, t, n, r, i, s=[], o="") {
    const {strategy: a} = n
        , {ssg: l, callType: c, firstAccess: u} = i;
    if (!u)
        return {
            locale: "",
            stat: !1,
            reason: "first_access_only"
        };
    const {redirectOn: f, alwaysRedirect: d, useCookie: h, fallbackLocale: y} = n.detectBrowserLanguage
        , p = ve(e) ? e : e.path;
    if (a !== "no_prefix") {
        if (f === "root") {
            if (p !== "/")
                return {
                    locale: "",
                    stat: !1,
                    reason: "not_redirect_on_root"
                }
        } else if (f === "no prefix" && !d && p.match(zc(s)))
            return {
                locale: "",
                stat: !1,
                reason: "not_redirect_on_no_prefix"
            }
    }
    let w = "unknown", m, g;
    h && (g = m = _f(t, {
        ...n.detectBrowserLanguage,
        localeCodes: s
    }),
        w = "cookie"),
    g || (g = Ty(r),
        w = "navigator_or_header");
    const b = g || y;
    !g && y && (w = "fallback");
    const v = o || n.vueI18n.locale;
    if (b && (!h || d || !m)) {
        if (a === "no_prefix")
            return {
                locale: b,
                stat: !0,
                from: w
            };
        if (c === "setup" && b !== v)
            return {
                locale: b,
                stat: !0,
                from: w
            };
        if (d) {
            const S = p === "/"
                , _ = f === "all"
                , E = f === "no prefix" && !p.match(zc(s));
            if (S || _ || E)
                return {
                    locale: b,
                    stat: !0,
                    from: w
                }
        }
    }
    return l === "ssg_setup" && b ? {
        locale: b,
        stat: !0,
        from: w
    } : (w === "navigator_or_header" || w === "cookie") && b ? {
        locale: b,
        stat: !0,
        from: w
    } : {
        locale: "",
        stat: !1,
        reason: "not_found_match"
    }
}
function kk() {
    let e;
    return e = window.location.host,
        e
}
function Rk(e) {
    let t = kk() || "";
    if (t) {
        const n = e.find(r=>r.domain === t);
        if (n)
            return n.code;
        t = ""
    }
    return t
}
function xy(e, t, n) {
    const r = t.find(i=>i.code === e);
    if (r && r.domain) {
        if (Qs(r.domain))
            return r.domain;
        let i;
        return i = window.location.protocol.split(":")[0],
        i + "://" + r.domain
    }
    console.warn(pa("Could not find domain name for locale " + e))
}
function Lk(e, t) {
    return ol(e, "setLocaleCookie", t)
}
function Ok(e, t, n) {
    return ol(e, "mergeLocaleMessage", t, n)
}
function Ak(e, t, n, r, i) {
    return ol(e, "onBeforeLanguageSwitch", t, n, r, i)
}
function Ik(e, t, n) {
    return ol(e, "onLanguageSwitched", t, n)
}
function Py(e, t) {
    let n = [];
    if (st(e))
        n = e;
    else if (Be(e)) {
        const r = [...t, "default"];
        for (const i of r)
            e[i] && (n = [...n, ...e[i].filter(Boolean)])
    } else
        ve(e) && t.every(r=>r !== e) && n.push(e);
    return n
}
async function Mk(e, t, n) {
    const {defaultLocale: r, initialLocale: i, localeCodes: s, fallbackLocale: o, langDir: a, lazy: l} = n
        , c = (u,f)=>{
            const d = t[u] || {};
            t[u] = {
                ...d,
                ...f
            }
        }
    ;
    if (a) {
        if (l && o) {
            const f = Py(o, [r, i]);
            await Promise.all(f.map(d=>ha(e, d, c)))
        }
        const u = l ? [...new Set().add(r).add(i)] : s;
        await Promise.all(u.map(f=>ha(e, f, c)))
    }
    return t
}
async function Wp(e, t, n, {useCookie: r=en.detectBrowserLanguage.useCookie, skipSettingLocaleOnNavigate: i=en.skipSettingLocaleOnNavigate, differentDomains: s=en.differentDomains, initial: o=!1, lazy: a=!1, langDir: l=null}={}) {
    let c = !1;
    const u = il(n);
    if (!e)
        return [c, u];
    if (!o && s)
        return [c, u];
    if (u === e)
        return [c, u];
    const f = await Ak(n, u, e, o, t)
        , d = XP(n);
    if (f && d && d.includes(f)) {
        if (f === u)
            return [c, u];
        e = f
    }
    if (l) {
        const h = Ek(n, "fallbackLocale");
        if (a) {
            const y = (p,w)=>Ok(n, p, w);
            if (h) {
                const p = Py(h, [e]);
                await Promise.all(p.map(w=>ha(t, w, y)))
            }
            await ha(t, e, y)
        }
    }
    return i ? [c, u] : (r && Lk(n, e),
        yy(n, e),
        await Ik(n, u, e),
        c = !0,
        [c, u])
}
function Gp(e, t, n, r, i, s, o, a=[]) {
    const {strategy: l, defaultLocale: c, differentDomains: u} = r
        , f = ut(i) ? i() : i
        , {locale: d, stat: h, reason: y, from: p} = r.detectBrowserLanguage ? Pk(e, t, r, Wc, s, a, f) : xk;
    if (y === "detect_ignore_on_ssg")
        return f;
    if ((p === "navigator_or_header" || p === "cookie" || p === "fallback") && d)
        return d;
    let w = d;
    return w || (u ? w = Rk(o) : l !== "no_prefix" ? w = n(e) : r.detectBrowserLanguage || (w = f)),
    !w && r.detectBrowserLanguage && r.detectBrowserLanguage.useCookie && (w = _f(t, {
        ...r.detectBrowserLanguage,
        localeCodes: a
    }) || ""),
    w || (w = c || ""),
        w
}
function Xp(e, t, n, r, i) {
    const {strategy: s, differentDomains: o} = i;
    let a = "";
    if (!o && s !== "no_prefix" && s !== "prefix_and_default" && r(e.to) !== n) {
        const {fullPath: l} = e.to
            , c = t.$switchLocalePath(n) || t.$localePath(l, n);
        ve(c) && c && !pv(c, l) && !c.startsWith("//") && (a = e.from && e.from.fullPath === c ? "" : c)
    }
    if (o || wk) {
        const c = vk({
            i18n: Hs(t.$i18n),
            route: e.to,
            router: t.$router
        })(n);
        ve(c) && (a = c)
    }
    return a
}
function Dk(e) {
    return Be(e) && "path"in e && "statusCode"in e
}
const Nk = ()=>sf(Ey + ":redirect", ()=>"");
function Kp(e, t) {
    return ET(e, {
        redirectCode: t
    })
}
async function Yp(e, {status: t=301, rootRedirect: n=en.rootRedirect, differentDomains: r=en.differentDomains, skipSettingLocaleOnNavigate: i=en.skipSettingLocaleOnNavigate}={}) {
    const {i18n: s, locale: o, route: a} = e;
    let {redirectPath: l} = e;
    if (a.path === "/" && n)
        return ve(n) ? l = "/" + n : Dk(n) && (l = "/" + n.path,
            t = n.statusCode),
            Kp(l, t);
    if (i) {
        s.__pendingLocale = o,
            s.__pendingLocalePromise = new Promise(c=>{
                    s.__resolvePendingLocalePromise = c
                }
            );
        return
    }
    if (r) {
        const c = Nk();
        c.value !== l && (c.value = "",
            window.location.assign(l))
    } else if (l)
        return Kp(l, t)
}
function $k(e, t) {
    zp(e, "$i18n", t.global);
    for (const n of [["getRouteBaseName", $i], ["localePath", bf], ["localeRoute", wf], ["switchLocalePath", Bs], ["localeHead", Sf]])
        zp(e, "$" + n[0], Ck(e, n[1]))
}
function Fk(e) {
    return t=>wy(t) && !e
}
function jk(e, t, n) {
    return (r,i)=>{
        if (e) {
            const s = xy(i, t);
            return s ? eo(s, r) : r
        } else
            return Sy(r)
    }
}
function Hk(e, t) {
    return n=>{
        var l, c;
        if (ut(e))
            return e(n);
        const {differentDomains: r, localeCodeLoader: i, normalizedLocales: s} = t
            , o = ut(i) ? i() : i;
        if (r && o) {
            const u = xy(o, s, t.nuxt);
            if (u)
                return u
        }
        const a = (c = (l = n.$config) == null ? void 0 : l.public) == null ? void 0 : c.i18n;
        return a != null && a.baseUrl ? a.baseUrl : e
    }
}
const Bk = dn(async e=>{
        let t, n;
        const r = Jr()
            , i = of()
            , {vueApp: s} = e
            , o = e
            , a = ([t,n] = jr(()=>bk()),
            t = await t,
            n(),
            t)
            , l = a.detectBrowserLanguage && a.detectBrowserLanguage.useCookie
            , {__normalizedLocales: c} = Wc
            , {defaultLocale: u, differentDomains: f, skipSettingLocaleOnNavigate: d, lazy: h, langDir: y, routesNameSeparator: p, defaultLocaleRouteNameSuffix: w, strategy: m, rootRedirect: g} = a;
        a.baseUrl = Hk(a.baseUrl, {
            differentDomains: f,
            nuxt: o,
            localeCodeLoader: u,
            normalizedLocales: c
        });
        const b = sk(oi, p, w)
            , v = a.vueI18n;
        v.messages = v.messages || {},
            v.fallbackLocale = v.fallbackLocale ?? !1,
            rk(r, {
                ...a,
                dynamicRouteParamsKey: "nuxtI18n",
                switchLocalePathIntercepter: jk(f, c),
                prefixable: Fk(f)
            });
        const S = x=>x || v.locale || "en-US";
        let _ = Gp(i, e.ssrContext, b, a, S(u), {
            ssg: "normal",
            callType: "setup",
            firstAccess: !0
        }, c, oi);
        v.messages = ([t,n] = jr(()=>Mk(o, v.messages, {
            ...a,
            initialLocale: _,
            fallbackLocale: v.fallbackLocale,
            localeCodes: oi
        })),
            t = await t,
            n(),
            t),
            _ = S(_);
        const E = SP({
            ...v,
            locale: _
        });
        let T = !0;
        const P = x=>_ !== x && T;
        QP(E, {
            locales: a.locales,
            localeCodes: oi,
            baseUrl: a.baseUrl,
            context: o,
            hooks: {
                onExtendComposer(x) {
                    x.strategy = m,
                        x.localeProperties = fe(()=>c.find(A=>A.code === x.locale.value) || {
                            code: x.locale.value
                        }),
                        x.setLocale = async A=>{
                            const k = P(A)
                                , [O] = await Wp(A, o, E, {
                                useCookie: l,
                                differentDomains: f,
                                initial: k,
                                skipSettingLocaleOnNavigate: d,
                                lazy: h,
                                langDir: y
                            });
                            O && k && (T = !1);
                            const N = Xp({
                                to: i
                            }, o, A, b, a);
                            await Yp({
                                i18n: E,
                                redirectPath: N,
                                locale: A,
                                route: i
                            }, {
                                differentDomains: f,
                                skipSettingLocaleOnNavigate: d,
                                rootRedirect: g
                            })
                        }
                        ,
                        x.differentDomains = f,
                        x.defaultLocale = u,
                        x.getBrowserLocale = ()=>Ty(Wc, e.ssrContext),
                        x.getLocaleCookie = ()=>_f(e.ssrContext, {
                            ...a.detectBrowserLanguage,
                            localeCodes: oi
                        }),
                        x.setLocaleCookie = A=>Tk(A, e.ssrContext, a.detectBrowserLanguage || void 0),
                        x.onBeforeLanguageSwitch = (A,k,O,N)=>e.callHook("i18n:beforeLocaleSwitch", {
                            oldLocale: A,
                            newLocale: k,
                            initialSetup: O,
                            context: N
                        }),
                        x.onLanguageSwitched = (A,k)=>e.callHook("i18n:localeSwitched", {
                            oldLocale: A,
                            newLocale: k
                        }),
                        x.finalizePendingLocaleChange = async()=>{
                            E.__pendingLocale && (yy(E, E.__pendingLocale),
                            E.__resolvePendingLocalePromise && await E.__resolvePendingLocalePromise(),
                                E.__pendingLocale = void 0)
                        }
                        ,
                        x.waitForPendingLocaleChange = async()=>{
                            E.__pendingLocale && E.__pendingLocalePromise && await E.__pendingLocalePromise
                        }
                },
                onExtendExportedGlobal(x) {
                    return {
                        strategy: {
                            get() {
                                return x.strategy
                            }
                        },
                        localeProperties: {
                            get() {
                                return x.localeProperties.value
                            }
                        },
                        setLocale: {
                            get() {
                                return async A=>Reflect.apply(x.setLocale, x, [A])
                            }
                        },
                        differentDomains: {
                            get() {
                                return x.differentDomains
                            }
                        },
                        defaultLocale: {
                            get() {
                                return x.defaultLocale
                            }
                        },
                        getBrowserLocale: {
                            get() {
                                return ()=>Reflect.apply(x.getBrowserLocale, x, [])
                            }
                        },
                        getLocaleCookie: {
                            get() {
                                return ()=>Reflect.apply(x.getLocaleCookie, x, [])
                            }
                        },
                        setLocaleCookie: {
                            get() {
                                return A=>Reflect.apply(x.setLocaleCookie, x, [A])
                            }
                        },
                        onBeforeLanguageSwitch: {
                            get() {
                                return (A,k,O,N)=>Reflect.apply(x.onBeforeLanguageSwitch, x, [A, k, O, N])
                            }
                        },
                        onLanguageSwitched: {
                            get() {
                                return (A,k)=>Reflect.apply(x.onLanguageSwitched, x, [A, k])
                            }
                        },
                        finalizePendingLocaleChange: {
                            get() {
                                return ()=>Reflect.apply(x.finalizePendingLocaleChange, x, [])
                            }
                        },
                        waitForPendingLocaleChange: {
                            get() {
                                return ()=>Reflect.apply(x.waitForPendingLocaleChange, x, [])
                            }
                        }
                    }
                },
                onExtendVueI18n(x) {
                    return {
                        strategy: {
                            get() {
                                return x.strategy
                            }
                        },
                        localeProperties: {
                            get() {
                                return x.localeProperties.value
                            }
                        },
                        setLocale: {
                            get() {
                                return async A=>Reflect.apply(x.setLocale, x, [A])
                            }
                        },
                        differentDomains: {
                            get() {
                                return x.differentDomains
                            }
                        },
                        defaultLocale: {
                            get() {
                                return x.defaultLocale
                            }
                        },
                        getBrowserLocale: {
                            get() {
                                return ()=>Reflect.apply(x.getBrowserLocale, x, [])
                            }
                        },
                        getLocaleCookie: {
                            get() {
                                return ()=>Reflect.apply(x.getLocaleCookie, x, [])
                            }
                        },
                        setLocaleCookie: {
                            get() {
                                return A=>Reflect.apply(x.setLocaleCookie, x, [A])
                            }
                        },
                        onBeforeLanguageSwitch: {
                            get() {
                                return (A,k,O,N)=>Reflect.apply(x.onBeforeLanguageSwitch, x, [A, k, O, N])
                            }
                        },
                        onLanguageSwitched: {
                            get() {
                                return (A,k)=>Reflect.apply(x.onLanguageSwitched, x, [A, k])
                            }
                        },
                        finalizePendingLocaleChange: {
                            get() {
                                return ()=>Reflect.apply(x.finalizePendingLocaleChange, x, [])
                            }
                        },
                        waitForPendingLocaleChange: {
                            get() {
                                return ()=>Reflect.apply(x.waitForPendingLocaleChange, x, [])
                            }
                        }
                    }
                }
            }
        });
        const I = {
            __composerExtend: x=>{
                const A = Hs(E);
                x.strategy = A.strategy,
                    x.localeProperties = fe(()=>A.localeProperties.value),
                    x.setLocale = A.setLocale,
                    x.differentDomains = A.differentDomains,
                    x.getBrowserLocale = A.getBrowserLocale,
                    x.getLocaleCookie = A.getLocaleCookie,
                    x.setLocaleCookie = A.setLocaleCookie,
                    x.onBeforeLanguageSwitch = A.onBeforeLanguageSwitch,
                    x.onLanguageSwitched = A.onLanguageSwitched,
                    x.finalizePendingLocaleChange = A.finalizePendingLocaleChange,
                    x.waitForPendingLocaleChange = A.waitForPendingLocaleChange
            }
        };
        s.use(E, I),
            $k(o, E);
        let L = 0;
        ST("locale-changing", async(x,A)=>{
                let k, O;
                const N = Gp(x, e.ssrContext, b, a, ()=>il(E) || S(u), {
                    ssg: "normal",
                    callType: "routing",
                    firstAccess: L === 0
                }, c, oi)
                    , D = P(N)
                    , [W] = ([k,O] = jr(()=>Wp(N, o, E, {
                    useCookie: l,
                    differentDomains: f,
                    initial: D,
                    skipSettingLocaleOnNavigate: d,
                    lazy: h,
                    langDir: y
                })),
                    k = await k,
                    O(),
                    k);
                W && D && (T = !1);
                const G = Xp({
                    to: x,
                    from: A
                }, o, N, b, a);
                return L++,
                    Yp({
                        i18n: E,
                        redirectPath: G,
                        locale: N,
                        route: x
                    }, {
                        differentDomains: f,
                        skipSettingLocaleOnNavigate: d,
                        rootRedirect: g
                    })
            }
            , {
                global: !0
            })
    }
);
function Vk(e={}) {
    const {immediate: t=!1, onNeedRefresh: n, onOfflineReady: r, onRegistered: i, onRegisteredSW: s, onRegisterError: o} = e;
    let a, l;
    const c = async(f=!0)=>{
            await l
        }
    ;
    async function u() {
        if ("serviceWorker"in navigator) {
            const {Workbox: f} = await at(()=>import("./workbox-window.prod.es5.08b2315b.js"), [], import.meta.url);
            a = new f("/sw.js",{
                scope: "/",
                type: "classic"
            }),
                a.addEventListener("activated", d=>{
                        (d.isUpdate || d.isExternal) && window.location.reload()
                    }
                ),
                a.addEventListener("installed", d=>{
                        d.isUpdate || r == null || r()
                    }
                ),
                a.register({
                    immediate: t
                }).then(d=>{
                        s ? s("/sw.js", d) : i == null || i(d)
                    }
                ).catch(d=>{
                        o == null || o(d)
                    }
                )
        }
    }
    return l = u(),
        c
}
function zk(e={}) {
    const {immediate: t=!0, onNeedRefresh: n, onOfflineReady: r, onRegistered: i, onRegisteredSW: s, onRegisterError: o} = e
        , a = X(!1)
        , l = X(!1);
    return {
        updateServiceWorker: Vk({
            immediate: t,
            onNeedRefresh() {
                a.value = !0,
                n == null || n()
            },
            onOfflineReady() {
                l.value = !0,
                r == null || r()
            },
            onRegistered: i,
            onRegisteredSW: s,
            onRegisterError: o
        }),
        offlineReady: l,
        needRefresh: a
    }
}
const Ol = {
    periodicSyncForUpdates: 0
}
    , Uk = dn(()=>{
        const e = X(!1)
            , t = X(!1)
            , n = X(!1)
            , r = X(Ol.installPrompt ? localStorage.getItem(Ol.installPrompt) === "true" : !0)
            , i = navigator.userAgent
            , s = i.match(/iPhone|iPad|iPod/)
            , a = !!(window.matchMedia("(display-mode: standalone)").matches || s && !i.match(/Safari/));
        let l;
        const c = ()=>l
            , {offlineReady: u, needRefresh: f, updateServiceWorker: d} = zk({
                immediate: !0,
                onRegisterError() {
                    e.value = !0
                },
                onRegisteredSW(w, m) {
                    l = m
                }
            })
            , h = async()=>{
                u.value = !1,
                    f.value = !1
            }
        ;
        let y = ()=>Promise.resolve()
            , p = ()=>{}
        ;
        if (!r.value) {
            let w;
            const m = g=>{
                    g.preventDefault(),
                        w = g,
                        n.value = !0
                }
            ;
            window.addEventListener("beforeinstallprompt", m),
                window.addEventListener("appinstalled", ()=>{
                        w = void 0,
                            n.value = !1
                    }
                ),
                p = ()=>{
                    w = void 0,
                        n.value = !1,
                        window.removeEventListener("beforeinstallprompt", m),
                        r.value = !0,
                        localStorage.setItem(Ol.installPrompt, "true")
                }
                ,
                y = async()=>{
                    if (!n.value || !w) {
                        n.value = !1;
                        return
                    }
                    n.value = !1,
                        await ct(),
                        w.prompt(),
                        await w.userChoice
                }
        }
        return {
            provide: {
                pwa: nn({
                    isInstalled: a,
                    showInstallPrompt: n,
                    cancelInstall: p,
                    install: y,
                    swActivated: t,
                    registrationError: e,
                    offlineReady: u,
                    needRefresh: f,
                    updateServiceWorker: d,
                    cancelPrompt: h,
                    getSWRegistration: c
                })
            }
        }
    }
)
    , Wk = "__NUXT_COLOR_MODE__"
    , Gk = "nuxt-color-mode"
    , Bn = window[Wk]
    , Xk = dn(e=>{
        const t = sf("color-mode", ()=>nn({
            preference: Bn.preference,
            value: Bn.value,
            unknown: !1,
            forced: !1
        })).value;
        Jr().afterEach(i=>{
                const s = i.meta.colorMode;
                s && s !== "system" ? (t.value = s,
                    t.forced = !0) : (s === "system" && console.warn("You cannot force the colorMode to system at the page level."),
                    t.forced = !1,
                    t.value = t.preference === "system" ? Bn.getColorScheme() : t.preference)
            }
        );
        let n;
        function r() {
            n || !window.matchMedia || (n = window.matchMedia("(prefers-color-scheme: dark)"),
                n.addEventListener("change", ()=>{
                        !t.forced && t.preference === "system" && (t.value = Bn.getColorScheme())
                    }
                ))
        }
        Se(()=>t.preference, i=>{
                var s;
                t.forced || (i === "system" ? (t.value = Bn.getColorScheme(),
                    r()) : t.value = i,
                (s = window.localStorage) == null || s.setItem(Gk, i))
            }
            , {
                immediate: !0
            }),
            Se(()=>t.value, (i,s)=>{
                    Bn.removeColorScheme(s),
                        Bn.addColorScheme(i)
                }
            ),
        t.preference === "system" && r(),
            e.hook("app:mounted", ()=>{
                    t.unknown && (t.preference = Bn.preference,
                        t.value = Bn.value,
                        t.unknown = !1)
                }
            ),
            e.provide("colorMode", t)
    }
);
const Kk = dn(()=>{}
)
    , Yk = dn({
    name: "nuxt:chunk-reload",
    setup(e) {
        const t = Jr()
            , n = Cr()
            , r = new Set;
        t.beforeEach(()=>{
                r.clear()
            }
        ),
            e.hook("app:chunkError", ({error: i})=>{
                    r.add(i)
                }
            ),
            t.onError((i,s)=>{
                    if (r.has(i)) {
                        const a = "href"in s && s.href.startsWith("#") ? n.app.baseURL + s.href : eo(n.app.baseURL, s.fullPath);
                        U1({
                            path: a,
                            persistState: !0
                        })
                    }
                }
            )
    }
});
function qk(e) {
    return {
        all: e = e || new Map,
        on: function(t, n) {
            var r = e.get(t);
            r ? r.push(n) : e.set(t, [n])
        },
        off: function(t, n) {
            var r = e.get(t);
            r && (n ? r.splice(r.indexOf(n) >>> 0, 1) : e.set(t, []))
        },
        emit: function(t, n) {
            var r = e.get(t);
            r && r.slice().map(function(i) {
                i(n)
            }),
            (r = e.get("*")) && r.slice().map(function(i) {
                i(t, n)
            })
        }
    }
}
const ma = qk()
    , ky = new Map
    , qp = {
        x: ["left", "center", "right"],
        y: ["top", "bottom"]
    }
    , Jk = (e=>()=>e++)(0)
    , Zk = e=>typeof e != "string" ? [] : e.split(/\s+/gi).filter(t=>t)
    , Qk = e=>{
        typeof e == "string" && (e = Zk(e));
        let t = null
            , n = null;
        return e.forEach(r=>{
                qp.y.indexOf(r) !== -1 && (n = r),
                qp.x.indexOf(r) !== -1 && (t = r)
            }
        ),
            {
                x: t,
                y: n
            }
    }
;
class eR {
    constructor(t, n, r) {
        this.remaining = n,
            this.callback = t,
            this.notifyItem = r,
            this.resume()
    }
    pause() {
        clearTimeout(this.notifyItem.timer),
            this.remaining -= Date.now() - this.start
    }
    resume() {
        this.start = Date.now(),
            clearTimeout(this.notifyItem.timer),
            this.notifyItem.timer = setTimeout(this.callback, this.remaining)
    }
}
const Al = {
        position: ["top", "right"],
        cssAnimation: "vn-fade",
        velocityAnimation: {
            enter: e=>({
                height: [e.clientHeight, 0],
                opacity: [1, 0]
            }),
            leave: {
                height: 0,
                opacity: [0, 1]
            }
        }
    }
    , tR = Xe({
        name: "velocity-group",
        emits: ["after-leave", "leave", "enter"],
        methods: {
            enter(e, t) {
                this.$emit("enter", e, t)
            },
            leave(e, t) {
                this.$emit("leave", e, t)
            },
            afterLeave() {
                this.$emit("after-leave")
            }
        }
    })
    , Ef = (e,t)=>{
        const n = e.__vccOpts || e;
        for (const [r,i] of t)
            n[r] = i;
        return n
    }
;
function nR(e, t, n, r, i, s) {
    return Ae(),
        gt(Xu, {
            tag: "span",
            css: !1,
            onEnter: e.enter,
            onLeave: e.leave,
            onAfterLeave: e.afterLeave
        }, {
            default: mt(()=>[Wi(e.$slots, "default")]),
            _: 3
        }, 8, ["onEnter", "onLeave", "onAfterLeave"])
}
const rR = Ef(tR, [["render", nR]])
    , iR = Xe({
    name: "css-group",
    inheritAttrs: !1,
    props: {
        name: {
            type: String,
            required: !0
        }
    }
});
function sR(e, t, n, r, i, s) {
    return Ae(),
        gt(Xu, {
            tag: "span",
            name: e.name
        }, {
            default: mt(()=>[Wi(e.$slots, "default")]),
            _: 3
        }, 8, ["name"])
}
const oR = Ef(iR, [["render", sR]])
    , Il = "[-+]?[0-9]*.?[0-9]+"
    , Jp = [{
    name: "px",
    regexp: new RegExp(`^${Il}px$`)
}, {
    name: "%",
    regexp: new RegExp(`^${Il}%$`)
}, {
    name: "px",
    regexp: new RegExp(`^${Il}$`)
}]
    , aR = e=>{
    if (e === "auto")
        return {
            type: e,
            value: 0
        };
    for (let t = 0; t < Jp.length; t++) {
        const n = Jp[t];
        if (n.regexp.test(e))
            return {
                type: n.name,
                value: parseFloat(e)
            }
    }
    return {
        type: "",
        value: e
    }
}
    , lR = e=>{
    switch (typeof e) {
        case "number":
            return {
                type: "px",
                value: e
            };
        case "string":
            return aR(e);
        default:
            return {
                type: "",
                value: e
            }
    }
}
    , ko = {
    IDLE: 0,
    DESTROYED: 2
}
    , cR = Xe({
    name: "notifications",
    components: {
        VelocityGroup: rR,
        CssGroup: oR
    },
    props: {
        group: {
            type: String,
            default: ""
        },
        width: {
            type: [Number, String],
            default: 300
        },
        reverse: {
            type: Boolean,
            default: !1
        },
        position: {
            type: [String, Array],
            default: Al.position
        },
        classes: {
            type: String,
            default: "vue-notification"
        },
        animationType: {
            type: String,
            default: "css"
        },
        animation: {
            type: Object,
            default: Al.velocityAnimation
        },
        animationName: {
            type: String,
            default: Al.cssAnimation
        },
        speed: {
            type: Number,
            default: 300
        },
        cooldown: {
            type: Number,
            default: 0
        },
        duration: {
            type: Number,
            default: 3e3
        },
        delay: {
            type: Number,
            default: 0
        },
        max: {
            type: Number,
            default: 1 / 0
        },
        ignoreDuplicates: {
            type: Boolean,
            default: !1
        },
        closeOnClick: {
            type: Boolean,
            default: !0
        },
        pauseOnHover: {
            type: Boolean,
            default: !1
        }
    },
    emits: ["click", "destroy", "start"],
    data() {
        return {
            list: [],
            velocity: ky.get("velocity"),
            timerControl: null
        }
    },
    computed: {
        actualWidth() {
            return lR(this.width)
        },
        isVA() {
            return this.animationType === "velocity"
        },
        componentName() {
            return this.isVA ? "velocity-group" : "css-group"
        },
        styles() {
            const {x: e, y: t} = Qk(this.position)
                , n = this.actualWidth.value
                , r = this.actualWidth.type
                , i = {
                width: n + r
            };
            return t && (i[t] = "0px"),
            e && (e === "center" ? i.left = `calc(50% - ${+n / 2}${r})` : i[e] = "0px"),
                i
        },
        active() {
            return this.list.filter(e=>e.state !== ko.DESTROYED)
        },
        botToTop() {
            return this.styles.hasOwnProperty("bottom")
        }
    },
    mounted() {
        ma.on("add", this.addItem),
            ma.on("close", this.closeItem)
    },
    methods: {
        destroyIfNecessary(e) {
            this.$emit("click", e),
            this.closeOnClick && this.destroy(e)
        },
        pauseTimeout() {
            var e;
            this.pauseOnHover && ((e = this.timerControl) == null || e.pause())
        },
        resumeTimeout() {
            var e;
            this.pauseOnHover && ((e = this.timerControl) == null || e.resume())
        },
        addItem(e={}) {
            if (e.group || (e.group = ""),
            e.data || (e.data = {}),
            this.group !== e.group)
                return;
            if (e.clean || e.clear) {
                this.destroyAll();
                return
            }
            const t = typeof e.duration == "number" ? e.duration : this.duration
                , n = typeof e.speed == "number" ? e.speed : this.speed
                , r = typeof e.ignoreDuplicates == "boolean" ? e.ignoreDuplicates : this.ignoreDuplicates
                , {title: i, text: s, type: o, data: a, id: l} = e
                , c = {
                id: l || Jk(),
                title: i,
                text: s,
                type: o,
                state: ko.IDLE,
                speed: n,
                length: t + 2 * n,
                data: a
            };
            t >= 0 && (this.timerControl = new eR(()=>this.destroy(c),c.length,c));
            const u = this.reverse ? !this.botToTop : this.botToTop;
            let f = -1;
            const d = this.active.some(h=>h.title === e.title && h.text === e.text);
            (!r || !d) && (u ? (this.list.push(c),
                this.$emit("start", c),
            this.active.length > this.max && (f = 0)) : (this.list.unshift(c),
                this.$emit("start", c),
            this.active.length > this.max && (f = this.active.length - 1)),
            f !== -1 && this.destroy(this.active[f]))
        },
        closeItem(e) {
            this.destroyById(e)
        },
        notifyClass(e) {
            return ["vue-notification-template", this.classes, e.type || ""]
        },
        notifyWrapperStyle(e) {
            return this.isVA ? void 0 : {
                transition: `all ${e.speed}ms`
            }
        },
        destroy(e) {
            clearTimeout(e.timer),
                e.state = ko.DESTROYED,
                this.clean(),
                this.$emit("destroy", e)
        },
        destroyById(e) {
            const t = this.list.find(n=>n.id === e);
            t && this.destroy(t)
        },
        destroyAll() {
            this.active.forEach(this.destroy)
        },
        getAnimation(e, t) {
            var n;
            const r = (n = this.animation) == null ? void 0 : n[e];
            return typeof r == "function" ? r.call(this, t) : r
        },
        enter(e, t) {
            if (!this.isVA)
                return;
            const n = this.getAnimation("enter", e);
            this.velocity(e, n, {
                duration: this.speed,
                complete: t
            })
        },
        leave(e, t) {
            if (!this.isVA)
                return;
            const n = this.getAnimation("leave", e);
            this.velocity(e, n, {
                duration: this.speed,
                complete: t
            })
        },
        clean() {
            this.list = this.list.filter(e=>e.state !== ko.DESTROYED)
        }
    }
})
    , uR = ["data-id"]
    , fR = ["onClick"]
    , dR = ["innerHTML"]
    , pR = ["innerHTML"];
function hR(e, t, n, r, i, s) {
    return Ae(),
        Qe("div", {
            class: "vue-notification-group",
            style: Br(e.styles)
        }, [(Ae(),
            gt($u(e.componentName), {
                name: e.animationName,
                onEnter: e.enter,
                onLeave: e.leave,
                onAfterLeave: e.clean
            }, {
                default: mt(()=>[(Ae(!0),
                    Qe(nt, null, ju(e.active, o=>(Ae(),
                        Qe("div", {
                            key: o.id,
                            class: "vue-notification-wrapper",
                            style: Br(e.notifyWrapperStyle(o)),
                            "data-id": o.id,
                            onMouseenter: t[0] || (t[0] = (...a)=>e.pauseTimeout && e.pauseTimeout(...a)),
                            onMouseleave: t[1] || (t[1] = (...a)=>e.resumeTimeout && e.resumeTimeout(...a))
                        }, [Wi(e.$slots, "body", {
                            class: Pt([e.classes, o.type]),
                            item: o,
                            close: ()=>e.destroy(o)
                        }, ()=>[Te("div", {
                            class: Pt(e.notifyClass(o)),
                            onClick: a=>e.destroyIfNecessary(o)
                        }, [o.title ? (Ae(),
                            Qe("div", {
                                key: 0,
                                class: "notification-title",
                                innerHTML: o.title
                            }, null, 8, dR)) : Wt("", !0), Te("div", {
                            class: "notification-content",
                            innerHTML: o.text
                        }, null, 8, pR)], 10, fR)])], 44, uR))), 128))]),
                _: 3
            }, 40, ["name", "onEnter", "onLeave", "onAfterLeave"]))], 4)
}
const mR = Ef(cR, [["render", hR]])
    , Cf = e=>{
        typeof e == "string" && (e = {
            title: "",
            text: e
        }),
        typeof e == "object" && ma.emit("add", e)
    }
;
Cf.close = e=>{
    ma.emit("close", e)
}
;
const Tf = ()=>({
    notify: Cf
});
function gR(e, t={}) {
    Object.entries(t).forEach(r=>ky.set(...r));
    const n = t.name || "notify";
    e.config.globalProperties["$" + n] = Cf,
        e.component(t.componentName || "Notifications", mR)
}
const vR = {
    install: gR
};
(function() {
        var e;
        try {
            if (typeof document < "u") {
                var t = document.createElement("style");
                t.nonce = (e = document.head.querySelector("meta[property=csp-nonce]")) == null ? void 0 : e.content,
                    t.appendChild(document.createTextNode(".vue-notification-group{display:block;position:fixed;z-index:5000}.vue-notification-wrapper{display:block;overflow:hidden;width:100%;margin:0;padding:0}.notification-title{font-weight:600}.vue-notification-template{display:block;box-sizing:border-box;background:white;text-align:left}.vue-notification{display:block;box-sizing:border-box;text-align:left;font-size:12px;padding:10px;margin:0 5px 5px;color:#fff;background:#44A4FC;border-left:5px solid #187FE7}.vue-notification.warn{background:#ffb648;border-left-color:#f48a06}.vue-notification.error{background:#E54D42;border-left-color:#b82e24}.vue-notification.success{background:#68CD86;border-left-color:#42a85f}.vn-fade-enter-active,.vn-fade-leave-active,.vn-fade-move{transition:all .5s}.vn-fade-enter-from,.vn-fade-leave-to{opacity:0}")),
                    document.head.appendChild(t)
            }
        } catch (n) {
            console.error("vite-plugin-css-injected-by-js", n)
        }
    }
)();
const yR = dn(e=>{
        e.vueApp.use(vR)
    }
)
    , bR = [TT, M1, D1, N1, $1, W1, Bk, Uk, Xk, Kk, Yk, yR]
    , wR = (e,t)=>t.path.replace(/(:\w+)\([^)]+\)/g, "$1").replace(/(:\w+)[?+*]/g, "$1").replace(/:\w+/g, n=>{
        var r;
        return ((r = e.params[n.slice(1)]) == null ? void 0 : r.toString()) || ""
    }
)
    , Kc = (e,t)=>{
    const n = e.route.matched.find(i=>{
            var s;
            return ((s = i.components) == null ? void 0 : s.default) === e.Component.type
        }
    )
        , r = t ?? (n == null ? void 0 : n.meta.key) ?? (n && wR(e.route, n));
    return typeof r == "function" ? r(e.route) : r
}
    , SR = (e,t)=>({
    default: ()=>e ? yt(sg, e === !0 ? {} : e, t) : t
})
    , _R = Xe({
    name: "RouteProvider",
    props: {
        vnode: {
            type: Object,
            required: !0
        },
        route: {
            type: Object,
            required: !0
        },
        vnodeRef: Object,
        renderKey: String,
        trackRootNodes: Boolean
    },
    setup(e) {
        const t = e.renderKey
            , n = e.route
            , r = {};
        for (const i in e.route)
            Object.defineProperty(r, i, {
                get: ()=>t === e.renderKey ? e.route[i] : n[i]
            });
        return Dn(to, Ui(r)),
            ()=>yt(e.vnode, {
                ref: e.vnodeRef
            })
    }
})
    , Ry = (e,t,n)=>(t = t === !0 ? {} : t,
    {
        default: ()=>{
            var r;
            return t ? yt(e, t, n) : (r = n.default) == null ? void 0 : r.call(n)
        }
    })
    , ER = Xe({
    name: "NuxtPage",
    inheritAttrs: !1,
    props: {
        name: {
            type: String
        },
        transition: {
            type: [Boolean, Object],
            default: void 0
        },
        keepalive: {
            type: [Boolean, Object],
            default: void 0
        },
        route: {
            type: Object
        },
        pageKey: {
            type: [Function, String],
            default: null
        }
    },
    setup(e, {attrs: t, expose: n}) {
        const r = pt()
            , i = X()
            , s = vt(to, null);
        n({
            pageRef: i
        });
        const o = vt(Ov, null);
        let a;
        const l = r.deferHydration();
        return ()=>yt(Uv, {
            name: e.name,
            route: e.route,
            ...t
        }, {
            default: c=>{
                const u = xR(s, c.route, c.Component)
                    , f = s && s.matched.length === c.route.matched.length;
                if (!c.Component)
                    return a && !f ? a : void 0;
                if (a && o && !o.isCurrent(c.route))
                    return a;
                if (u && s && (!o || o != null && o.isCurrent(s)))
                    return f ? a : null;
                const d = Kc(c, e.pageKey)
                    , h = !!(e.transition ?? c.route.meta.pageTransition ?? _c)
                    , y = h && TR([e.transition, c.route.meta.pageTransition, _c, {
                    onAfterLeave: ()=>{
                        r.callHook("page:transition:finish", c.Component)
                    }
                }].filter(Boolean));
                return a = Ry(Ur, h && y, SR(e.keepalive ?? c.route.meta.keepalive ?? sT, yt(ja, {
                    suspensible: !0,
                    onPending: ()=>r.callHook("page:start", c.Component),
                    onResolve: ()=>{
                        ct(()=>r.callHook("page:finish", c.Component).finally(l))
                    }
                }, {
                    default: ()=>yt(_R, {
                        key: d,
                        vnode: c.Component,
                        route: c.route,
                        renderKey: d,
                        trackRootNodes: h,
                        vnodeRef: i
                    })
                }))).default(),
                    a
            }
        })
    }
});
function CR(e) {
    return Array.isArray(e) ? e : e ? [e] : []
}
function TR(e) {
    const t = e.map(n=>({
        ...n,
        onAfterLeave: CR(n.onAfterLeave)
    }));
    return vT(...t)
}
function xR(e, t, n) {
    if (!e)
        return !1;
    const r = t.matched.findIndex(i=>{
            var s;
            return ((s = i.components) == null ? void 0 : s.default) === (n == null ? void 0 : n.type)
        }
    );
    return !r || r === -1 ? !1 : t.matched.slice(0, r).some((i,s)=>{
            var o, a, l;
            return ((o = i.components) == null ? void 0 : o.default) !== ((l = (a = e.matched[s]) == null ? void 0 : a.components) == null ? void 0 : l.default)
        }
    ) || n && Kc({
        route: t,
        Component: n
    }) !== Kc({
        route: e,
        Component: n
    })
}
const PR = Xe({
    name: "LayoutLoader",
    inheritAttrs: !1,
    props: {
        name: String,
        layoutProps: Object
    },
    async setup(e, t) {
        const n = await Mr[e.name]().then(r=>r.default || r);
        return ()=>yt(n, e.layoutProps, t.slots)
    }
})
    , kR = Xe({
    name: "NuxtLayout",
    inheritAttrs: !1,
    props: {
        name: {
            type: [String, Boolean, Object],
            default: null
        }
    },
    setup(e, t) {
        const n = pt()
            , r = vt(to)
            , i = r === of() ? uf() : r
            , s = fe(()=>we(e.name) ?? i.meta.layout ?? "default")
            , o = X();
        t.expose({
            layoutRef: o
        });
        const a = n.deferHydration();
        return ()=>{
            const l = s.value && s.value in Mr
                , c = i.meta.layoutTransition ?? iT;
            return Ry(Ur, l && c, {
                default: ()=>yt(ja, {
                    suspensible: !0,
                    onResolve: ()=>{
                        ct(a)
                    }
                }, {
                    default: ()=>yt(RR, {
                        layoutProps: Wu(t.attrs, {
                            ref: o
                        }),
                        key: s.value,
                        name: s.value,
                        shouldProvide: !e.name,
                        hasTransition: !!c
                    }, t.slots)
                })
            }).default()
        }
    }
})
    , RR = Xe({
    name: "NuxtLayoutProvider",
    inheritAttrs: !1,
    props: {
        name: {
            type: [String, Boolean]
        },
        layoutProps: {
            type: Object
        },
        hasTransition: {
            type: Boolean
        },
        shouldProvide: {
            type: Boolean
        }
    },
    setup(e, t) {
        const n = e.name;
        return e.shouldProvide && Dn(Ov, {
            isCurrent: r=>n === (r.meta.layout ?? "default")
        }),
            ()=>{
                var r, i;
                return !n || typeof n == "string" && !(n in Mr) ? (i = (r = t.slots).default) == null ? void 0 : i.call(r) : yt(PR, {
                    key: n,
                    layoutProps: e.layoutProps,
                    name: n
                }, t.slots)
            }
    }
})
    , LR = Xe({
    __name: "flag",
    props: {
        country: {
            type: String,
            default: "un"
        }
    },
    setup(e) {
        const t = e
            , n = fe(()=>"flag-icon-" + t.country.toLowerCase());
        return (r,i)=>(Ae(),
            Qe("span", {
                class: Pt([we(n), "flag-icon"])
            }, null, 2))
    }
});
function OR(e, t) {
    let n, r, i;
    const s = X(!0)
        , o = ()=>{
            s.value = !0,
                i()
        }
    ;
    Se(e, o, {
        flush: "sync"
    });
    const a = typeof t == "function" ? t : t.get
        , l = typeof t == "function" ? void 0 : t.set
        , c = Gm((u,f)=>(r = u,
        i = f,
        {
            get() {
                return s.value && (n = a(),
                    s.value = !1),
                    r(),
                    n
            },
            set(d) {
                l == null || l(d)
            }
        }));
    return Object.isExtensible(c) && (c.trigger = o),
        c
}
function sn(e) {
    return Su() ? (Am(e),
        !0) : !1
}
function AR() {
    const e = new Set
        , t = i=>{
            e.delete(i)
        }
    ;
    return {
        on: i=>{
            e.add(i);
            const s = ()=>t(i);
            return sn(s),
                {
                    off: s
                }
        }
        ,
        off: t,
        trigger: i=>Promise.all(Array.from(e).map(s=>s(i)))
    }
}
function At(e) {
    let t = !1, n;
    const r = La(!0);
    return (...i)=>(t || (n = r.run(()=>e(...i)),
        t = !0),
        n)
}
function $t(e) {
    return typeof e == "function" ? e() : we(e)
}
const Wr = typeof window < "u"
    , Zp = ()=>+Date.now()
    , Fi = ()=>{}
    , IR = (e,t)=>Object.prototype.hasOwnProperty.call(e, t);
function al(e, t) {
    function n(...r) {
        return new Promise((i,s)=>{
                Promise.resolve(e(()=>t.apply(this, r), {
                    fn: t,
                    thisArg: this,
                    args: r
                })).then(i).catch(s)
            }
        )
    }
    return n
}
const Ly = e=>e();
function Oy(e, t={}) {
    let n, r, i = Fi;
    const s = a=>{
            clearTimeout(a),
                i(),
                i = Fi
        }
    ;
    return a=>{
        const l = $t(e)
            , c = $t(t.maxWait);
        return n && s(n),
            l <= 0 || c !== void 0 && c <= 0 ? (r && (s(r),
                r = null),
                Promise.resolve(a())) : new Promise((u,f)=>{
                    i = t.rejectOnCancel ? f : u,
                    c && !r && (r = setTimeout(()=>{
                            n && s(n),
                                r = null,
                                u(a())
                        }
                        , c)),
                        n = setTimeout(()=>{
                                r && s(r),
                                    r = null,
                                    u(a())
                            }
                            , l)
                }
            )
    }
}
function xf(e, t=!0, n=!0, r=!1) {
    let i = 0, s, o = !0, a = Fi, l;
    const c = ()=>{
            s && (clearTimeout(s),
                s = void 0,
                a(),
                a = Fi)
        }
    ;
    return f=>{
        const d = $t(e)
            , h = Date.now() - i
            , y = ()=>l = f();
        return c(),
            d <= 0 ? (i = Date.now(),
                y()) : (h > d && (n || !o) ? (i = Date.now(),
                y()) : t && (l = new Promise((p,w)=>{
                    a = r ? w : p,
                        s = setTimeout(()=>{
                                i = Date.now(),
                                    o = !0,
                                    p(y()),
                                    c()
                            }
                            , Math.max(0, d - h))
                }
            )),
            !n && !s && (s = setTimeout(()=>o = !0, d)),
                o = !1,
                l)
    }
}
function MR(e=Ly) {
    const t = X(!0);
    function n() {
        t.value = !1
    }
    function r() {
        t.value = !0
    }
    const i = (...s)=>{
            t.value && e(...s)
        }
    ;
    return {
        isActive: _r(t),
        pause: n,
        resume: r,
        eventFilter: i
    }
}
function DR(e) {
    let t;
    function n() {
        return t || (t = e()),
            t
    }
    return n.reset = async()=>{
        const r = t;
        t = void 0,
        r && await r
    }
        ,
        n
}
function Ay(e, t=200, n={}) {
    return al(Oy(t, n), e)
}
function NR(e, t=200, n={}) {
    const r = X(e.value)
        , i = Ay(()=>{
            r.value = e.value
        }
        , t, n);
    return Se(e, ()=>i()),
        r
}
function $R(e, t=200, n=!1, r=!0, i=!1) {
    return al(xf(t, n, r, i), e)
}
function FR(e, t=200, n=!0, r=!0) {
    if (t <= 0)
        return e;
    const i = X(e.value)
        , s = $R(()=>{
            i.value = e.value
        }
        , t, n, r);
    return Se(e, ()=>s()),
        i
}
function Iy(e, t=!0) {
    Ot() ? Ve(e) : t ? e() : ct(e)
}
function Pf(e, t=1e3, n={}) {
    const {immediate: r=!0, immediateCallback: i=!1} = n;
    let s = null;
    const o = X(!1);
    function a() {
        s && (clearInterval(s),
            s = null)
    }
    function l() {
        o.value = !1,
            a()
    }
    function c() {
        const u = $t(t);
        u <= 0 || (o.value = !0,
        i && e(),
            a(),
            s = setInterval(e, u))
    }
    if (r && Wr && c(),
    Je(t) || typeof t == "function") {
        const u = Se(t, ()=>{
                o.value && Wr && c()
            }
        );
        sn(u)
    }
    return sn(l),
        {
            isActive: o,
            pause: l,
            resume: c
        }
}
var jR = Object.defineProperty
    , Qp = Object.getOwnPropertySymbols
    , HR = Object.prototype.hasOwnProperty
    , BR = Object.prototype.propertyIsEnumerable
    , eh = (e,t,n)=>t in e ? jR(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n
    , VR = (e,t)=>{
        for (var n in t || (t = {}))
            HR.call(t, n) && eh(e, n, t[n]);
        if (Qp)
            for (var n of Qp(t))
                BR.call(t, n) && eh(e, n, t[n]);
        return e
    }
;
function zR(e=1e3, t={}) {
    const {controls: n=!1, immediate: r=!0, callback: i} = t
        , s = X(0)
        , o = ()=>s.value += 1
        , a = ()=>{
        s.value = 0
    }
        , l = Pf(i ? ()=>{
            o(),
                i(s.value)
        }
        : o, e, {
        immediate: r
    });
    return n ? VR({
        counter: s,
        reset: a
    }, l) : s
}
function UR(e, t, n={}) {
    const {immediate: r=!0} = n
        , i = X(!1);
    let s = null;
    function o() {
        s && (clearTimeout(s),
            s = null)
    }
    function a() {
        i.value = !1,
            o()
    }
    function l(...c) {
        o(),
            i.value = !0,
            s = setTimeout(()=>{
                    i.value = !1,
                        s = null,
                        e(...c)
                }
                , $t(t))
    }
    return r && (i.value = !0,
    Wr && l()),
        sn(a),
        {
            isPending: _r(i),
            start: l,
            stop: a
        }
}
var WR = Object.defineProperty
    , th = Object.getOwnPropertySymbols
    , GR = Object.prototype.hasOwnProperty
    , XR = Object.prototype.propertyIsEnumerable
    , nh = (e,t,n)=>t in e ? WR(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n
    , KR = (e,t)=>{
        for (var n in t || (t = {}))
            GR.call(t, n) && nh(e, n, t[n]);
        if (th)
            for (var n of th(t))
                XR.call(t, n) && nh(e, n, t[n]);
        return e
    }
;
function YR(e=1e3, t={}) {
    const {controls: n=!1, callback: r} = t
        , i = UR(r ?? Fi, e, t)
        , s = fe(()=>!i.isPending.value);
    return n ? KR({
        ready: s
    }, i) : s
}
var rh = Object.getOwnPropertySymbols
    , qR = Object.prototype.hasOwnProperty
    , JR = Object.prototype.propertyIsEnumerable
    , ZR = (e,t)=>{
        var n = {};
        for (var r in e)
            qR.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
        if (e != null && rh)
            for (var r of rh(e))
                t.indexOf(r) < 0 && JR.call(e, r) && (n[r] = e[r]);
        return n
    }
;
function kf(e, t, n={}) {
    const r = n
        , {eventFilter: i=Ly} = r
        , s = ZR(r, ["eventFilter"]);
    return Se(e, al(i, t), s)
}
var QR = Object.defineProperty
    , eL = Object.defineProperties
    , tL = Object.getOwnPropertyDescriptors
    , ga = Object.getOwnPropertySymbols
    , My = Object.prototype.hasOwnProperty
    , Dy = Object.prototype.propertyIsEnumerable
    , ih = (e,t,n)=>t in e ? QR(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n
    , nL = (e,t)=>{
        for (var n in t || (t = {}))
            My.call(t, n) && ih(e, n, t[n]);
        if (ga)
            for (var n of ga(t))
                Dy.call(t, n) && ih(e, n, t[n]);
        return e
    }
    , rL = (e,t)=>eL(e, tL(t))
    , iL = (e,t)=>{
        var n = {};
        for (var r in e)
            My.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
        if (e != null && ga)
            for (var r of ga(e))
                t.indexOf(r) < 0 && Dy.call(e, r) && (n[r] = e[r]);
        return n
    }
;
function Xi(e, t, n={}) {
    const r = n
        , {debounce: i=0, maxWait: s=void 0} = r
        , o = iL(r, ["debounce", "maxWait"]);
    return kf(e, t, rL(nL({}, o), {
        eventFilter: Oy(i, {
            maxWait: s
        })
    }))
}
var sL = Object.defineProperty
    , oL = Object.defineProperties
    , aL = Object.getOwnPropertyDescriptors
    , sh = Object.getOwnPropertySymbols
    , lL = Object.prototype.hasOwnProperty
    , cL = Object.prototype.propertyIsEnumerable
    , oh = (e,t,n)=>t in e ? sL(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
}) : e[t] = n
    , uL = (e,t)=>{
    for (var n in t || (t = {}))
        lL.call(t, n) && oh(e, n, t[n]);
    if (sh)
        for (var n of sh(t))
            cL.call(t, n) && oh(e, n, t[n]);
    return e
}
    , fL = (e,t)=>oL(e, aL(t));
function dL(e, t, n) {
    return Se(e, t, fL(uL({}, n), {
        deep: !0
    }))
}
var pL = Object.defineProperty
    , hL = Object.defineProperties
    , mL = Object.getOwnPropertyDescriptors
    , va = Object.getOwnPropertySymbols
    , Ny = Object.prototype.hasOwnProperty
    , $y = Object.prototype.propertyIsEnumerable
    , ah = (e,t,n)=>t in e ? pL(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n
    , gL = (e,t)=>{
        for (var n in t || (t = {}))
            Ny.call(t, n) && ah(e, n, t[n]);
        if (va)
            for (var n of va(t))
                $y.call(t, n) && ah(e, n, t[n]);
        return e
    }
    , vL = (e,t)=>hL(e, mL(t))
    , yL = (e,t)=>{
        var n = {};
        for (var r in e)
            Ny.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
        if (e != null && va)
            for (var r of va(e))
                t.indexOf(r) < 0 && $y.call(e, r) && (n[r] = e[r]);
        return n
    }
;
function Fy(e, t, n={}) {
    const r = n
        , {eventFilter: i} = r
        , s = yL(r, ["eventFilter"])
        , {eventFilter: o, pause: a, resume: l, isActive: c} = MR(i);
    return {
        stop: kf(e, t, vL(gL({}, s), {
            eventFilter: o
        })),
        pause: a,
        resume: l,
        isActive: c
    }
}
var bL = Object.defineProperty
    , wL = Object.defineProperties
    , SL = Object.getOwnPropertyDescriptors
    , ya = Object.getOwnPropertySymbols
    , jy = Object.prototype.hasOwnProperty
    , Hy = Object.prototype.propertyIsEnumerable
    , lh = (e,t,n)=>t in e ? bL(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n
    , _L = (e,t)=>{
        for (var n in t || (t = {}))
            jy.call(t, n) && lh(e, n, t[n]);
        if (ya)
            for (var n of ya(t))
                Hy.call(t, n) && lh(e, n, t[n]);
        return e
    }
    , EL = (e,t)=>wL(e, SL(t))
    , CL = (e,t)=>{
        var n = {};
        for (var r in e)
            jy.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
        if (e != null && ya)
            for (var r of ya(e))
                t.indexOf(r) < 0 && Hy.call(e, r) && (n[r] = e[r]);
        return n
    }
;
function TL(e, t, n={}) {
    const r = n
        , {throttle: i=0, trailing: s=!0, leading: o=!0} = r
        , a = CL(r, ["throttle", "trailing", "leading"]);
    return kf(e, t, EL(_L({}, a), {
        eventFilter: xf(i, s, o)
    }))
}
function En(e) {
    var t;
    const n = $t(e);
    return (t = n == null ? void 0 : n.$el) != null ? t : n
}
const Lt = Wr ? window : void 0
    , ll = Wr ? window.document : void 0
    , Rf = Wr ? window.navigator : void 0;
function Ft(...e) {
    let t, n, r, i;
    if (typeof e[0] == "string" || Array.isArray(e[0]) ? ([n,r,i] = e,
        t = Lt) : [t,n,r,i] = e,
        !t)
        return Fi;
    Array.isArray(n) || (n = [n]),
    Array.isArray(r) || (r = [r]);
    const s = []
        , o = ()=>{
            s.forEach(u=>u()),
                s.length = 0
        }
        , a = (u,f,d,h)=>(u.addEventListener(f, d, h),
            ()=>u.removeEventListener(f, d, h))
        , l = Se(()=>[En(t), $t(i)], ([u,f])=>{
                o(),
                u && s.push(...n.flatMap(d=>r.map(h=>a(u, d, h, f))))
            }
            , {
                immediate: !0,
                flush: "post"
            })
        , c = ()=>{
            l(),
                o()
        }
    ;
    return sn(c),
        c
}
function xL(e) {
    return typeof e == "function" ? e : typeof e == "string" ? t=>t.key === e : Array.isArray(e) ? t=>e.includes(t.key) : ()=>!0
}
function li(...e) {
    let t, n, r = {};
    e.length === 3 ? (t = e[0],
        n = e[1],
        r = e[2]) : e.length === 2 ? typeof e[1] == "object" ? (t = !0,
        n = e[0],
        r = e[1]) : (t = e[0],
        n = e[1]) : (t = !0,
        n = e[0]);
    const {target: i=Lt, eventName: s="keydown", passive: o=!1, dedupe: a=!1} = r
        , l = xL(t);
    return Ft(i, s, u=>{
            u.repeat && $t(a) || l(u) && n(u)
        }
        , o)
}
function PL(e={}) {
    var t;
    const {window: n=Lt, deep: r=!0} = e
        , i = (t = e.document) != null ? t : n == null ? void 0 : n.document
        , s = ()=>{
        var a;
        let l = i == null ? void 0 : i.activeElement;
        if (r)
            for (; l != null && l.shadowRoot; )
                l = (a = l == null ? void 0 : l.shadowRoot) == null ? void 0 : a.activeElement;
        return l
    }
        , o = OR(()=>null, ()=>s());
    return n && (Ft(n, "blur", a=>{
            a.relatedTarget === null && o.trigger()
        }
        , !0),
        Ft(n, "focus", o.trigger, !0)),
        o
}
function kL() {
    const e = X(!1);
    return Ot() && Ve(()=>{
            e.value = !0
        }
    ),
        e
}
function ei(e) {
    const t = kL();
    return fe(()=>(t.value,
        !!e()))
}
function RL(e, t={}) {
    const {immediate: n=!0, window: r=Lt} = t
        , i = X(!1);
    let s = 0
        , o = null;
    function a(u) {
        if (!i.value || !r)
            return;
        const f = u - (s || u);
        e({
            delta: f,
            timestamp: u
        }),
            s = u,
            o = r.requestAnimationFrame(a)
    }
    function l() {
        !i.value && r && (i.value = !0,
            o = r.requestAnimationFrame(a))
    }
    function c() {
        i.value = !1,
        o != null && r && (r.cancelAnimationFrame(o),
            o = null)
    }
    return n && l(),
        sn(c),
        {
            isActive: _r(i),
            pause: c,
            resume: l
        }
}
function By(e, t={}) {
    const {window: n=Lt} = t
        , r = ei(()=>n && "matchMedia"in n && typeof n.matchMedia == "function");
    let i;
    const s = X(!1)
        , o = c=>{
        s.value = c.matches
    }
        , a = ()=>{
        i && ("removeEventListener"in i ? i.removeEventListener("change", o) : i.removeListener(o))
    }
        , l = Er(()=>{
            r.value && (a(),
                i = n.matchMedia($t(e)),
                "addEventListener"in i ? i.addEventListener("change", o) : i.addListener(o),
                s.value = i.matches)
        }
    );
    return sn(()=>{
            l(),
                a(),
                i = void 0
        }
    ),
        s
}
const Ro = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}
    , Lo = "__vueuse_ssr_handlers__"
    , LL = OL();
function OL() {
    return Lo in Ro || (Ro[Lo] = Ro[Lo] || {}),
        Ro[Lo]
}
function AL(e, t) {
    return LL[e] || t
}
function IL(e) {
    return e == null ? "any" : e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof Date ? "date" : typeof e == "boolean" ? "boolean" : typeof e == "string" ? "string" : typeof e == "object" ? "object" : Number.isNaN(e) ? "any" : "number"
}
var ML = Object.defineProperty
    , ch = Object.getOwnPropertySymbols
    , DL = Object.prototype.hasOwnProperty
    , NL = Object.prototype.propertyIsEnumerable
    , uh = (e,t,n)=>t in e ? ML(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n
    , fh = (e,t)=>{
        for (var n in t || (t = {}))
            DL.call(t, n) && uh(e, n, t[n]);
        if (ch)
            for (var n of ch(t))
                NL.call(t, n) && uh(e, n, t[n]);
        return e
    }
;
const $L = {
    boolean: {
        read: e=>e === "true",
        write: e=>String(e)
    },
    object: {
        read: e=>JSON.parse(e),
        write: e=>JSON.stringify(e)
    },
    number: {
        read: e=>Number.parseFloat(e),
        write: e=>String(e)
    },
    any: {
        read: e=>e,
        write: e=>String(e)
    },
    string: {
        read: e=>e,
        write: e=>String(e)
    },
    map: {
        read: e=>new Map(JSON.parse(e)),
        write: e=>JSON.stringify(Array.from(e.entries()))
    },
    set: {
        read: e=>new Set(JSON.parse(e)),
        write: e=>JSON.stringify(Array.from(e))
    },
    date: {
        read: e=>new Date(e),
        write: e=>e.toISOString()
    }
}
    , dh = "vueuse-storage";
function Vy(e, t, n, r={}) {
    var i;
    const {flush: s="pre", deep: o=!0, listenToStorageChanges: a=!0, writeDefaults: l=!0, mergeDefaults: c=!1, shallow: u, window: f=Lt, eventFilter: d, onError: h=T=>{
        console.error(T)
    }
    } = r
        , y = (u ? gr : X)(t);
    if (!n)
        try {
            n = AL("getDefaultStorage", ()=>{
                    var T;
                    return (T = Lt) == null ? void 0 : T.localStorage
                }
            )()
        } catch (T) {
            h(T)
        }
    if (!n)
        return y;
    const p = $t(t)
        , w = IL(p)
        , m = (i = r.serializer) != null ? i : $L[w]
        , {pause: g, resume: b} = Fy(y, ()=>v(y.value), {
        flush: s,
        deep: o,
        eventFilter: d
    });
    return f && a && (Ft(f, "storage", E),
        Ft(f, dh, _)),
        E(),
        y;
    function v(T) {
        try {
            if (T == null)
                n.removeItem(e);
            else {
                const P = m.write(T)
                    , I = n.getItem(e);
                I !== P && (n.setItem(e, P),
                f && f.dispatchEvent(new CustomEvent(dh,{
                    detail: {
                        key: e,
                        oldValue: I,
                        newValue: P,
                        storageArea: n
                    }
                })))
            }
        } catch (P) {
            h(P)
        }
    }
    function S(T) {
        const P = T ? T.newValue : n.getItem(e);
        if (P == null)
            return l && p !== null && n.setItem(e, m.write(p)),
                p;
        if (!T && c) {
            const I = m.read(P);
            return typeof c == "function" ? c(I, p) : w === "object" && !Array.isArray(I) ? fh(fh({}, p), I) : I
        } else
            return typeof P != "string" ? P : m.read(P)
    }
    function _(T) {
        E(T.detail)
    }
    function E(T) {
        if (!(T && T.storageArea !== n)) {
            if (T && T.key == null) {
                y.value = p;
                return
            }
            if (!(T && T.key !== e)) {
                g();
                try {
                    y.value = S(T)
                } catch (P) {
                    h(P)
                } finally {
                    T ? ct(b) : b()
                }
            }
        }
    }
}
var ph = Object.getOwnPropertySymbols
    , FL = Object.prototype.hasOwnProperty
    , jL = Object.prototype.propertyIsEnumerable
    , HL = (e,t)=>{
        var n = {};
        for (var r in e)
            FL.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
        if (e != null && ph)
            for (var r of ph(e))
                t.indexOf(r) < 0 && jL.call(e, r) && (n[r] = e[r]);
        return n
    }
;
function BL(e, t, n={}) {
    const r = n
        , {window: i=Lt} = r
        , s = HL(r, ["window"]);
    let o;
    const a = ei(()=>i && "MutationObserver"in i)
        , l = ()=>{
            o && (o.disconnect(),
                o = void 0)
        }
        , c = Se(()=>En(e), f=>{
                l(),
                a.value && i && f && (o = new MutationObserver(t),
                    o.observe(f, s))
            }
            , {
                immediate: !0
            })
        , u = ()=>{
            l(),
                c()
        }
    ;
    return sn(u),
        {
            isSupported: a,
            stop: u
        }
}
function ts(e, t, n={}) {
    const {window: r=Lt, initialValue: i="", observe: s=!1} = n
        , o = X(i)
        , a = fe(()=>{
            var c;
            return En(t) || ((c = r == null ? void 0 : r.document) == null ? void 0 : c.documentElement)
        }
    );
    function l() {
        var c;
        const u = $t(e)
            , f = $t(a);
        if (f && r) {
            const d = (c = r.getComputedStyle(f).getPropertyValue(u)) == null ? void 0 : c.trim();
            o.value = d || i
        }
    }
    return s && BL(a, l, {
        attributeFilter: ["style", "class"],
        window: r
    }),
        Se([a, ()=>$t(e)], l, {
            immediate: !0
        }),
        Se(o, c=>{
                var u;
                (u = a.value) != null && u.style && a.value.style.setProperty($t(e), c)
            }
        ),
        o
}
function VL(e, t={}) {
    const {controls: n=!1, navigator: r=Rf} = t
        , i = ei(()=>r && "permissions"in r);
    let s;
    const o = typeof e == "string" ? {
        name: e
    } : e
        , a = X()
        , l = ()=>{
        s && (a.value = s.state)
    }
        , c = DR(async()=>{
            if (i.value) {
                if (!s)
                    try {
                        s = await r.permissions.query(o),
                            Ft(s, "change", l),
                            l()
                    } catch {
                        a.value = "prompt"
                    }
                return s
            }
        }
    );
    return c(),
        n ? {
            state: a,
            isSupported: i,
            query: c
        } : a
}
function zL(e={}) {
    const {navigator: t=Rf, requestPermissions: n=!1, constraints: r={
        audio: !0,
        video: !0
    }, onUpdated: i} = e
        , s = X([])
        , o = fe(()=>s.value.filter(y=>y.kind === "videoinput"))
        , a = fe(()=>s.value.filter(y=>y.kind === "audioinput"))
        , l = fe(()=>s.value.filter(y=>y.kind === "audiooutput"))
        , c = ei(()=>t && t.mediaDevices && t.mediaDevices.enumerateDevices)
        , u = X(!1);
    let f;
    async function d() {
        c.value && (s.value = await t.mediaDevices.enumerateDevices(),
        i == null || i(s.value),
        f && (f.getTracks().forEach(y=>y.stop()),
            f = null))
    }
    async function h() {
        if (!c.value)
            return !1;
        if (u.value)
            return !0;
        const {state: y, query: p} = VL("camera", {
            controls: !0
        });
        return await p(),
        y.value !== "granted" && (f = await t.mediaDevices.getUserMedia(c),
            d()),
            u.value = !0,
            u.value
    }
    return c.value && (n && h(),
        Ft(t.mediaDevices, "devicechange", d),
        d()),
        {
            devices: s,
            ensurePermissions: h,
            permissionGranted: u,
            videoInputs: o,
            audioInputs: a,
            audioOutputs: l,
            isSupported: c
        }
}
var hh = Object.getOwnPropertySymbols
    , UL = Object.prototype.hasOwnProperty
    , WL = Object.prototype.propertyIsEnumerable
    , GL = (e,t)=>{
        var n = {};
        for (var r in e)
            UL.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
        if (e != null && hh)
            for (var r of hh(e))
                t.indexOf(r) < 0 && WL.call(e, r) && (n[r] = e[r]);
        return n
    }
;
function zy(e, t, n={}) {
    const r = n
        , {window: i=Lt} = r
        , s = GL(r, ["window"]);
    let o;
    const a = ei(()=>i && "ResizeObserver"in i)
        , l = ()=>{
            o && (o.disconnect(),
                o = void 0)
        }
        , c = fe(()=>Array.isArray(e) ? e.map(d=>En(d)) : [En(e)])
        , u = Se(c, d=>{
                if (l(),
                a.value && i) {
                    o = new ResizeObserver(t);
                    for (const h of d)
                        h && o.observe(h, s)
                }
            }
            , {
                immediate: !0,
                flush: "post",
                deep: !0
            })
        , f = ()=>{
            l(),
                u()
        }
    ;
    return sn(f),
        {
            isSupported: a,
            stop: f
        }
}
function mh(e, t={
    width: 0,
    height: 0
}, n={}) {
    const {window: r=Lt, box: i="content-box"} = n
        , s = fe(()=>{
            var l, c;
            return (c = (l = En(e)) == null ? void 0 : l.namespaceURI) == null ? void 0 : c.includes("svg")
        }
    )
        , o = X(t.width)
        , a = X(t.height);
    return zy(e, ([l])=>{
            const c = i === "border-box" ? l.borderBoxSize : i === "content-box" ? l.contentBoxSize : l.devicePixelContentBoxSize;
            if (r && s.value) {
                const u = En(e);
                if (u) {
                    const f = r.getComputedStyle(u);
                    o.value = Number.parseFloat(f.width),
                        a.value = Number.parseFloat(f.height)
                }
            } else if (c) {
                const u = Array.isArray(c) ? c : [c];
                o.value = u.reduce((f,{inlineSize: d})=>f + d, 0),
                    a.value = u.reduce((f,{blockSize: d})=>f + d, 0)
            } else
                o.value = l.contentRect.width,
                    a.value = l.contentRect.height
        }
        , n),
        Se(()=>En(e), l=>{
                o.value = l ? t.width : 0,
                    a.value = l ? t.height : 0
            }
        ),
        {
            width: o,
            height: a
        }
}
var XL = Object.defineProperty
    , gh = Object.getOwnPropertySymbols
    , KL = Object.prototype.hasOwnProperty
    , YL = Object.prototype.propertyIsEnumerable
    , vh = (e,t,n)=>t in e ? XL(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n
    , Ml = (e,t)=>{
        for (var n in t || (t = {}))
            KL.call(t, n) && vh(e, n, t[n]);
        if (gh)
            for (var n of gh(t))
                YL.call(t, n) && vh(e, n, t[n]);
        return e
    }
;
const qL = {
    multiple: !0,
    accept: "*",
    reset: !1
};
function lF(e={}) {
    const {document: t=ll} = e
        , n = X(null)
        , {on: r, trigger: i} = AR();
    let s;
    t && (s = t.createElement("input"),
            s.type = "file",
            s.onchange = l=>{
                const c = l.target;
                n.value = c.files,
                    i(n.value)
            }
    );
    const o = ()=>{
            n.value = null,
            s && (s.value = "")
        }
        , a = l=>{
            if (!s)
                return;
            const c = Ml(Ml(Ml({}, qL), e), l);
            s.multiple = c.multiple,
                s.accept = c.accept,
            IR(c, "capture") && (s.capture = c.capture),
            c.reset && o(),
                s.click()
        }
    ;
    return {
        files: _r(n),
        open: a,
        reset: o,
        onChange: r
    }
}
const yh = ["fullscreenchange", "webkitfullscreenchange", "webkitendfullscreen", "mozfullscreenchange", "MSFullscreenChange"];
function JL(e, t={}) {
    const {document: n=ll, autoExit: r=!1} = t
        , i = fe(()=>{
                var m;
                return (m = En(e)) != null ? m : n == null ? void 0 : n.querySelector("html")
            }
        )
        , s = X(!1)
        , o = fe(()=>["requestFullscreen", "webkitRequestFullscreen", "webkitEnterFullscreen", "webkitEnterFullScreen", "webkitRequestFullScreen", "mozRequestFullScreen", "msRequestFullscreen"].find(m=>n && m in n || i.value && m in i.value))
        , a = fe(()=>["exitFullscreen", "webkitExitFullscreen", "webkitExitFullScreen", "webkitCancelFullScreen", "mozCancelFullScreen", "msExitFullscreen"].find(m=>n && m in n || i.value && m in i.value))
        , l = fe(()=>["fullScreen", "webkitIsFullScreen", "webkitDisplayingFullscreen", "mozFullScreen", "msFullscreenElement"].find(m=>n && m in n || i.value && m in i.value))
        , c = ["fullscreenElement", "webkitFullscreenElement", "mozFullScreenElement", "msFullscreenElement"].find(m=>n && m in n)
        , u = ei(()=>i.value && n && o.value !== void 0 && a.value !== void 0 && l.value !== void 0)
        , f = ()=>c ? (n == null ? void 0 : n[c]) === i.value : !1
        , d = ()=>{
            if (l.value) {
                if (n && n[l.value] != null)
                    return n[l.value];
                {
                    const m = i.value;
                    if ((m == null ? void 0 : m[l.value]) != null)
                        return !!m[l.value]
                }
            }
            return !1
        }
    ;
    async function h() {
        if (!(!u.value || !s.value)) {
            if (a.value)
                if ((n == null ? void 0 : n[a.value]) != null)
                    await n[a.value]();
                else {
                    const m = i.value;
                    (m == null ? void 0 : m[a.value]) != null && await m[a.value]()
                }
            s.value = !1
        }
    }
    async function y() {
        if (!u.value || s.value)
            return;
        d() && await h();
        const m = i.value;
        o.value && (m == null ? void 0 : m[o.value]) != null && (await m[o.value](),
            s.value = !0)
    }
    async function p() {
        await (s.value ? h() : y())
    }
    const w = ()=>{
            const m = d();
            (!m || m && f()) && (s.value = m)
        }
    ;
    return Ft(n, yh, w, !1),
        Ft(()=>En(i), yh, w, !1),
    r && sn(h),
        {
            isSupported: u,
            isFullscreen: s,
            enter: y,
            exit: h,
            toggle: p
        }
}
const ZL = ["mousemove", "mousedown", "resize", "keydown", "touchstart", "wheel"]
    , QL = 6e4;
function eO(e=QL, t={}) {
    const {initialState: n=!1, listenForVisibilityChange: r=!0, events: i=ZL, window: s=Lt, eventFilter: o=xf(50)} = t
        , a = X(n)
        , l = X(Zp());
    let c;
    const u = ()=>{
        a.value = !1,
            clearTimeout(c),
            c = setTimeout(()=>a.value = !0, e)
    }
        , f = al(o, ()=>{
            l.value = Zp(),
                u()
        }
    );
    if (s) {
        const d = s.document;
        for (const h of i)
            Ft(s, h, f, {
                passive: !0
            });
        r && Ft(d, "visibilitychange", ()=>{
                d.hidden || f()
            }
        ),
            u()
    }
    return {
        idle: a,
        lastActive: l,
        reset: u
    }
}
const tO = ["mousedown", "mouseup", "keydown", "keyup"];
function Dl(e, t={}) {
    const {events: n=tO, document: r=ll, initial: i=null} = t
        , s = X(i);
    return r && n.forEach(o=>{
            Ft(r, o, a=>{
                    typeof a.getModifierState == "function" && (s.value = a.getModifierState(e))
                }
            )
        }
    ),
        s
}
function Gr(e, t, n={}) {
    const {window: r=Lt} = n;
    return Vy(e, t, r == null ? void 0 : r.localStorage, n)
}
var nO = Object.defineProperty
    , bh = Object.getOwnPropertySymbols
    , rO = Object.prototype.hasOwnProperty
    , iO = Object.prototype.propertyIsEnumerable
    , wh = (e,t,n)=>t in e ? nO(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n
    , sO = (e,t)=>{
        for (var n in t || (t = {}))
            rO.call(t, n) && wh(e, n, t[n]);
        if (bh)
            for (var n of bh(t))
                iO.call(t, n) && wh(e, n, t[n]);
        return e
    }
;
function cF(e={}) {
    const {controls: t=!1, interval: n="requestAnimationFrame"} = e
        , r = X(new Date)
        , i = ()=>r.value = new Date
        , s = n === "requestAnimationFrame" ? RL(i, {
        immediate: !0
    }) : Pf(i, n, {
        immediate: !0
    });
    return t ? sO({
        now: r
    }, s) : r
}
function oO(e, t, n={}) {
    const {window: r=Lt} = n;
    return Vy(e, t, r == null ? void 0 : r.sessionStorage, n)
}
let aO = 0;
function lO(e, t={}) {
    const n = X(!1)
        , {document: r=ll, immediate: i=!0, manual: s=!1, id: o=`vueuse_styletag_ ${++aO}`} = t
        , a = X(e);
    let l = ()=>{}
    ;
    const c = ()=>{
            if (!r)
                return;
            const f = r.getElementById(o) || r.createElement("style");
            f.isConnected || (f.id = o,
            t.media && (f.media = t.media),
                r.head.appendChild(f)),
            !n.value && (l = Se(a, d=>{
                    f.textContent = d
                }
                , {
                    immediate: !0
                }),
                n.value = !0)
        }
        , u = ()=>{
            !r || !n.value || (l(),
                r.head.removeChild(r.getElementById(o)),
                n.value = !1)
        }
    ;
    return i && !s && Iy(c),
    s || sn(u),
        {
            id: o,
            css: a,
            unload: u,
            load: c,
            isLoaded: _r(n)
        }
}
function uF(e) {
    const t = X(e == null ? void 0 : e.element)
        , n = X(e == null ? void 0 : e.input)
        , r = X(1);
    function i() {
        var s, o;
        if (!t.value)
            return;
        let a = "";
        t.value.style.height = "1px",
            r.value = (s = t.value) == null ? void 0 : s.scrollHeight,
            e != null && e.styleTarget ? $t(e.styleTarget).style.height = `${r.value}px` : a = `${r.value}px`,
            t.value.style.height = a,
        (o = e == null ? void 0 : e.onResize) == null || o.call(e)
    }
    return Se([n, t], ()=>ct(i), {
        immediate: !0
    }),
        zy(t, ()=>i()),
    e != null && e.watch && Se(e.watch, i, {
        immediate: !0,
        deep: !0
    }),
        {
            textarea: t,
            input: n,
            triggerResize: i
        }
}
function Uy(e="history", t={}) {
    const {initialValue: n={}, removeNullishValues: r=!0, removeFalsyValues: i=!1, write: s=!0, window: o=Lt} = t;
    if (!o)
        return nn(n);
    const a = nn({});
    function l() {
        if (e === "history")
            return o.location.search || "";
        if (e === "hash") {
            const m = o.location.hash || ""
                , g = m.indexOf("?");
            return g > 0 ? m.slice(g) : ""
        } else
            return (o.location.hash || "").replace(/^#/, "")
    }
    function c(m) {
        const g = m.toString();
        if (e === "history")
            return `${g ? `?${g}` : ""}${o.location.hash || ""}`;
        if (e === "hash-params")
            return `${o.location.search || ""}${g ? `#${g}` : ""}`;
        const b = o.location.hash || "#"
            , v = b.indexOf("?");
        return v > 0 ? `${b.slice(0, v)}${g ? `?${g}` : ""}` : `${b}${g ? `?${g}` : ""}`
    }
    function u() {
        return new URLSearchParams(l())
    }
    function f(m) {
        const g = new Set(Object.keys(a));
        for (const b of m.keys()) {
            const v = m.getAll(b);
            a[b] = v.length > 1 ? v : m.get(b) || "",
                g.delete(b)
        }
        Array.from(g).forEach(b=>delete a[b])
    }
    const {pause: d, resume: h} = Fy(a, ()=>{
            const m = new URLSearchParams("");
            Object.keys(a).forEach(g=>{
                    const b = a[g];
                    Array.isArray(b) ? b.forEach(v=>m.append(g, v)) : r && b == null || i && !b ? m.delete(g) : m.set(g, b)
                }
            ),
                y(m)
        }
        , {
            deep: !0
        });
    function y(m, g) {
        d(),
        g && f(m),
            o.history.replaceState(o.history.state, o.document.title, o.location.pathname + c(m)),
            h()
    }
    function p() {
        s && y(u(), !0)
    }
    Ft(o, "popstate", p, !1),
    e !== "history" && Ft(o, "hashchange", p, !1);
    const w = u();
    return w.keys().next().value ? f(w) : Object.assign(a, n),
        a
}
function cO(e={}) {
    var t, n;
    const r = X((t = e.enabled) != null ? t : !1)
        , i = X((n = e.autoSwitch) != null ? n : !0)
        , s = X(e.constraints)
        , {navigator: o=Rf} = e
        , a = ei(()=>{
            var p;
            return (p = o == null ? void 0 : o.mediaDevices) == null ? void 0 : p.getUserMedia
        }
    )
        , l = gr();
    function c(p) {
        switch (p) {
            case "video":
            {
                if (s.value)
                    return s.value.video || !1;
                break
            }
            case "audio":
            {
                if (s.value)
                    return s.value.audio || !1;
                break
            }
        }
    }
    async function u() {
        if (!(!a.value || l.value))
            return l.value = await o.mediaDevices.getUserMedia({
                video: c("video"),
                audio: c("audio")
            }),
                l.value
    }
    function f() {
        var p;
        (p = l.value) == null || p.getTracks().forEach(w=>w.stop()),
            l.value = void 0
    }
    function d() {
        f(),
            r.value = !1
    }
    async function h() {
        return await u(),
        l.value && (r.value = !0),
            l.value
    }
    async function y() {
        return f(),
            await h()
    }
    return Se(r, p=>{
            p ? u() : f()
        }
        , {
            immediate: !0
        }),
        Se(s, ()=>{
                i.value && l.value && y()
            }
            , {
                immediate: !0
            }),
        {
            isSupported: a,
            stream: l,
            start: h,
            stop: d,
            restart: y,
            constraints: s,
            enabled: r,
            autoSwitch: i
        }
}
function uO(e={}) {
    const {window: t=Lt, initialWidth: n=Number.POSITIVE_INFINITY, initialHeight: r=Number.POSITIVE_INFINITY, listenOrientation: i=!0, includeScrollbar: s=!0} = e
        , o = X(n)
        , a = X(r)
        , l = ()=>{
            t && (s ? (o.value = t.innerWidth,
                a.value = t.innerHeight) : (o.value = t.document.documentElement.clientWidth,
                a.value = t.document.documentElement.clientHeight))
        }
    ;
    if (l(),
        Iy(l),
        Ft("resize", l, {
            passive: !0
        }),
        i) {
        const c = By("(orientation: portrait)");
        Se(c, ()=>l())
    }
    return {
        width: o,
        height: a
    }
}
/*! Capacitor: https://capacitorjs.com/ - MIT License */
const fO = e=>{
    const t = new Map;
    t.set("web", {
        name: "web"
    });
    const n = e.CapacitorPlatforms || {
            currentPlatform: {
                name: "web"
            },
            platforms: t
        }
        , r = (s,o)=>{
            n.platforms.set(s, o)
        }
        , i = s=>{
            n.platforms.has(s) && (n.currentPlatform = n.platforms.get(s))
        }
    ;
    return n.addPlatform = r,
        n.setPlatform = i,
        n
}
    , dO = e=>e.CapacitorPlatforms = fO(e)
    , Wy = dO(typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
Wy.addPlatform;
Wy.setPlatform;
var ji;
(function(e) {
        e.Unimplemented = "UNIMPLEMENTED",
            e.Unavailable = "UNAVAILABLE"
    }
)(ji || (ji = {}));
class Nl extends Error {
    constructor(t, n, r) {
        super(t),
            this.message = t,
            this.code = n,
            this.data = r
    }
}
const pO = e=>{
    var t, n;
    return e != null && e.androidBridge ? "android" : !((n = (t = e == null ? void 0 : e.webkit) === null || t === void 0 ? void 0 : t.messageHandlers) === null || n === void 0) && n.bridge ? "ios" : "web"
}
    , hO = e=>{
    var t, n, r, i, s;
    const o = e.CapacitorCustomPlatform || null
        , a = e.Capacitor || {}
        , l = a.Plugins = a.Plugins || {}
        , c = e.CapacitorPlatforms
        , u = ()=>o !== null ? o.name : pO(e)
        , f = ((t = c == null ? void 0 : c.currentPlatform) === null || t === void 0 ? void 0 : t.getPlatform) || u
        , d = ()=>f() !== "web"
        , h = ((n = c == null ? void 0 : c.currentPlatform) === null || n === void 0 ? void 0 : n.isNativePlatform) || d
        , y = E=>{
        const T = v.get(E);
        return !!(T != null && T.platforms.has(f()) || m(E))
    }
        , p = ((r = c == null ? void 0 : c.currentPlatform) === null || r === void 0 ? void 0 : r.isPluginAvailable) || y
        , w = E=>{
        var T;
        return (T = a.PluginHeaders) === null || T === void 0 ? void 0 : T.find(P=>P.name === E)
    }
        , m = ((i = c == null ? void 0 : c.currentPlatform) === null || i === void 0 ? void 0 : i.getPluginHeader) || w
        , g = E=>e.console.error(E)
        , b = (E,T,P)=>Promise.reject(`${P} does not have an implementation of "${T}".`)
        , v = new Map
        , S = (E,T={})=>{
        const P = v.get(E);
        if (P)
            return console.warn(`Capacitor plugin "${E}" already registered. Cannot register plugins twice.`),
                P.proxy;
        const I = f()
            , L = m(E);
        let x;
        const A = async()=>(!x && I in T ? x = typeof T[I] == "function" ? x = await T[I]() : x = T[I] : o !== null && !x && "web"in T && (x = typeof T.web == "function" ? x = await T.web() : x = T.web),
            x)
            , k = (le,ge)=>{
            var ye, de;
            if (L) {
                const z = L == null ? void 0 : L.methods.find(Pe=>ge === Pe.name);
                if (z)
                    return z.rtype === "promise" ? Pe=>a.nativePromise(E, ge.toString(), Pe) : (Pe,_e)=>a.nativeCallback(E, ge.toString(), Pe, _e);
                if (le)
                    return (ye = le[ge]) === null || ye === void 0 ? void 0 : ye.bind(le)
            } else {
                if (le)
                    return (de = le[ge]) === null || de === void 0 ? void 0 : de.bind(le);
                throw new Nl(`"${E}" plugin is not implemented on ${I}`,ji.Unimplemented)
            }
        }
            , O = le=>{
            let ge;
            const ye = (...de)=>{
                    const z = A().then(Pe=>{
                            const _e = k(Pe, le);
                            if (_e) {
                                const J = _e(...de);
                                return ge = J == null ? void 0 : J.remove,
                                    J
                            } else
                                throw new Nl(`"${E}.${le}()" is not implemented on ${I}`,ji.Unimplemented)
                        }
                    );
                    return le === "addListener" && (z.remove = async()=>ge()),
                        z
                }
            ;
            return ye.toString = ()=>`${le.toString()}() { [capacitor code] }`,
                Object.defineProperty(ye, "name", {
                    value: le,
                    writable: !1,
                    configurable: !1
                }),
                ye
        }
            , N = O("addListener")
            , D = O("removeListener")
            , W = (le,ge)=>{
            const ye = N({
                eventName: le
            }, ge)
                , de = async()=>{
                const Pe = await ye;
                D({
                    eventName: le,
                    callbackId: Pe
                }, ge)
            }
                , z = new Promise(Pe=>ye.then(()=>Pe({
                remove: de
            })));
            return z.remove = async()=>{
                console.warn("Using addListener() without 'await' is deprecated."),
                    await de()
            }
                ,
                z
        }
            , G = new Proxy({},{
            get(le, ge) {
                switch (ge) {
                    case "$$typeof":
                        return;
                    case "toJSON":
                        return ()=>({});
                    case "addListener":
                        return L ? W : N;
                    case "removeListener":
                        return D;
                    default:
                        return O(ge)
                }
            }
        });
        return l[E] = G,
            v.set(E, {
                name: E,
                proxy: G,
                platforms: new Set([...Object.keys(T), ...L ? [I] : []])
            }),
            G
    }
        , _ = ((s = c == null ? void 0 : c.currentPlatform) === null || s === void 0 ? void 0 : s.registerPlugin) || S;
    return a.convertFileSrc || (a.convertFileSrc = E=>E),
        a.getPlatform = f,
        a.handleError = g,
        a.isNativePlatform = h,
        a.isPluginAvailable = p,
        a.pluginMethodNoop = b,
        a.registerPlugin = _,
        a.Exception = Nl,
        a.DEBUG = !!a.DEBUG,
        a.isLoggingEnabled = !!a.isLoggingEnabled,
        a.platform = a.getPlatform(),
        a.isNative = a.isNativePlatform(),
        a
}
    , mO = e=>e.Capacitor = hO(e)
    , Vs = mO(typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {})
    , ti = Vs.registerPlugin;
Vs.Plugins;
class Gy {
    constructor(t) {
        this.listeners = {},
            this.windowListeners = {},
        t && (console.warn(`Capacitor WebPlugin "${t.name}" config object was deprecated in v3 and will be removed in v4.`),
            this.config = t)
    }
    addListener(t, n) {
        this.listeners[t] || (this.listeners[t] = []),
            this.listeners[t].push(n);
        const i = this.windowListeners[t];
        i && !i.registered && this.addWindowListener(i);
        const s = async()=>this.removeListener(t, n)
            , o = Promise.resolve({
            remove: s
        });
        return Object.defineProperty(o, "remove", {
            value: async()=>{
                console.warn("Using addListener() without 'await' is deprecated."),
                    await s()
            }
        }),
            o
    }
    async removeAllListeners() {
        this.listeners = {};
        for (const t in this.windowListeners)
            this.removeWindowListener(this.windowListeners[t]);
        this.windowListeners = {}
    }
    notifyListeners(t, n) {
        const r = this.listeners[t];
        r && r.forEach(i=>i(n))
    }
    hasListeners(t) {
        return !!this.listeners[t].length
    }
    registerWindowListener(t, n) {
        this.windowListeners[n] = {
            registered: !1,
            windowEventName: t,
            pluginEventName: n,
            handler: r=>{
                this.notifyListeners(n, r)
            }
        }
    }
    unimplemented(t="not implemented") {
        return new Vs.Exception(t,ji.Unimplemented)
    }
    unavailable(t="not available") {
        return new Vs.Exception(t,ji.Unavailable)
    }
    async removeListener(t, n) {
        const r = this.listeners[t];
        if (!r)
            return;
        const i = r.indexOf(n);
        this.listeners[t].splice(i, 1),
        this.listeners[t].length || this.removeWindowListener(this.windowListeners[t])
    }
    addWindowListener(t) {
        window.addEventListener(t.windowEventName, t.handler),
            t.registered = !0
    }
    removeWindowListener(t) {
        t && (window.removeEventListener(t.windowEventName, t.handler),
            t.registered = !1)
    }
}
const Sh = e=>encodeURIComponent(e).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape)
    , _h = e=>e.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
class gO extends Gy {
    async getCookies() {
        const t = document.cookie
            , n = {};
        return t.split(";").forEach(r=>{
                if (r.length <= 0)
                    return;
                let[i,s] = r.replace(/=/, "CAP_COOKIE").split("CAP_COOKIE");
                i = _h(i).trim(),
                    s = _h(s).trim(),
                    n[i] = s
            }
        ),
            n
    }
    async setCookie(t) {
        try {
            const n = Sh(t.key)
                , r = Sh(t.value)
                , i = `; expires=${(t.expires || "").replace("expires=", "")}`
                , s = (t.path || "/").replace("path=", "")
                , o = t.url != null && t.url.length > 0 ? `domain=${t.url}` : "";
            document.cookie = `${n}=${r || ""}${i}; path=${s}; ${o};`
        } catch (n) {
            return Promise.reject(n)
        }
    }
    async deleteCookie(t) {
        try {
            document.cookie = `${t.key}=; Max-Age=0`
        } catch (n) {
            return Promise.reject(n)
        }
    }
    async clearCookies() {
        try {
            const t = document.cookie.split(";") || [];
            for (const n of t)
                document.cookie = n.replace(/^ +/, "").replace(/=.*/, `=;expires=${new Date().toUTCString()};path=/`)
        } catch (t) {
            return Promise.reject(t)
        }
    }
    async clearAllCookies() {
        try {
            await this.clearCookies()
        } catch (t) {
            return Promise.reject(t)
        }
    }
}
ti("CapacitorCookies", {
    web: ()=>new gO
});
const vO = async e=>new Promise((t,n)=>{
            const r = new FileReader;
            r.onload = ()=>{
                const i = r.result;
                t(i.indexOf(",") >= 0 ? i.split(",")[1] : i)
            }
                ,
                r.onerror = i=>n(i),
                r.readAsDataURL(e)
        }
    )
    , yO = (e={})=>{
        const t = Object.keys(e);
        return Object.keys(e).map(i=>i.toLocaleLowerCase()).reduce((i,s,o)=>(i[s] = e[t[o]],
            i), {})
    }
    , bO = (e,t=!0)=>e ? Object.entries(e).reduce((r,i)=>{
            const [s,o] = i;
            let a, l;
            return Array.isArray(o) ? (l = "",
                o.forEach(c=>{
                        a = t ? encodeURIComponent(c) : c,
                            l += `${s}=${a}&`
                    }
                ),
                l.slice(0, -1)) : (a = t ? encodeURIComponent(o) : o,
                l = `${s}=${a}`),
                `${r}&${l}`
        }
        , "").substr(1) : null
    , wO = (e,t={})=>{
        const n = Object.assign({
            method: e.method || "GET",
            headers: e.headers
        }, t)
            , i = yO(e.headers)["content-type"] || "";
        if (typeof e.data == "string")
            n.body = e.data;
        else if (i.includes("application/x-www-form-urlencoded")) {
            const s = new URLSearchParams;
            for (const [o,a] of Object.entries(e.data || {}))
                s.set(o, a);
            n.body = s.toString()
        } else if (i.includes("multipart/form-data")) {
            const s = new FormData;
            if (e.data instanceof FormData)
                e.data.forEach((a,l)=>{
                        s.append(l, a)
                    }
                );
            else
                for (const a of Object.keys(e.data))
                    s.append(a, e.data[a]);
            n.body = s;
            const o = new Headers(n.headers);
            o.delete("content-type"),
                n.headers = o
        } else
            (i.includes("application/json") || typeof e.data == "object") && (n.body = JSON.stringify(e.data));
        return n
    }
;
class SO extends Gy {
    async request(t) {
        const n = wO(t, t.webFetchExtra)
            , r = bO(t.params, t.shouldEncodeUrlParams)
            , i = r ? `${t.url}?${r}` : t.url
            , s = await fetch(i, n)
            , o = s.headers.get("content-type") || "";
        let {responseType: a="text"} = s.ok ? t : {};
        o.includes("application/json") && (a = "json");
        let l, c;
        switch (a) {
            case "arraybuffer":
            case "blob":
                c = await s.blob(),
                    l = await vO(c);
                break;
            case "json":
                l = await s.json();
                break;
            case "document":
            case "text":
            default:
                l = await s.text()
        }
        const u = {};
        return s.headers.forEach((f,d)=>{
                u[d] = f
            }
        ),
            {
                data: l,
                headers: u,
                status: s.status,
                url: s.url
            }
    }
    async get(t) {
        return this.request(Object.assign(Object.assign({}, t), {
            method: "GET"
        }))
    }
    async post(t) {
        return this.request(Object.assign(Object.assign({}, t), {
            method: "POST"
        }))
    }
    async put(t) {
        return this.request(Object.assign(Object.assign({}, t), {
            method: "PUT"
        }))
    }
    async patch(t) {
        return this.request(Object.assign(Object.assign({}, t), {
            method: "PATCH"
        }))
    }
    async delete(t) {
        return this.request(Object.assign(Object.assign({}, t), {
            method: "DELETE"
        }))
    }
}
ti("CapacitorHttp", {
    web: ()=>new SO
});
const cl = ()=>By("(pointer: coarse)")
    , _O = e=>{
    const t = cl()
        , {load: n, unload: r, isLoaded: i} = lO("body { overflow: hidden; }", {
            immediate: !1
        })
        , s = ()=>{
            t.value && e.value && !i.value ? n() : !e.value && i.value && r()
        }
    ;
    Se(e, s),
        s()
}
    , Lf = ()=>{
    const e = X(!1);
    return Ve(()=>{
            e.value = !0
        }
    ),
        e
}
    , EO = At(()=>{
        const e = X(null)
            , t = fe(()=>e.value === "ios")
            , n = fe(()=>e.value === "android")
            , r = fe(()=>e.value === "web");
        return Ve(async()=>{
                e.value = await Vs.getPlatform()
            }
        ),
            {
                platform: e,
                isIos: t,
                isAndroid: n,
                isWeb: r
            }
    }
)
    , CO = Xe({
    __name: "watch-scroll",
    props: {
        active: {
            type: Boolean,
            default: !1
        }
    },
    setup(e) {
        const n = Ri(e, "active");
        return _O(n),
            (r,i)=>null
    }
})
    , Xy = Xe({
    name: "ClientOnly",
    inheritAttrs: !1,
    props: ["fallback", "placeholder", "placeholderTag", "fallbackTag"],
    setup(e, {slots: t, attrs: n}) {
        const r = X(!1);
        return Ve(()=>{
                r.value = !0
            }
        ),
            i=>{
                var l;
                if (r.value)
                    return (l = t.default) == null ? void 0 : l.call(t);
                const s = t.fallback || t.placeholder;
                if (s)
                    return s();
                const o = i.fallback || i.placeholder || ""
                    , a = i.fallbackTag || i.placeholderTag || "span";
                return Qe(a, n, o)
            }
    }
})
    , TO = At(()=>{
        const e = X([])
            , t = X([])
            , n = fe(()=>e.value[e.value.length - 1]);
        return {
            parent: fe(()=>t.value[t.value.length - 1]),
            currentOpened: n,
            add: (i,s)=>{
                e.value.includes(i) || (e.value.push(i),
                s && t.value.push(i))
            }
            ,
            remove: i=>{
                e.value = e.value.filter(s=>s !== i),
                    t.value = t.value.filter(s=>s !== i)
            }
        }
    }
);
function xO(e, t) {
    return Ae(),
        Qe("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 20 20",
            fill: "currentColor",
            "aria-hidden": "true"
        }, [Te("path", {
            "fill-rule": "evenodd",
            d: "M16.704 4.153a.75.75 0 01.143 1.052l-8 10.5a.75.75 0 01-1.127.075l-4.5-4.5a.75.75 0 011.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 011.05-.143z",
            "clip-rule": "evenodd"
        })])
}
function PO(e, t) {
    return Ae(),
        Qe("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 20 20",
            fill: "currentColor",
            "aria-hidden": "true"
        }, [Te("path", {
            "fill-rule": "evenodd",
            d: "M10 3a.75.75 0 01.55.24l3.25 3.5a.75.75 0 11-1.1 1.02L10 4.852 7.3 7.76a.75.75 0 01-1.1-1.02l3.25-3.5A.75.75 0 0110 3zm-3.76 9.2a.75.75 0 011.06.04l2.7 2.908 2.7-2.908a.75.75 0 111.1 1.02l-3.25 3.5a.75.75 0 01-1.1 0l-3.25-3.5a.75.75 0 01.04-1.06z",
            "clip-rule": "evenodd"
        })])
}
function Eh(e, t) {
    return Ae(),
        Qe("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 20 20",
            fill: "currentColor",
            "aria-hidden": "true"
        }, [Te("path", {
            d: "M3.5 2.75a.75.75 0 00-1.5 0v14.5a.75.75 0 001.5 0v-4.392l1.657-.348a6.449 6.449 0 014.271.572 7.948 7.948 0 005.965.524l2.078-.64A.75.75 0 0018 12.25v-8.5a.75.75 0 00-.904-.734l-2.38.501a7.25 7.25 0 01-4.186-.363l-.502-.2a8.75 8.75 0 00-5.053-.439l-1.475.31V2.75z"
        })])
}
function Ky(e, t) {
    return Ae(),
        Qe("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 20 20",
            fill: "currentColor",
            "aria-hidden": "true"
        }, [Te("path", {
            d: "M6.28 5.22a.75.75 0 00-1.06 1.06L8.94 10l-3.72 3.72a.75.75 0 101.06 1.06L10 11.06l3.72 3.72a.75.75 0 101.06-1.06L11.06 10l3.72-3.72a.75.75 0 00-1.06-1.06L10 8.94 6.28 5.22z"
        })])
}
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var Yy = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"]
    , ba = Yy.join(",")
    , qy = typeof Element > "u"
    , Xr = qy ? function() {}
    : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector
    , wa = !qy && Element.prototype.getRootNode ? function(e) {
        var t;
        return e == null || (t = e.getRootNode) === null || t === void 0 ? void 0 : t.call(e)
    }
    : function(e) {
        return e == null ? void 0 : e.ownerDocument
    }
    , Sa = function e(t, n) {
    var r;
    n === void 0 && (n = !0);
    var i = t == null || (r = t.getAttribute) === null || r === void 0 ? void 0 : r.call(t, "inert")
        , s = i === "" || i === "true"
        , o = s || n && t && e(t.parentNode);
    return o
}
    , kO = function(t) {
    var n, r = t == null || (n = t.getAttribute) === null || n === void 0 ? void 0 : n.call(t, "contenteditable");
    return r === "" || r === "true"
}
    , Jy = function(t, n, r) {
    if (Sa(t))
        return [];
    var i = Array.prototype.slice.apply(t.querySelectorAll(ba));
    return n && Xr.call(t, ba) && i.unshift(t),
        i = i.filter(r),
        i
}
    , Zy = function e(t, n, r) {
    for (var i = [], s = Array.from(t); s.length; ) {
        var o = s.shift();
        if (!Sa(o, !1))
            if (o.tagName === "SLOT") {
                var a = o.assignedElements()
                    , l = a.length ? a : o.children
                    , c = e(l, !0, r);
                r.flatten ? i.push.apply(i, c) : i.push({
                    scopeParent: o,
                    candidates: c
                })
            } else {
                var u = Xr.call(o, ba);
                u && r.filter(o) && (n || !t.includes(o)) && i.push(o);
                var f = o.shadowRoot || typeof r.getShadowRoot == "function" && r.getShadowRoot(o)
                    , d = !Sa(f, !1) && (!r.shadowRootFilter || r.shadowRootFilter(o));
                if (f && d) {
                    var h = e(f === !0 ? o.children : f.children, !0, r);
                    r.flatten ? i.push.apply(i, h) : i.push({
                        scopeParent: o,
                        candidates: h
                    })
                } else
                    s.unshift.apply(s, o.children)
            }
    }
    return i
}
    , Qy = function(t) {
    return !isNaN(parseInt(t.getAttribute("tabindex"), 10))
}
    , Ar = function(t) {
    if (!t)
        throw new Error("No node provided");
    return t.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(t.tagName) || kO(t)) && !Qy(t) ? 0 : t.tabIndex
}
    , RO = function(t, n) {
    var r = Ar(t);
    return r < 0 && n && !Qy(t) ? 0 : r
}
    , LO = function(t, n) {
    return t.tabIndex === n.tabIndex ? t.documentOrder - n.documentOrder : t.tabIndex - n.tabIndex
}
    , eb = function(t) {
    return t.tagName === "INPUT"
}
    , OO = function(t) {
    return eb(t) && t.type === "hidden"
}
    , AO = function(t) {
    var n = t.tagName === "DETAILS" && Array.prototype.slice.apply(t.children).some(function(r) {
        return r.tagName === "SUMMARY"
    });
    return n
}
    , IO = function(t, n) {
    for (var r = 0; r < t.length; r++)
        if (t[r].checked && t[r].form === n)
            return t[r]
}
    , MO = function(t) {
    if (!t.name)
        return !0;
    var n = t.form || wa(t), r = function(a) {
        return n.querySelectorAll('input[type="radio"][name="' + a + '"]')
    }, i;
    if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
        i = r(window.CSS.escape(t.name));
    else
        try {
            i = r(t.name)
        } catch (o) {
            return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", o.message),
                !1
        }
    var s = IO(i, t.form);
    return !s || s === t
}
    , DO = function(t) {
    return eb(t) && t.type === "radio"
}
    , NO = function(t) {
    return DO(t) && !MO(t)
}
    , $O = function(t) {
    var n, r = t && wa(t), i = (n = r) === null || n === void 0 ? void 0 : n.host, s = !1;
    if (r && r !== t) {
        var o, a, l;
        for (s = !!((o = i) !== null && o !== void 0 && (a = o.ownerDocument) !== null && a !== void 0 && a.contains(i) || t != null && (l = t.ownerDocument) !== null && l !== void 0 && l.contains(t)); !s && i; ) {
            var c, u, f;
            r = wa(i),
                i = (c = r) === null || c === void 0 ? void 0 : c.host,
                s = !!((u = i) !== null && u !== void 0 && (f = u.ownerDocument) !== null && f !== void 0 && f.contains(i))
        }
    }
    return s
}
    , Ch = function(t) {
    var n = t.getBoundingClientRect()
        , r = n.width
        , i = n.height;
    return r === 0 && i === 0
}
    , FO = function(t, n) {
    var r = n.displayCheck
        , i = n.getShadowRoot;
    if (getComputedStyle(t).visibility === "hidden")
        return !0;
    var s = Xr.call(t, "details>summary:first-of-type")
        , o = s ? t.parentElement : t;
    if (Xr.call(o, "details:not([open]) *"))
        return !0;
    if (!r || r === "full" || r === "legacy-full") {
        if (typeof i == "function") {
            for (var a = t; t; ) {
                var l = t.parentElement
                    , c = wa(t);
                if (l && !l.shadowRoot && i(l) === !0)
                    return Ch(t);
                t.assignedSlot ? t = t.assignedSlot : !l && c !== t.ownerDocument ? t = c.host : t = l
            }
            t = a
        }
        if ($O(t))
            return !t.getClientRects().length;
        if (r !== "legacy-full")
            return !0
    } else if (r === "non-zero-area")
        return Ch(t);
    return !1
}
    , jO = function(t) {
    if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(t.tagName))
        for (var n = t.parentElement; n; ) {
            if (n.tagName === "FIELDSET" && n.disabled) {
                for (var r = 0; r < n.children.length; r++) {
                    var i = n.children.item(r);
                    if (i.tagName === "LEGEND")
                        return Xr.call(n, "fieldset[disabled] *") ? !0 : !i.contains(t)
                }
                return !0
            }
            n = n.parentElement
        }
    return !1
}
    , _a = function(t, n) {
    return !(n.disabled || Sa(n) || OO(n) || FO(n, t) || AO(n) || jO(n))
}
    , Yc = function(t, n) {
    return !(NO(n) || Ar(n) < 0 || !_a(t, n))
}
    , HO = function(t) {
    var n = parseInt(t.getAttribute("tabindex"), 10);
    return !!(isNaN(n) || n >= 0)
}
    , BO = function e(t) {
    var n = []
        , r = [];
    return t.forEach(function(i, s) {
        var o = !!i.scopeParent
            , a = o ? i.scopeParent : i
            , l = RO(a, o)
            , c = o ? e(i.candidates) : a;
        l === 0 ? o ? n.push.apply(n, c) : n.push(a) : r.push({
            documentOrder: s,
            tabIndex: l,
            item: i,
            isScope: o,
            content: c
        })
    }),
        r.sort(LO).reduce(function(i, s) {
            return s.isScope ? i.push.apply(i, s.content) : i.push(s.content),
                i
        }, []).concat(n)
}
    , VO = function(t, n) {
    n = n || {};
    var r;
    return n.getShadowRoot ? r = Zy([t], n.includeContainer, {
        filter: Yc.bind(null, n),
        flatten: !1,
        getShadowRoot: n.getShadowRoot,
        shadowRootFilter: HO
    }) : r = Jy(t, n.includeContainer, Yc.bind(null, n)),
        BO(r)
}
    , zO = function(t, n) {
    n = n || {};
    var r;
    return n.getShadowRoot ? r = Zy([t], n.includeContainer, {
        filter: _a.bind(null, n),
        flatten: !0,
        getShadowRoot: n.getShadowRoot
    }) : r = Jy(t, n.includeContainer, _a.bind(null, n)),
        r
}
    , ci = function(t, n) {
    if (n = n || {},
        !t)
        throw new Error("No node provided");
    return Xr.call(t, ba) === !1 ? !1 : Yc(n, t)
}
    , UO = Yy.concat("iframe").join(",")
    , $l = function(t, n) {
    if (n = n || {},
        !t)
        throw new Error("No node provided");
    return Xr.call(t, UO) === !1 ? !1 : _a(n, t)
};
/*!
* focus-trap 7.5.2
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/
function Th(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })),
            n.push.apply(n, r)
    }
    return n
}
function xh(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? Th(Object(n), !0).forEach(function(r) {
            WO(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Th(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}
function WO(e, t, n) {
    return t = XO(t),
        t in e ? Object.defineProperty(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = n,
        e
}
function GO(e, t) {
    if (typeof e != "object" || e === null)
        return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t || "default");
        if (typeof r != "object")
            return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}
function XO(e) {
    var t = GO(e, "string");
    return typeof t == "symbol" ? t : String(t)
}
var Ph = {
        activateTrap: function(t, n) {
            if (t.length > 0) {
                var r = t[t.length - 1];
                r !== n && r.pause()
            }
            var i = t.indexOf(n);
            i === -1 || t.splice(i, 1),
                t.push(n)
        },
        deactivateTrap: function(t, n) {
            var r = t.indexOf(n);
            r !== -1 && t.splice(r, 1),
            t.length > 0 && t[t.length - 1].unpause()
        }
    }
    , KO = function(t) {
        return t.tagName && t.tagName.toLowerCase() === "input" && typeof t.select == "function"
    }
    , YO = function(t) {
        return (t == null ? void 0 : t.key) === "Escape" || (t == null ? void 0 : t.key) === "Esc" || (t == null ? void 0 : t.keyCode) === 27
    }
    , Cs = function(t) {
        return (t == null ? void 0 : t.key) === "Tab" || (t == null ? void 0 : t.keyCode) === 9
    }
    , qO = function(t) {
        return Cs(t) && !t.shiftKey
    }
    , JO = function(t) {
        return Cs(t) && t.shiftKey
    }
    , kh = function(t) {
        return setTimeout(t, 0)
    }
    , Rh = function(t, n) {
        var r = -1;
        return t.every(function(i, s) {
            return n(i) ? (r = s,
                !1) : !0
        }),
            r
    }
    , ns = function(t) {
        for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
            r[i - 1] = arguments[i];
        return typeof t == "function" ? t.apply(void 0, r) : t
    }
    , Oo = function(t) {
        return t.target.shadowRoot && typeof t.composedPath == "function" ? t.composedPath()[0] : t.target
    }
    , ZO = []
    , QO = function(t, n) {
        var r = (n == null ? void 0 : n.document) || document, i = (n == null ? void 0 : n.trapStack) || ZO, s = xh({
            returnFocusOnDeactivate: !0,
            escapeDeactivates: !0,
            delayInitialFocus: !0,
            isKeyForward: qO,
            isKeyBackward: JO
        }, n), o = {
            containers: [],
            containerGroups: [],
            tabbableGroups: [],
            nodeFocusedBeforeActivation: null,
            mostRecentlyFocusedNode: null,
            active: !1,
            paused: !1,
            delayInitialFocusTimer: void 0,
            recentNavEvent: void 0
        }, a, l = function(L, x, A) {
            return L && L[x] !== void 0 ? L[x] : s[A || x]
        }, c = function(L, x) {
            var A = typeof (x == null ? void 0 : x.composedPath) == "function" ? x.composedPath() : void 0;
            return o.containerGroups.findIndex(function(k) {
                var O = k.container
                    , N = k.tabbableNodes;
                return O.contains(L) || (A == null ? void 0 : A.includes(O)) || N.find(function(D) {
                    return D === L
                })
            })
        }, u = function(L) {
            var x = s[L];
            if (typeof x == "function") {
                for (var A = arguments.length, k = new Array(A > 1 ? A - 1 : 0), O = 1; O < A; O++)
                    k[O - 1] = arguments[O];
                x = x.apply(void 0, k)
            }
            if (x === !0 && (x = void 0),
                !x) {
                if (x === void 0 || x === !1)
                    return x;
                throw new Error("`".concat(L, "` was specified but was not a node, or did not return a node"))
            }
            var N = x;
            if (typeof x == "string" && (N = r.querySelector(x),
                !N))
                throw new Error("`".concat(L, "` as selector refers to no known node"));
            return N
        }, f = function() {
            var L = u("initialFocus");
            if (L === !1)
                return !1;
            if (L === void 0 || !$l(L, s.tabbableOptions))
                if (c(r.activeElement) >= 0)
                    L = r.activeElement;
                else {
                    var x = o.tabbableGroups[0]
                        , A = x && x.firstTabbableNode;
                    L = A || u("fallbackFocus")
                }
            if (!L)
                throw new Error("Your focus-trap needs to have at least one focusable element");
            return L
        }, d = function() {
            if (o.containerGroups = o.containers.map(function(L) {
                var x = VO(L, s.tabbableOptions)
                    , A = zO(L, s.tabbableOptions)
                    , k = x.length > 0 ? x[0] : void 0
                    , O = x.length > 0 ? x[x.length - 1] : void 0
                    , N = A.find(function(G) {
                    return ci(G)
                })
                    , D = A.slice().reverse().find(function(G) {
                    return ci(G)
                })
                    , W = !!x.find(function(G) {
                    return Ar(G) > 0
                });
                return {
                    container: L,
                    tabbableNodes: x,
                    focusableNodes: A,
                    posTabIndexesFound: W,
                    firstTabbableNode: k,
                    lastTabbableNode: O,
                    firstDomTabbableNode: N,
                    lastDomTabbableNode: D,
                    nextTabbableNode: function(le) {
                        var ge = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
                            , ye = x.indexOf(le);
                        return ye < 0 ? ge ? A.slice(A.indexOf(le) + 1).find(function(de) {
                            return ci(de)
                        }) : A.slice(0, A.indexOf(le)).reverse().find(function(de) {
                            return ci(de)
                        }) : x[ye + (ge ? 1 : -1)]
                    }
                }
            }),
                o.tabbableGroups = o.containerGroups.filter(function(L) {
                    return L.tabbableNodes.length > 0
                }),
            o.tabbableGroups.length <= 0 && !u("fallbackFocus"))
                throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
            if (o.containerGroups.find(function(L) {
                return L.posTabIndexesFound
            }) && o.containerGroups.length > 1)
                throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.")
        }, h = function I(L) {
            if (L !== !1 && L !== r.activeElement) {
                if (!L || !L.focus) {
                    I(f());
                    return
                }
                L.focus({
                    preventScroll: !!s.preventScroll
                }),
                    o.mostRecentlyFocusedNode = L,
                KO(L) && L.select()
            }
        }, y = function(L) {
            var x = u("setReturnFocus", L);
            return x || (x === !1 ? !1 : L)
        }, p = function(L) {
            var x = L.target
                , A = L.event
                , k = L.isBackward
                , O = k === void 0 ? !1 : k;
            x = x || Oo(A),
                d();
            var N = null;
            if (o.tabbableGroups.length > 0) {
                var D = c(x, A)
                    , W = D >= 0 ? o.containerGroups[D] : void 0;
                if (D < 0)
                    O ? N = o.tabbableGroups[o.tabbableGroups.length - 1].lastTabbableNode : N = o.tabbableGroups[0].firstTabbableNode;
                else if (O) {
                    var G = Rh(o.tabbableGroups, function(Pe) {
                        var _e = Pe.firstTabbableNode;
                        return x === _e
                    });
                    if (G < 0 && (W.container === x || $l(x, s.tabbableOptions) && !ci(x, s.tabbableOptions) && !W.nextTabbableNode(x, !1)) && (G = D),
                    G >= 0) {
                        var le = G === 0 ? o.tabbableGroups.length - 1 : G - 1
                            , ge = o.tabbableGroups[le];
                        N = Ar(x) >= 0 ? ge.lastTabbableNode : ge.lastDomTabbableNode
                    } else
                        Cs(A) || (N = W.nextTabbableNode(x, !1))
                } else {
                    var ye = Rh(o.tabbableGroups, function(Pe) {
                        var _e = Pe.lastTabbableNode;
                        return x === _e
                    });
                    if (ye < 0 && (W.container === x || $l(x, s.tabbableOptions) && !ci(x, s.tabbableOptions) && !W.nextTabbableNode(x)) && (ye = D),
                    ye >= 0) {
                        var de = ye === o.tabbableGroups.length - 1 ? 0 : ye + 1
                            , z = o.tabbableGroups[de];
                        N = Ar(x) >= 0 ? z.firstTabbableNode : z.firstDomTabbableNode
                    } else
                        Cs(A) || (N = W.nextTabbableNode(x))
                }
            } else
                N = u("fallbackFocus");
            return N
        }, w = function(L) {
            var x = Oo(L);
            if (!(c(x, L) >= 0)) {
                if (ns(s.clickOutsideDeactivates, L)) {
                    a.deactivate({
                        returnFocus: s.returnFocusOnDeactivate
                    });
                    return
                }
                ns(s.allowOutsideClick, L) || L.preventDefault()
            }
        }, m = function(L) {
            var x = Oo(L)
                , A = c(x, L) >= 0;
            if (A || x instanceof Document)
                A && (o.mostRecentlyFocusedNode = x);
            else {
                L.stopImmediatePropagation();
                var k, O = !0;
                if (o.mostRecentlyFocusedNode)
                    if (Ar(o.mostRecentlyFocusedNode) > 0) {
                        var N = c(o.mostRecentlyFocusedNode)
                            , D = o.containerGroups[N].tabbableNodes;
                        if (D.length > 0) {
                            var W = D.findIndex(function(G) {
                                return G === o.mostRecentlyFocusedNode
                            });
                            W >= 0 && (s.isKeyForward(o.recentNavEvent) ? W + 1 < D.length && (k = D[W + 1],
                                O = !1) : W - 1 >= 0 && (k = D[W - 1],
                                O = !1))
                        }
                    } else
                        o.containerGroups.some(function(G) {
                            return G.tabbableNodes.some(function(le) {
                                return Ar(le) > 0
                            })
                        }) || (O = !1);
                else
                    O = !1;
                O && (k = p({
                    target: o.mostRecentlyFocusedNode,
                    isBackward: s.isKeyBackward(o.recentNavEvent)
                })),
                    h(k || o.mostRecentlyFocusedNode || f())
            }
            o.recentNavEvent = void 0
        }, g = function(L) {
            var x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            o.recentNavEvent = L;
            var A = p({
                event: L,
                isBackward: x
            });
            A && (Cs(L) && L.preventDefault(),
                h(A))
        }, b = function(L) {
            if (YO(L) && ns(s.escapeDeactivates, L) !== !1) {
                L.preventDefault(),
                    a.deactivate();
                return
            }
            (s.isKeyForward(L) || s.isKeyBackward(L)) && g(L, s.isKeyBackward(L))
        }, v = function(L) {
            var x = Oo(L);
            c(x, L) >= 0 || ns(s.clickOutsideDeactivates, L) || ns(s.allowOutsideClick, L) || (L.preventDefault(),
                L.stopImmediatePropagation())
        }, S = function() {
            if (o.active)
                return Ph.activateTrap(i, a),
                    o.delayInitialFocusTimer = s.delayInitialFocus ? kh(function() {
                        h(f())
                    }) : h(f()),
                    r.addEventListener("focusin", m, !0),
                    r.addEventListener("mousedown", w, {
                        capture: !0,
                        passive: !1
                    }),
                    r.addEventListener("touchstart", w, {
                        capture: !0,
                        passive: !1
                    }),
                    r.addEventListener("click", v, {
                        capture: !0,
                        passive: !1
                    }),
                    r.addEventListener("keydown", b, {
                        capture: !0,
                        passive: !1
                    }),
                    a
        }, _ = function() {
            if (o.active)
                return r.removeEventListener("focusin", m, !0),
                    r.removeEventListener("mousedown", w, !0),
                    r.removeEventListener("touchstart", w, !0),
                    r.removeEventListener("click", v, !0),
                    r.removeEventListener("keydown", b, !0),
                    a
        }, E = function(L) {
            var x = L.some(function(A) {
                var k = Array.from(A.removedNodes);
                return k.some(function(O) {
                    return O === o.mostRecentlyFocusedNode
                })
            });
            x && h(f())
        }, T = typeof window < "u" && "MutationObserver"in window ? new MutationObserver(E) : void 0, P = function() {
            T && (T.disconnect(),
            o.active && !o.paused && o.containers.map(function(L) {
                T.observe(L, {
                    subtree: !0,
                    childList: !0
                })
            }))
        };
        return a = {
            get active() {
                return o.active
            },
            get paused() {
                return o.paused
            },
            activate: function(L) {
                if (o.active)
                    return this;
                var x = l(L, "onActivate")
                    , A = l(L, "onPostActivate")
                    , k = l(L, "checkCanFocusTrap");
                k || d(),
                    o.active = !0,
                    o.paused = !1,
                    o.nodeFocusedBeforeActivation = r.activeElement,
                x == null || x();
                var O = function() {
                    k && d(),
                        S(),
                        P(),
                    A == null || A()
                };
                return k ? (k(o.containers.concat()).then(O, O),
                    this) : (O(),
                    this)
            },
            deactivate: function(L) {
                if (!o.active)
                    return this;
                var x = xh({
                    onDeactivate: s.onDeactivate,
                    onPostDeactivate: s.onPostDeactivate,
                    checkCanReturnFocus: s.checkCanReturnFocus
                }, L);
                clearTimeout(o.delayInitialFocusTimer),
                    o.delayInitialFocusTimer = void 0,
                    _(),
                    o.active = !1,
                    o.paused = !1,
                    P(),
                    Ph.deactivateTrap(i, a);
                var A = l(x, "onDeactivate")
                    , k = l(x, "onPostDeactivate")
                    , O = l(x, "checkCanReturnFocus")
                    , N = l(x, "returnFocus", "returnFocusOnDeactivate");
                A == null || A();
                var D = function() {
                    kh(function() {
                        N && h(y(o.nodeFocusedBeforeActivation)),
                        k == null || k()
                    })
                };
                return N && O ? (O(y(o.nodeFocusedBeforeActivation)).then(D, D),
                    this) : (D(),
                    this)
            },
            pause: function(L) {
                if (o.paused || !o.active)
                    return this;
                var x = l(L, "onPause")
                    , A = l(L, "onPostPause");
                return o.paused = !0,
                x == null || x(),
                    _(),
                    P(),
                A == null || A(),
                    this
            },
            unpause: function(L) {
                if (!o.paused || !o.active)
                    return this;
                var x = l(L, "onUnpause")
                    , A = l(L, "onPostUnpause");
                return o.paused = !1,
                x == null || x(),
                    d(),
                    S(),
                    P(),
                A == null || A(),
                    this
            },
            updateContainerElements: function(L) {
                var x = [].concat(L).filter(Boolean);
                return o.containers = x.map(function(A) {
                    return typeof A == "string" ? r.querySelector(A) : A
                }),
                o.active && d(),
                    P(),
                    this
            }
        },
            a.updateContainerElements(t),
            a
    }
    , eA = Object.defineProperty
    , tA = Object.defineProperties
    , nA = Object.getOwnPropertyDescriptors
    , Ea = Object.getOwnPropertySymbols
    , tb = Object.prototype.hasOwnProperty
    , nb = Object.prototype.propertyIsEnumerable
    , Lh = (e,t,n)=>t in e ? eA(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n
    , rA = (e,t)=>{
        for (var n in t || (t = {}))
            tb.call(t, n) && Lh(e, n, t[n]);
        if (Ea)
            for (var n of Ea(t))
                nb.call(t, n) && Lh(e, n, t[n]);
        return e
    }
    , iA = (e,t)=>tA(e, nA(t))
    , sA = (e,t)=>{
        var n = {};
        for (var r in e)
            tb.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
        if (e != null && Ea)
            for (var r of Ea(e))
                t.indexOf(r) < 0 && nb.call(e, r) && (n[r] = e[r]);
        return n
    }
;
function oA(e, t={}) {
    let n;
    const r = t
        , {immediate: i} = r
        , s = sA(r, ["immediate"])
        , o = X(!1)
        , a = X(!1)
        , l = d=>n && n.activate(d)
        , c = d=>n && n.deactivate(d)
        , u = ()=>{
            n && (n.pause(),
                a.value = !0)
        }
        , f = ()=>{
            n && (n.unpause(),
                a.value = !1)
        }
    ;
    return Se(()=>En(e), d=>{
            d && (n = QO(d, iA(rA({}, s), {
                onActivate() {
                    o.value = !0,
                    t.onActivate && t.onActivate()
                },
                onDeactivate() {
                    o.value = !1,
                    t.onDeactivate && t.onDeactivate()
                }
            })),
            i && l())
        }
        , {
            flush: "post"
        }),
        sn(()=>c()),
        {
            hasFocus: o,
            isPaused: a,
            activate: l,
            deactivate: c,
            pause: u,
            unpause: f
        }
}
const aA = {
    key: 0,
    class: "z-20 fixed left-0 right-0 bottom-0 top-0 pointer-events-none"
}
    , lA = ["onClick"]
    , cA = Te("div", {
    class: "fixed pb-14 w-full bottom-0 flex md:hidden bg-gradient-to-t from-black bg-opacity-100 pointer-events-none"
}, null, -1)
    , rb = Xe({
    __name: "modal",
    props: {
        size: {
            type: String,
            default: "max-w-5xl"
        },
        popup: {
            type: Boolean,
            default: !1
        },
        auto: {
            type: Boolean,
            default: !1
        },
        show: {
            type: Boolean,
            default: !1
        },
        controllable: {
            type: Boolean,
            default: !1
        },
        closeButton: {
            type: Boolean,
            default: !0
        },
        parent: {
            type: Boolean,
            default: !1
        },
        background: {
            type: Boolean,
            default: !1
        },
        dark: {
            type: Boolean,
            default: !1
        }
    },
    emits: ["close"],
    setup(e, {expose: t, emit: n}) {
        const r = e
            , i = TO()
            , s = X(!1)
            , o = Ri(r, "controllable")
            , a = Ri(r, "show")
            , l = Lf()
            , c = fe(()=>l.value && (o.value ? a.value : s.value))
            , u = X()
            , f = X()
            , d = X()
            , {height: h} = mh(f)
            , {height: y} = mh(d)
            , {activate: p, deactivate: w} = oA(u, {
            allowOutsideClick: !0
        })
            , m = X(Math.random().toString())
            , g = fe(()=>i.currentOpened.value === m.value || i.parent.value === m.value)
            , b = fe(()=>c.value && g.value);
        Se(c, async T=>{
                T ? i.add(m.value, r.parent) : i.remove(m.value)
            }
        ),
            Se(b, async T=>{
                    T ? (await ct(),
                        p()) : w()
                }
            ),
            Kt(()=>{
                    i.remove(m.value)
                }
            );
        const v = fe(()=>h.value > y.value)
            , S = ()=>{
                s.value = !c.value
            }
            , _ = ()=>{
                s.value = !0
            }
            , E = ()=>{
                s.value = !1,
                    n("close")
            }
        ;
        return t({
            isOpened: c,
            toggle: S,
            open: _,
            close: E
        }),
            (T,P)=>{
                const I = CO
                    , L = Xy;
                return Ae(),
                    gt(L, null, {
                        default: mt(()=>[(Ae(),
                            gt(cc, {
                                to: "body"
                            }, [Re(Ur, {
                                "leave-active-class": "transition duration-150 ease-in pointer-events-none",
                                "leave-from-class": "opacity-100",
                                "leave-to-class": "opacity-0",
                                "enter-active-class": "transition duration-150 ease-in",
                                "enter-from-class": "opacity-0",
                                "enter-to-class": "opacity-100"
                            }, {
                                default: mt(()=>[we(b) ? (Ae(),
                                    Qe("div", {
                                        key: 0,
                                        class: Pt(["z-20 fixed left-0 right-0 bottom-0 top-0 bg-black", {
                                            "backdrop-blur-sm": e.background,
                                            "bg-opacity-60": e.background && !e.dark,
                                            "bg-opacity-90": e.background && e.dark,
                                            "bg-opacity-0": !e.background
                                        }]),
                                        onClick: E
                                    }, null, 2)) : Wt("", !0)]),
                                _: 1
                            })])), Re(I, {
                            active: we(b)
                        }, null, 8, ["active"]), (Ae(),
                            gt(cc, {
                                to: "body"
                            }, [Te("div", {
                                ref_key: "main",
                                ref: u,
                                class: "absolute pointer-events-none"
                            }, [Re(Ur, {
                                "leave-active-class": "transition-all duration-100 ease-in",
                                "leave-from-class": "opacity-100 translate-y-0 scale-100",
                                "leave-to-class": "opacity-0 translate-y-6 scale-90",
                                "enter-active-class": "transition-all duration-100 ease-in",
                                "enter-from-class": "opacity-0 translate-y-6 scale-90",
                                "enter-to-class": "opacity-100 translate-y-0 scale-100"
                            }, {
                                default: mt(()=>[we(b) ? (Ae(),
                                    Qe("div", aA, [Te("div", {
                                        class: Pt([{
                                            "justify-center": we(v) && !e.popup,
                                            [e.size]: !e.popup,
                                            "px-2 pt-14 pb-14": !e.popup,
                                            "px-2 pb-14": e.popup,
                                            "justify-end": e.popup
                                        }, "flex flex-col items-center h-vh container overflow-y-auto pointer-events-auto mx-auto focus:outline-none"]),
                                        onClick: ev(E, ["self"]),
                                        ref_key: "parent",
                                        ref: f,
                                        tabindex: "0"
                                    }, [cA, Te("div", {
                                        class: Pt(["relative", {
                                            "w-full h-full": !e.auto || e.popup
                                        }]),
                                        ref_key: "container",
                                        ref: d
                                    }, [Wi(T.$slots, "default"), e.closeButton && !e.popup ? (Ae(),
                                        Qe("button", {
                                            key: 0,
                                            onClick: E,
                                            type: "button",
                                            class: "absolute right-3 top-3 leading-1 px-2 py-2 bt"
                                        }, [Re(we(Ky), {
                                            class: "h-5 w-5"
                                        })])) : Wt("", !0)], 2)], 10, lA)])) : Wt("", !0)]),
                                _: 3
                            })], 512)]))]),
                        _: 3
                    })
            }
    }
});
function Cn(e, t, ...n) {
    if (e in t) {
        let i = t[e];
        return typeof i == "function" ? i(...n) : i
    }
    let r = new Error(`Tried to handle "${e}" but there is no handler defined. Only defined handlers are: ${Object.keys(t).map(i=>`"${i}"`).join(", ")}.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, Cn),
        r
}
var qc = (e=>(e[e.None = 0] = "None",
    e[e.RenderStrategy = 1] = "RenderStrategy",
    e[e.Static = 2] = "Static",
    e))(qc || {})
    , uA = (e=>(e[e.Unmount = 0] = "Unmount",
    e[e.Hidden = 1] = "Hidden",
    e))(uA || {});
function io({visible: e=!0, features: t=0, ourProps: n, theirProps: r, ...i}) {
    var s;
    let o = sb(r, n)
        , a = Object.assign(i, {
        props: o
    });
    if (e || t & 2 && o.static)
        return Fl(a);
    if (t & 1) {
        let l = (s = o.unmount) == null || s ? 0 : 1;
        return Cn(l, {
            [0]() {
                return null
            },
            [1]() {
                return Fl({
                    ...i,
                    props: {
                        ...o,
                        hidden: !0,
                        style: {
                            display: "none"
                        }
                    }
                })
            }
        })
    }
    return Fl(a)
}
function Fl({props: e, attrs: t, slots: n, slot: r, name: i}) {
    var s, o;
    let {as: a, ...l} = ob(e, ["unmount", "static"])
        , c = (s = n.default) == null ? void 0 : s.call(n, r)
        , u = {};
    if (r) {
        let f = !1
            , d = [];
        for (let[h,y] of Object.entries(r))
            typeof y == "boolean" && (f = !0),
            y === !0 && d.push(h);
        f && (u["data-headlessui-state"] = d.join(" "))
    }
    if (a === "template") {
        if (c = ib(c ?? []),
        Object.keys(l).length > 0 || Object.keys(t).length > 0) {
            let[f,...d] = c ?? [];
            if (!dA(f) || d.length > 0)
                throw new Error(['Passing props on "template"!', "", `The current component <${i} /> is rendering a "template".`, "However we need to passthrough the following props:", Object.keys(l).concat(Object.keys(t)).map(p=>p.trim()).filter((p,w,m)=>m.indexOf(p) === w).sort((p,w)=>p.localeCompare(w)).map(p=>`  - ${p}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".', "Render a single element as the child so that we can forward the props onto that element."].map(p=>`  - ${p}`).join(`
`)].join(`
`));
            let h = sb((o = f.props) != null ? o : {}, l)
                , y = Tn(f, h);
            for (let p in h)
                p.startsWith("on") && (y.props || (y.props = {}),
                    y.props[p] = h[p]);
            return y
        }
        return Array.isArray(c) && c.length === 1 ? c[0] : c
    }
    return yt(a, Object.assign({}, l, u), {
        default: ()=>c
    })
}
function ib(e) {
    return e.flatMap(t=>t.type === nt ? ib(t.children) : [t])
}
function sb(...e) {
    if (e.length === 0)
        return {};
    if (e.length === 1)
        return e[0];
    let t = {}
        , n = {};
    for (let r of e)
        for (let i in r)
            i.startsWith("on") && typeof r[i] == "function" ? (n[i] != null || (n[i] = []),
                n[i].push(r[i])) : t[i] = r[i];
    if (t.disabled || t["aria-disabled"])
        return Object.assign(t, Object.fromEntries(Object.keys(n).map(r=>[r, void 0])));
    for (let r in n)
        Object.assign(t, {
            [r](i, ...s) {
                let o = n[r];
                for (let a of o) {
                    if (i instanceof Event && i.defaultPrevented)
                        return;
                    a(i, ...s)
                }
            }
        });
    return t
}
function fA(e) {
    let t = Object.assign({}, e);
    for (let n in t)
        t[n] === void 0 && delete t[n];
    return t
}
function ob(e, t=[]) {
    let n = Object.assign({}, e);
    for (let r of t)
        r in n && delete n[r];
    return n
}
function dA(e) {
    return e == null ? !1 : typeof e.type == "string" || typeof e.type == "object" || typeof e.type == "function"
}
let pA = 0;
function hA() {
    return ++pA
}
function Of() {
    return hA()
}
var bt = (e=>(e.Space = " ",
    e.Enter = "Enter",
    e.Escape = "Escape",
    e.Backspace = "Backspace",
    e.Delete = "Delete",
    e.ArrowLeft = "ArrowLeft",
    e.ArrowUp = "ArrowUp",
    e.ArrowRight = "ArrowRight",
    e.ArrowDown = "ArrowDown",
    e.Home = "Home",
    e.End = "End",
    e.PageUp = "PageUp",
    e.PageDown = "PageDown",
    e.Tab = "Tab",
    e))(bt || {});
function mA(e) {
    throw new Error("Unexpected object: " + e)
}
var Nt = (e=>(e[e.First = 0] = "First",
    e[e.Previous = 1] = "Previous",
    e[e.Next = 2] = "Next",
    e[e.Last = 3] = "Last",
    e[e.Specific = 4] = "Specific",
    e[e.Nothing = 5] = "Nothing",
    e))(Nt || {});
function gA(e, t) {
    let n = t.resolveItems();
    if (n.length <= 0)
        return null;
    let r = t.resolveActiveIndex()
        , i = r ?? -1
        , s = (()=>{
            switch (e.focus) {
                case 0:
                    return n.findIndex(o=>!t.resolveDisabled(o));
                case 1:
                {
                    let o = n.slice().reverse().findIndex((a,l,c)=>i !== -1 && c.length - l - 1 >= i ? !1 : !t.resolveDisabled(a));
                    return o === -1 ? o : n.length - 1 - o
                }
                case 2:
                    return n.findIndex((o,a)=>a <= i ? !1 : !t.resolveDisabled(o));
                case 3:
                {
                    let o = n.slice().reverse().findIndex(a=>!t.resolveDisabled(a));
                    return o === -1 ? o : n.length - 1 - o
                }
                case 4:
                    return n.findIndex(o=>t.resolveId(o) === e.id);
                case 5:
                    return null;
                default:
                    mA(e)
            }
        }
    )();
    return s === -1 ? r : s
}
function lt(e) {
    var t;
    return e == null || e.value == null ? null : (t = e.value.$el) != null ? t : e.value
}
let ab = Symbol("Context");
var zs = (e=>(e[e.Open = 1] = "Open",
    e[e.Closed = 2] = "Closed",
    e[e.Closing = 4] = "Closing",
    e[e.Opening = 8] = "Opening",
    e))(zs || {});
function vA() {
    return vt(ab, null)
}
function yA(e) {
    Dn(ab, e)
}
function Oh(e, t) {
    if (e)
        return e;
    let n = t ?? "button";
    if (typeof n == "string" && n.toLowerCase() === "button")
        return "button"
}
function bA(e, t) {
    let n = X(Oh(e.value.type, e.value.as));
    return Ve(()=>{
            n.value = Oh(e.value.type, e.value.as)
        }
    ),
        Er(()=>{
                var r;
                n.value || lt(t) && lt(t)instanceof HTMLButtonElement && !((r = lt(t)) != null && r.hasAttribute("type")) && (n.value = "button")
            }
        ),
        n
}
var wA = Object.defineProperty
    , SA = (e,t,n)=>t in e ? wA(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
}) : e[t] = n
    , Ah = (e,t,n)=>(SA(e, typeof t != "symbol" ? t + "" : t, n),
    n);
let _A = class {
    constructor() {
        Ah(this, "current", this.detect()),
            Ah(this, "currentId", 0)
    }
    set(t) {
        this.current !== t && (this.currentId = 0,
            this.current = t)
    }
    reset() {
        this.set(this.detect())
    }
    nextId() {
        return ++this.currentId
    }
    get isServer() {
        return this.current === "server"
    }
    get isClient() {
        return this.current === "client"
    }
    detect() {
        return typeof window > "u" || typeof document > "u" ? "server" : "client"
    }
}
    , Af = new _A;
function EA(e) {
    if (Af.isServer)
        return null;
    if (e instanceof Node)
        return e.ownerDocument;
    if (e != null && e.hasOwnProperty("value")) {
        let t = lt(e);
        if (t)
            return t.ownerDocument
    }
    return document
}
let Ih = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map(e=>`${e}:not([tabindex='-1'])`).join(",");
var CA = (e=>(e[e.First = 1] = "First",
    e[e.Previous = 2] = "Previous",
    e[e.Next = 4] = "Next",
    e[e.Last = 8] = "Last",
    e[e.WrapAround = 16] = "WrapAround",
    e[e.NoScroll = 32] = "NoScroll",
    e))(CA || {})
    , TA = (e=>(e[e.Error = 0] = "Error",
    e[e.Overflow = 1] = "Overflow",
    e[e.Success = 2] = "Success",
    e[e.Underflow = 3] = "Underflow",
    e))(TA || {})
    , xA = (e=>(e[e.Previous = -1] = "Previous",
    e[e.Next = 1] = "Next",
    e))(xA || {})
    , If = (e=>(e[e.Strict = 0] = "Strict",
    e[e.Loose = 1] = "Loose",
    e))(If || {});
function lb(e, t=0) {
    var n;
    return e === ((n = EA(e)) == null ? void 0 : n.body) ? !1 : Cn(t, {
        [0]() {
            return e.matches(Ih)
        },
        [1]() {
            let r = e;
            for (; r !== null; ) {
                if (r.matches(Ih))
                    return !0;
                r = r.parentElement
            }
            return !1
        }
    })
}
var PA = (e=>(e[e.Keyboard = 0] = "Keyboard",
    e[e.Mouse = 1] = "Mouse",
    e))(PA || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", e=>{
        e.metaKey || e.altKey || e.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "")
    }
    , !0),
    document.addEventListener("click", e=>{
            e.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "")
        }
        , !0));
function kA(e, t=n=>n) {
    return e.slice().sort((n,r)=>{
            let i = t(n)
                , s = t(r);
            if (i === null || s === null)
                return 0;
            let o = i.compareDocumentPosition(s);
            return o & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : o & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0
        }
    )
}
function Ao(e, t, n) {
    Af.isServer || Er(r=>{
            document.addEventListener(e, t, n),
                r(()=>document.removeEventListener(e, t, n))
        }
    )
}
function RA(e, t, n) {
    Af.isServer || Er(r=>{
            window.addEventListener(e, t, n),
                r(()=>window.removeEventListener(e, t, n))
        }
    )
}
function LA(e, t, n=fe(()=>!0)) {
    function r(s, o) {
        if (!n.value || s.defaultPrevented)
            return;
        let a = o(s);
        if (a === null || !a.getRootNode().contains(a))
            return;
        let l = function c(u) {
            return typeof u == "function" ? c(u()) : Array.isArray(u) || u instanceof Set ? u : [u]
        }(e);
        for (let c of l) {
            if (c === null)
                continue;
            let u = c instanceof HTMLElement ? c : lt(c);
            if (u != null && u.contains(a) || s.composed && s.composedPath().includes(u))
                return
        }
        return !lb(a, If.Loose) && a.tabIndex !== -1 && s.preventDefault(),
            t(s, a)
    }
    let i = X(null);
    Ao("pointerdown", s=>{
            var o, a;
            n.value && (i.value = ((a = (o = s.composedPath) == null ? void 0 : o.call(s)) == null ? void 0 : a[0]) || s.target)
        }
        , !0),
        Ao("mousedown", s=>{
                var o, a;
                n.value && (i.value = ((a = (o = s.composedPath) == null ? void 0 : o.call(s)) == null ? void 0 : a[0]) || s.target)
            }
            , !0),
        Ao("click", s=>{
                i.value && (r(s, ()=>i.value),
                    i.value = null)
            }
            , !0),
        Ao("touchend", s=>r(s, ()=>s.target instanceof HTMLElement ? s.target : null), !0),
        RA("blur", s=>r(s, ()=>window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0)
}
var cb = (e=>(e[e.None = 1] = "None",
    e[e.Focusable = 2] = "Focusable",
    e[e.Hidden = 4] = "Hidden",
    e))(cb || {});
let OA = Xe({
    name: "Hidden",
    props: {
        as: {
            type: [Object, String],
            default: "div"
        },
        features: {
            type: Number,
            default: 1
        }
    },
    setup(e, {slots: t, attrs: n}) {
        return ()=>{
            let {features: r, ...i} = e
                , s = {
                "aria-hidden": (r & 2) === 2 ? !0 : void 0,
                style: {
                    position: "fixed",
                    top: 1,
                    left: 1,
                    width: 1,
                    height: 0,
                    padding: 0,
                    margin: -1,
                    overflow: "hidden",
                    clip: "rect(0, 0, 0, 0)",
                    whiteSpace: "nowrap",
                    borderWidth: "0",
                    ...(r & 4) === 4 && (r & 2) !== 2 && {
                        display: "none"
                    }
                }
            };
            return io({
                ourProps: s,
                theirProps: i,
                slot: {},
                attrs: n,
                slots: t,
                name: "Hidden"
            })
        }
    }
});
function ub(e={}, t=null, n=[]) {
    for (let[r,i] of Object.entries(e))
        db(n, fb(t, r), i);
    return n
}
function fb(e, t) {
    return e ? e + "[" + t + "]" : t
}
function db(e, t, n) {
    if (Array.isArray(n))
        for (let[r,i] of n.entries())
            db(e, fb(t, r.toString()), i);
    else
        n instanceof Date ? e.push([t, n.toISOString()]) : typeof n == "boolean" ? e.push([t, n ? "1" : "0"]) : typeof n == "string" ? e.push([t, n]) : typeof n == "number" ? e.push([t, `${n}`]) : n == null ? e.push([t, ""]) : ub(n, t, e)
}
function dF(e) {
    var t;
    let n = (t = e == null ? void 0 : e.form) != null ? t : e.closest("form");
    if (n) {
        for (let r of n.elements)
            if (r.tagName === "INPUT" && r.type === "submit" || r.tagName === "BUTTON" && r.type === "submit" || r.nodeName === "INPUT" && r.type === "image") {
                r.click();
                return
            }
        n.requestSubmit()
    }
}
function AA(e, t, n) {
    let r = X(n == null ? void 0 : n.value)
        , i = fe(()=>e.value !== void 0);
    return [fe(()=>i.value ? e.value : r.value), function(s) {
        return i.value || (r.value = s),
            t == null ? void 0 : t(s)
    }
    ]
}
function Mh(e) {
    return [e.screenX, e.screenY]
}
function IA() {
    let e = X([-1, -1]);
    return {
        wasMoved(t) {
            let n = Mh(t);
            return e.value[0] === n[0] && e.value[1] === n[1] ? !1 : (e.value = n,
                !0)
        },
        update(t) {
            e.value = Mh(t)
        }
    }
}
let Dh = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function Nh(e) {
    var t, n;
    let r = (t = e.innerText) != null ? t : ""
        , i = e.cloneNode(!0);
    if (!(i instanceof HTMLElement))
        return r;
    let s = !1;
    for (let a of i.querySelectorAll('[hidden],[aria-hidden],[role="img"]'))
        a.remove(),
            s = !0;
    let o = s ? (n = i.innerText) != null ? n : "" : r;
    return Dh.test(o) && (o = o.replace(Dh, "")),
        o
}
function MA(e) {
    let t = e.getAttribute("aria-label");
    if (typeof t == "string")
        return t.trim();
    let n = e.getAttribute("aria-labelledby");
    if (n) {
        let r = n.split(" ").map(i=>{
                let s = document.getElementById(i);
                if (s) {
                    let o = s.getAttribute("aria-label");
                    return typeof o == "string" ? o.trim() : Nh(s).trim()
                }
                return null
            }
        ).filter(Boolean);
        if (r.length > 0)
            return r.join(", ")
    }
    return Nh(e).trim()
}
function DA(e) {
    let t = X("")
        , n = X("");
    return ()=>{
        let r = lt(e);
        if (!r)
            return "";
        let i = r.innerText;
        if (t.value === i)
            return n.value;
        let s = MA(r).trim().toLowerCase();
        return t.value = i,
            n.value = s,
            s
    }
}
function NA(e, t) {
    return e === t
}
var $A = (e=>(e[e.Open = 0] = "Open",
    e[e.Closed = 1] = "Closed",
    e))($A || {})
    , FA = (e=>(e[e.Single = 0] = "Single",
    e[e.Multi = 1] = "Multi",
    e))(FA || {})
    , jA = (e=>(e[e.Pointer = 0] = "Pointer",
    e[e.Other = 1] = "Other",
    e))(jA || {});
function HA(e) {
    requestAnimationFrame(()=>requestAnimationFrame(e))
}
let pb = Symbol("ListboxContext");
function ul(e) {
    let t = vt(pb, null);
    if (t === null) {
        let n = new Error(`<${e} /> is missing a parent <Listbox /> component.`);
        throw Error.captureStackTrace && Error.captureStackTrace(n, ul),
            n
    }
    return t
}
let BA = Xe({
    name: "Listbox",
    emits: {
        "update:modelValue": e=>!0
    },
    props: {
        as: {
            type: [Object, String],
            default: "template"
        },
        disabled: {
            type: [Boolean],
            default: !1
        },
        by: {
            type: [String, Function],
            default: ()=>NA
        },
        horizontal: {
            type: [Boolean],
            default: !1
        },
        modelValue: {
            type: [Object, String, Number, Boolean],
            default: void 0
        },
        defaultValue: {
            type: [Object, String, Number, Boolean],
            default: void 0
        },
        form: {
            type: String,
            optional: !0
        },
        name: {
            type: String,
            optional: !0
        },
        multiple: {
            type: [Boolean],
            default: !1
        }
    },
    inheritAttrs: !1,
    setup(e, {slots: t, attrs: n, emit: r}) {
        let i = X(1)
            , s = X(null)
            , o = X(null)
            , a = X(null)
            , l = X([])
            , c = X("")
            , u = X(null)
            , f = X(1);
        function d(g=b=>b) {
            let b = u.value !== null ? l.value[u.value] : null
                , v = kA(g(l.value.slice()), _=>lt(_.dataRef.domRef))
                , S = b ? v.indexOf(b) : null;
            return S === -1 && (S = null),
                {
                    options: v,
                    activeOptionIndex: S
                }
        }
        let h = fe(()=>e.multiple ? 1 : 0)
            , [y,p] = AA(fe(()=>e.modelValue === void 0 ? Cn(h.value, {
            [1]: [],
            [0]: void 0
        }) : e.modelValue), g=>r("update:modelValue", g), fe(()=>e.defaultValue))
            , w = {
            listboxState: i,
            value: y,
            mode: h,
            compare(g, b) {
                if (typeof e.by == "string") {
                    let v = e.by;
                    return (g == null ? void 0 : g[v]) === (b == null ? void 0 : b[v])
                }
                return e.by(g, b)
            },
            orientation: fe(()=>e.horizontal ? "horizontal" : "vertical"),
            labelRef: s,
            buttonRef: o,
            optionsRef: a,
            disabled: fe(()=>e.disabled),
            options: l,
            searchQuery: c,
            activeOptionIndex: u,
            activationTrigger: f,
            closeListbox() {
                e.disabled || i.value !== 1 && (i.value = 1,
                    u.value = null)
            },
            openListbox() {
                e.disabled || i.value !== 0 && (i.value = 0)
            },
            goToOption(g, b, v) {
                if (e.disabled || i.value === 1)
                    return;
                let S = d()
                    , _ = gA(g === Nt.Specific ? {
                    focus: Nt.Specific,
                    id: b
                } : {
                    focus: g
                }, {
                    resolveItems: ()=>S.options,
                    resolveActiveIndex: ()=>S.activeOptionIndex,
                    resolveId: E=>E.id,
                    resolveDisabled: E=>E.dataRef.disabled
                });
                c.value = "",
                    u.value = _,
                    f.value = v ?? 1,
                    l.value = S.options
            },
            search(g) {
                if (e.disabled || i.value === 1)
                    return;
                let b = c.value !== "" ? 0 : 1;
                c.value += g.toLowerCase();
                let v = (u.value !== null ? l.value.slice(u.value + b).concat(l.value.slice(0, u.value + b)) : l.value).find(_=>_.dataRef.textValue.startsWith(c.value) && !_.dataRef.disabled)
                    , S = v ? l.value.indexOf(v) : -1;
                S === -1 || S === u.value || (u.value = S,
                    f.value = 1)
            },
            clearSearch() {
                e.disabled || i.value !== 1 && c.value !== "" && (c.value = "")
            },
            registerOption(g, b) {
                let v = d(S=>[...S, {
                    id: g,
                    dataRef: b
                }]);
                l.value = v.options,
                    u.value = v.activeOptionIndex
            },
            unregisterOption(g) {
                let b = d(v=>{
                        let S = v.findIndex(_=>_.id === g);
                        return S !== -1 && v.splice(S, 1),
                            v
                    }
                );
                l.value = b.options,
                    u.value = b.activeOptionIndex,
                    f.value = 1
            },
            select(g) {
                e.disabled || p(Cn(h.value, {
                    [0]: ()=>g,
                    [1]: ()=>{
                        let b = ke(w.value.value).slice()
                            , v = ke(g)
                            , S = b.findIndex(_=>w.compare(v, ke(_)));
                        return S === -1 ? b.push(v) : b.splice(S, 1),
                            b
                    }
                }))
            }
        };
        LA([o, a], (g,b)=>{
                var v;
                w.closeListbox(),
                lb(b, If.Loose) || (g.preventDefault(),
                (v = lt(o)) == null || v.focus())
            }
            , fe(()=>i.value === 0)),
            Dn(pb, w),
            yA(fe(()=>Cn(i.value, {
                [0]: zs.Open,
                [1]: zs.Closed
            })));
        let m = fe(()=>{
                var g;
                return (g = lt(o)) == null ? void 0 : g.closest("form")
            }
        );
        return Ve(()=>{
                Se([m], ()=>{
                        if (!m.value || e.defaultValue === void 0)
                            return;
                        function g() {
                            w.select(e.defaultValue)
                        }
                        return m.value.addEventListener("reset", g),
                            ()=>{
                                var b;
                                (b = m.value) == null || b.removeEventListener("reset", g)
                            }
                    }
                    , {
                        immediate: !0
                    })
            }
        ),
            ()=>{
                let {name: g, modelValue: b, disabled: v, form: S, ..._} = e
                    , E = {
                    open: i.value === 0,
                    disabled: v,
                    value: y.value
                };
                return yt(nt, [...g != null && y.value != null ? ub({
                    [g]: y.value
                }).map(([T,P])=>yt(OA, fA({
                    features: cb.Hidden,
                    key: T,
                    as: "input",
                    type: "hidden",
                    hidden: !0,
                    readOnly: !0,
                    form: S,
                    name: T,
                    value: P
                }))) : [], io({
                    ourProps: {},
                    theirProps: {
                        ...n,
                        ...ob(_, ["defaultValue", "onUpdate:modelValue", "horizontal", "multiple", "by"])
                    },
                    slot: E,
                    slots: t,
                    attrs: n,
                    name: "Listbox"
                })])
            }
    }
})
    , VA = Xe({
    name: "ListboxButton",
    props: {
        as: {
            type: [Object, String],
            default: "button"
        },
        id: {
            type: String,
            default: ()=>`headlessui-listbox-button-${Of()}`
        }
    },
    setup(e, {attrs: t, slots: n, expose: r}) {
        let i = ul("ListboxButton");
        r({
            el: i.buttonRef,
            $el: i.buttonRef
        });
        function s(c) {
            switch (c.key) {
                case bt.Space:
                case bt.Enter:
                case bt.ArrowDown:
                    c.preventDefault(),
                        i.openListbox(),
                        ct(()=>{
                                var u;
                                (u = lt(i.optionsRef)) == null || u.focus({
                                    preventScroll: !0
                                }),
                                i.value.value || i.goToOption(Nt.First)
                            }
                        );
                    break;
                case bt.ArrowUp:
                    c.preventDefault(),
                        i.openListbox(),
                        ct(()=>{
                                var u;
                                (u = lt(i.optionsRef)) == null || u.focus({
                                    preventScroll: !0
                                }),
                                i.value.value || i.goToOption(Nt.Last)
                            }
                        );
                    break
            }
        }
        function o(c) {
            switch (c.key) {
                case bt.Space:
                    c.preventDefault();
                    break
            }
        }
        function a(c) {
            i.disabled.value || (i.listboxState.value === 0 ? (i.closeListbox(),
                ct(()=>{
                        var u;
                        return (u = lt(i.buttonRef)) == null ? void 0 : u.focus({
                            preventScroll: !0
                        })
                    }
                )) : (c.preventDefault(),
                i.openListbox(),
                HA(()=>{
                        var u;
                        return (u = lt(i.optionsRef)) == null ? void 0 : u.focus({
                            preventScroll: !0
                        })
                    }
                )))
        }
        let l = bA(fe(()=>({
            as: e.as,
            type: t.type
        })), i.buttonRef);
        return ()=>{
            var c, u;
            let f = {
                open: i.listboxState.value === 0,
                disabled: i.disabled.value,
                value: i.value.value
            }
                , {id: d, ...h} = e
                , y = {
                ref: i.buttonRef,
                id: d,
                type: l.value,
                "aria-haspopup": "listbox",
                "aria-controls": (c = lt(i.optionsRef)) == null ? void 0 : c.id,
                "aria-expanded": i.listboxState.value === 0,
                "aria-labelledby": i.labelRef.value ? [(u = lt(i.labelRef)) == null ? void 0 : u.id, d].join(" ") : void 0,
                disabled: i.disabled.value === !0 ? !0 : void 0,
                onKeydown: s,
                onKeyup: o,
                onClick: a
            };
            return io({
                ourProps: y,
                theirProps: h,
                slot: f,
                attrs: t,
                slots: n,
                name: "ListboxButton"
            })
        }
    }
})
    , zA = Xe({
    name: "ListboxOptions",
    props: {
        as: {
            type: [Object, String],
            default: "ul"
        },
        static: {
            type: Boolean,
            default: !1
        },
        unmount: {
            type: Boolean,
            default: !0
        },
        id: {
            type: String,
            default: ()=>`headlessui-listbox-options-${Of()}`
        }
    },
    setup(e, {attrs: t, slots: n, expose: r}) {
        let i = ul("ListboxOptions")
            , s = X(null);
        r({
            el: i.optionsRef,
            $el: i.optionsRef
        });
        function o(c) {
            switch (s.value && clearTimeout(s.value),
                c.key) {
                case bt.Space:
                    if (i.searchQuery.value !== "")
                        return c.preventDefault(),
                            c.stopPropagation(),
                            i.search(c.key);
                case bt.Enter:
                    if (c.preventDefault(),
                        c.stopPropagation(),
                    i.activeOptionIndex.value !== null) {
                        let u = i.options.value[i.activeOptionIndex.value];
                        i.select(u.dataRef.value)
                    }
                    i.mode.value === 0 && (i.closeListbox(),
                        ct(()=>{
                                var u;
                                return (u = lt(i.buttonRef)) == null ? void 0 : u.focus({
                                    preventScroll: !0
                                })
                            }
                        ));
                    break;
                case Cn(i.orientation.value, {
                    vertical: bt.ArrowDown,
                    horizontal: bt.ArrowRight
                }):
                    return c.preventDefault(),
                        c.stopPropagation(),
                        i.goToOption(Nt.Next);
                case Cn(i.orientation.value, {
                    vertical: bt.ArrowUp,
                    horizontal: bt.ArrowLeft
                }):
                    return c.preventDefault(),
                        c.stopPropagation(),
                        i.goToOption(Nt.Previous);
                case bt.Home:
                case bt.PageUp:
                    return c.preventDefault(),
                        c.stopPropagation(),
                        i.goToOption(Nt.First);
                case bt.End:
                case bt.PageDown:
                    return c.preventDefault(),
                        c.stopPropagation(),
                        i.goToOption(Nt.Last);
                case bt.Escape:
                    c.preventDefault(),
                        c.stopPropagation(),
                        i.closeListbox(),
                        ct(()=>{
                                var u;
                                return (u = lt(i.buttonRef)) == null ? void 0 : u.focus({
                                    preventScroll: !0
                                })
                            }
                        );
                    break;
                case bt.Tab:
                    c.preventDefault(),
                        c.stopPropagation();
                    break;
                default:
                    c.key.length === 1 && (i.search(c.key),
                        s.value = setTimeout(()=>i.clearSearch(), 350));
                    break
            }
        }
        let a = vA()
            , l = fe(()=>a !== null ? (a.value & zs.Open) === zs.Open : i.listboxState.value === 0);
        return ()=>{
            var c, u, f, d;
            let h = {
                open: i.listboxState.value === 0
            }
                , {id: y, ...p} = e
                , w = {
                "aria-activedescendant": i.activeOptionIndex.value === null || (c = i.options.value[i.activeOptionIndex.value]) == null ? void 0 : c.id,
                "aria-multiselectable": i.mode.value === 1 ? !0 : void 0,
                "aria-labelledby": (d = (u = lt(i.labelRef)) == null ? void 0 : u.id) != null ? d : (f = lt(i.buttonRef)) == null ? void 0 : f.id,
                "aria-orientation": i.orientation.value,
                id: y,
                onKeydown: o,
                role: "listbox",
                tabIndex: 0,
                ref: i.optionsRef
            };
            return io({
                ourProps: w,
                theirProps: p,
                slot: h,
                attrs: t,
                slots: n,
                features: qc.RenderStrategy | qc.Static,
                visible: l.value,
                name: "ListboxOptions"
            })
        }
    }
})
    , UA = Xe({
    name: "ListboxOption",
    props: {
        as: {
            type: [Object, String],
            default: "li"
        },
        value: {
            type: [Object, String, Number, Boolean]
        },
        disabled: {
            type: Boolean,
            default: !1
        },
        id: {
            type: String,
            default: ()=>`headlessui-listbox.option-${Of()}`
        }
    },
    setup(e, {slots: t, attrs: n, expose: r}) {
        let i = ul("ListboxOption")
            , s = X(null);
        r({
            el: s,
            $el: s
        });
        let o = fe(()=>i.activeOptionIndex.value !== null ? i.options.value[i.activeOptionIndex.value].id === e.id : !1)
            , a = fe(()=>Cn(i.mode.value, {
            [0]: ()=>i.compare(ke(i.value.value), ke(e.value)),
            [1]: ()=>ke(i.value.value).some(m=>i.compare(ke(m), ke(e.value)))
        }))
            , l = fe(()=>Cn(i.mode.value, {
            [1]: ()=>{
                var m;
                let g = ke(i.value.value);
                return ((m = i.options.value.find(b=>g.some(v=>i.compare(ke(v), ke(b.dataRef.value))))) == null ? void 0 : m.id) === e.id
            }
            ,
            [0]: ()=>a.value
        }))
            , c = DA(s)
            , u = fe(()=>({
            disabled: e.disabled,
            value: e.value,
            get textValue() {
                return c()
            },
            domRef: s
        }));
        Ve(()=>i.registerOption(e.id, u)),
            Kt(()=>i.unregisterOption(e.id)),
            Ve(()=>{
                    Se([i.listboxState, a], ()=>{
                            i.listboxState.value === 0 && a.value && Cn(i.mode.value, {
                                [1]: ()=>{
                                    l.value && i.goToOption(Nt.Specific, e.id)
                                }
                                ,
                                [0]: ()=>{
                                    i.goToOption(Nt.Specific, e.id)
                                }
                            })
                        }
                        , {
                            immediate: !0
                        })
                }
            ),
            Er(()=>{
                    i.listboxState.value === 0 && o.value && i.activationTrigger.value !== 0 && ct(()=>{
                            var m, g;
                            return (g = (m = lt(s)) == null ? void 0 : m.scrollIntoView) == null ? void 0 : g.call(m, {
                                block: "nearest"
                            })
                        }
                    )
                }
            );
        function f(m) {
            if (e.disabled)
                return m.preventDefault();
            i.select(e.value),
            i.mode.value === 0 && (i.closeListbox(),
                ct(()=>{
                        var g;
                        return (g = lt(i.buttonRef)) == null ? void 0 : g.focus({
                            preventScroll: !0
                        })
                    }
                ))
        }
        function d() {
            if (e.disabled)
                return i.goToOption(Nt.Nothing);
            i.goToOption(Nt.Specific, e.id)
        }
        let h = IA();
        function y(m) {
            h.update(m)
        }
        function p(m) {
            h.wasMoved(m) && (e.disabled || o.value || i.goToOption(Nt.Specific, e.id, 0))
        }
        function w(m) {
            h.wasMoved(m) && (e.disabled || o.value && i.goToOption(Nt.Nothing))
        }
        return ()=>{
            let {disabled: m} = e
                , g = {
                active: o.value,
                selected: a.value,
                disabled: m
            }
                , {id: b, value: v, disabled: S, ..._} = e
                , E = {
                id: b,
                ref: s,
                role: "option",
                tabIndex: m === !0 ? void 0 : -1,
                "aria-disabled": m === !0 ? !0 : void 0,
                "aria-selected": a.value,
                disabled: void 0,
                onClick: f,
                onFocus: d,
                onPointerenter: y,
                onMouseenter: y,
                onPointermove: p,
                onMousemove: p,
                onPointerleave: w,
                onMouseleave: w
            };
            return io({
                ourProps: E,
                theirProps: _,
                slot: g,
                attrs: n,
                slots: t,
                name: "ListboxOption"
            })
        }
    }
});
const WA = {
    class: "relative mt-1"
}
    , GA = {
    key: 1,
    class: "flex flex-1 items-center flex-row gap-3"
}
    , XA = {
    key: 0,
    class: "flex"
}
    , KA = {
    class: "block truncate font-medium"
}
    , YA = {
    class: "pointer-events-none absolute inset-y-0 right-0 flex items-center pr-2"
}
    , qA = {
    key: 1,
    class: "absolute inset-y-0 left-0 flex items-center pl-3 text-indigo-600"
}
    , JA = Xe({
    __name: "simple-select",
    props: {
        placeholder: {
            type: Object
        },
        value: {
            type: Object
        },
        values: {
            type: Array
        },
        items: {
            type: Array,
            required: !0
        },
        multiple: {
            type: Boolean,
            default: !1
        },
        defaultName: {
            type: String,
            default: "Default"
        },
        defaultNames: {
            type: String,
            default: "Default"
        }
    },
    emits: ["change", "select"],
    setup(e) {
        const t = e
            , n = fe(()=>{
                var l;
                return ((l = t.values) == null ? void 0 : l.length) || 0
            }
        )
            , r = fe(()=>n.value > 3 ? ", ..." : "")
            , i = fe(()=>{
                var l;
                return (l = t.values) == null ? void 0 : l.map(c=>c.label).slice(0, 3)
            }
        )
            , s = fe(()=>{
                var l, c, u;
                return (u = t.multiple ? ((c = i.value) == null ? void 0 : c.join(", ")) + r.value : (l = t.value) == null ? void 0 : l.label) == null ? void 0 : u.trim()
            }
        )
            , o = fe(()=>{
                var l, c, u, f;
                return t.multiple ? ((c = t.values) == null ? void 0 : c.length) === 1 ? (f = (u = t.values) == null ? void 0 : u[0]) == null ? void 0 : f.country : null : (l = t.value) == null ? void 0 : l.country
            }
        )
            , a = cl();
        return (l,c)=>{
            const u = LR
                , f = rb;
            return Ae(),
                gt(we(BA), {
                    "model-value": t.multiple ? t.values : t.value,
                    "onUpdate:modelValue": c[0] || (c[0] = d=>l.$emit("change", d)),
                    class: "text-gray-900 select-none",
                    multiple: e.multiple
                }, {
                    default: mt(({open: d, close: h})=>[Te("div", WA, [Re(we(VA), {
                        class: Pt([{
                            "!bg-opacity-100 ring-4 scale-[95%]": d
                        }, "block relative w-full cursor-pointer rounded-lg bg-white bg-opacity-80 py-2 pl-4 pr-10 text-left shadow-md focus:outline-none focus-visible:border-indigo-500 transition-all duration-100 active:scale-[95%] ring-indigo-400 hover:ring-[4px] focus:ring-[4px] active:ring-[8px] focus-visible:ring-[8px] sm:text-sm"])
                    }, {
                        default: mt(()=>[!we(s) && l.$slots.default ? Wi(l.$slots, "default", {
                            key: 0
                        }) : (Ae(),
                            Qe("span", GA, [we(o) ? (Ae(),
                                Qe("span", XA, [Re(u, {
                                    class: "relative rounded",
                                    country: we(o),
                                    size: "small"
                                }, null, 8, ["country"])])) : Wt("", !0), Te("span", KA, _n(we(s) || e.defaultName), 1)])), Te("span", YA, [Re(we(PO), {
                            class: "h-5 w-5 text-gray-400",
                            "aria-hidden": "true"
                        })])]),
                        _: 2
                    }, 1032, ["class"]), Re(f, {
                        controllable: "",
                        popup: "",
                        show: d,
                        background: we(a)
                    }, {
                        default: mt(()=>[Re(we(zA), {
                            class: "pointer-events-auto max-h-60 w-full overflow-auto rounded-md bg-white py-1 text-base shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none sm:text-sm"
                        }, {
                            default: mt(()=>[(Ae(!0),
                                Qe(nt, null, ju(t.items, (y,p)=>(Ae(),
                                    gt(we(UA), {
                                        onClick: w=>l.$emit("select", y),
                                        key: y.deviceId || y.label,
                                        value: y,
                                        as: "template"
                                    }, {
                                        default: mt(({active: w, selected: m})=>[Te("li", {
                                            class: Pt(["flex flex-row items-center gap-2", [w ? "bg-indigo-100 text-indigo-900" : "text-gray-900", "relative cursor-default select-none py-2 pl-10 pr-4 transition-all duration-100 active:ring-6 active:ring-indigo-200 active:bg-indigo-200 active:text-indigo-900"]])
                                        }, [y.country ? (Ae(),
                                            gt(u, {
                                                key: 0,
                                                class: "relative rounded",
                                                country: y.country,
                                                size: "small"
                                            }, null, 8, ["country"])) : Wt("", !0), Te("span", {
                                            class: Pt([m ? "font-medium" : "font-normal", "block truncate"])
                                        }, _n(y.label || e.defaultNames + " #" + (p + 1)), 3), m ? (Ae(),
                                            Qe("span", qA, [Re(we(xO), {
                                                class: "h-5 w-5",
                                                "aria-hidden": "true"
                                            })])) : Wt("", !0)], 2)]),
                                        _: 2
                                    }, 1032, ["onClick", "value"]))), 128))]),
                            _: 1
                        })]),
                        _: 2
                    }, 1032, ["show", "background"])])]),
                    _: 3
                }, 8, ["model-value", "multiple"])
        }
    }
})
    , $h = (e,t)=>{
    const r = Cr().public.appUrl;
    return $fetch(e, {
        ...t,
        ...r ? {
            baseURL: r,
            headers: {
                appcookie: document.cookie
            }
        } : {}
    })
}
    , hb = (e=1)=>new Promise(t=>setTimeout(t, e));
let mb = !0
    , gb = !0;
function jo(e, t, n) {
    const r = e.match(t);
    return r && r.length >= n && parseInt(r[n], 10)
}
function ni(e, t, n) {
    if (!e.RTCPeerConnection)
        return;
    const r = e.RTCPeerConnection.prototype
        , i = r.addEventListener;
    r.addEventListener = function(o, a) {
        if (o !== t)
            return i.apply(this, arguments);
        const l = c=>{
                const u = n(c);
                u && (a.handleEvent ? a.handleEvent(u) : a(u))
            }
        ;
        return this._eventMap = this._eventMap || {},
        this._eventMap[t] || (this._eventMap[t] = new Map),
            this._eventMap[t].set(a, l),
            i.apply(this, [o, l])
    }
    ;
    const s = r.removeEventListener;
    r.removeEventListener = function(o, a) {
        if (o !== t || !this._eventMap || !this._eventMap[t])
            return s.apply(this, arguments);
        if (!this._eventMap[t].has(a))
            return s.apply(this, arguments);
        const l = this._eventMap[t].get(a);
        return this._eventMap[t].delete(a),
        this._eventMap[t].size === 0 && delete this._eventMap[t],
        Object.keys(this._eventMap).length === 0 && delete this._eventMap,
            s.apply(this, [o, l])
    }
        ,
        Object.defineProperty(r, "on" + t, {
            get() {
                return this["_on" + t]
            },
            set(o) {
                this["_on" + t] && (this.removeEventListener(t, this["_on" + t]),
                    delete this["_on" + t]),
                o && this.addEventListener(t, this["_on" + t] = o)
            },
            enumerable: !0,
            configurable: !0
        })
}
function ZA(e) {
    return typeof e != "boolean" ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (mb = e,
        e ? "adapter.js logging disabled" : "adapter.js logging enabled")
}
function QA(e) {
    return typeof e != "boolean" ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (gb = !e,
    "adapter.js deprecation warnings " + (e ? "disabled" : "enabled"))
}
function vb() {
    if (typeof window == "object") {
        if (mb)
            return;
        typeof console < "u" && typeof console.log == "function" && console.log.apply(console, arguments)
    }
}
function Mf(e, t) {
    gb && console.warn(e + " is deprecated, please use " + t + " instead.")
}
function eI(e) {
    const t = {
        browser: null,
        version: null
    };
    if (typeof e > "u" || !e.navigator || !e.navigator.userAgent)
        return t.browser = "Not a browser.",
            t;
    const {navigator: n} = e;
    if (n.mozGetUserMedia)
        t.browser = "firefox",
            t.version = jo(n.userAgent, /Firefox\/(\d+)\./, 1);
    else if (n.webkitGetUserMedia || e.isSecureContext === !1 && e.webkitRTCPeerConnection)
        t.browser = "chrome",
            t.version = jo(n.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
    else if (e.RTCPeerConnection && n.userAgent.match(/AppleWebKit\/(\d+)\./))
        t.browser = "safari",
            t.version = jo(n.userAgent, /AppleWebKit\/(\d+)\./, 1),
            t.supportsUnifiedPlan = e.RTCRtpTransceiver && "currentDirection"in e.RTCRtpTransceiver.prototype;
    else
        return t.browser = "Not a supported browser.",
            t;
    return t
}
function Fh(e) {
    return Object.prototype.toString.call(e) === "[object Object]"
}
function yb(e) {
    return Fh(e) ? Object.keys(e).reduce(function(t, n) {
        const r = Fh(e[n])
            , i = r ? yb(e[n]) : e[n]
            , s = r && !Object.keys(i).length;
        return i === void 0 || s ? t : Object.assign(t, {
            [n]: i
        })
    }, {}) : e
}
function Jc(e, t, n) {
    !t || n.has(t.id) || (n.set(t.id, t),
        Object.keys(t).forEach(r=>{
                r.endsWith("Id") ? Jc(e, e.get(t[r]), n) : r.endsWith("Ids") && t[r].forEach(i=>{
                        Jc(e, e.get(i), n)
                    }
                )
            }
        ))
}
function jh(e, t, n) {
    const r = n ? "outbound-rtp" : "inbound-rtp"
        , i = new Map;
    if (t === null)
        return i;
    const s = [];
    return e.forEach(o=>{
            o.type === "track" && o.trackIdentifier === t.id && s.push(o)
        }
    ),
        s.forEach(o=>{
                e.forEach(a=>{
                        a.type === r && a.trackId === o.id && Jc(e, a, i)
                    }
                )
            }
        ),
        i
}
const Hh = vb;
function bb(e, t) {
    const n = e && e.navigator;
    if (!n.mediaDevices)
        return;
    const r = function(a) {
        if (typeof a != "object" || a.mandatory || a.optional)
            return a;
        const l = {};
        return Object.keys(a).forEach(c=>{
                if (c === "require" || c === "advanced" || c === "mediaSource")
                    return;
                const u = typeof a[c] == "object" ? a[c] : {
                    ideal: a[c]
                };
                u.exact !== void 0 && typeof u.exact == "number" && (u.min = u.max = u.exact);
                const f = function(d, h) {
                    return d ? d + h.charAt(0).toUpperCase() + h.slice(1) : h === "deviceId" ? "sourceId" : h
                };
                if (u.ideal !== void 0) {
                    l.optional = l.optional || [];
                    let d = {};
                    typeof u.ideal == "number" ? (d[f("min", c)] = u.ideal,
                        l.optional.push(d),
                        d = {},
                        d[f("max", c)] = u.ideal,
                        l.optional.push(d)) : (d[f("", c)] = u.ideal,
                        l.optional.push(d))
                }
                u.exact !== void 0 && typeof u.exact != "number" ? (l.mandatory = l.mandatory || {},
                    l.mandatory[f("", c)] = u.exact) : ["min", "max"].forEach(d=>{
                        u[d] !== void 0 && (l.mandatory = l.mandatory || {},
                            l.mandatory[f(d, c)] = u[d])
                    }
                )
            }
        ),
        a.advanced && (l.optional = (l.optional || []).concat(a.advanced)),
            l
    }
        , i = function(a, l) {
        if (t.version >= 61)
            return l(a);
        if (a = JSON.parse(JSON.stringify(a)),
        a && typeof a.audio == "object") {
            const c = function(u, f, d) {
                f in u && !(d in u) && (u[d] = u[f],
                    delete u[f])
            };
            a = JSON.parse(JSON.stringify(a)),
                c(a.audio, "autoGainControl", "googAutoGainControl"),
                c(a.audio, "noiseSuppression", "googNoiseSuppression"),
                a.audio = r(a.audio)
        }
        if (a && typeof a.video == "object") {
            let c = a.video.facingMode;
            c = c && (typeof c == "object" ? c : {
                ideal: c
            });
            const u = t.version < 66;
            if (c && (c.exact === "user" || c.exact === "environment" || c.ideal === "user" || c.ideal === "environment") && !(n.mediaDevices.getSupportedConstraints && n.mediaDevices.getSupportedConstraints().facingMode && !u)) {
                delete a.video.facingMode;
                let f;
                if (c.exact === "environment" || c.ideal === "environment" ? f = ["back", "rear"] : (c.exact === "user" || c.ideal === "user") && (f = ["front"]),
                    f)
                    return n.mediaDevices.enumerateDevices().then(d=>{
                            d = d.filter(y=>y.kind === "videoinput");
                            let h = d.find(y=>f.some(p=>y.label.toLowerCase().includes(p)));
                            return !h && d.length && f.includes("back") && (h = d[d.length - 1]),
                            h && (a.video.deviceId = c.exact ? {
                                exact: h.deviceId
                            } : {
                                ideal: h.deviceId
                            }),
                                a.video = r(a.video),
                                Hh("chrome: " + JSON.stringify(a)),
                                l(a)
                        }
                    )
            }
            a.video = r(a.video)
        }
        return Hh("chrome: " + JSON.stringify(a)),
            l(a)
    }
        , s = function(a) {
        return t.version >= 64 ? a : {
            name: {
                PermissionDeniedError: "NotAllowedError",
                PermissionDismissedError: "NotAllowedError",
                InvalidStateError: "NotAllowedError",
                DevicesNotFoundError: "NotFoundError",
                ConstraintNotSatisfiedError: "OverconstrainedError",
                TrackStartError: "NotReadableError",
                MediaDeviceFailedDueToShutdown: "NotAllowedError",
                MediaDeviceKillSwitchOn: "NotAllowedError",
                TabCaptureError: "AbortError",
                ScreenCaptureError: "AbortError",
                DeviceCaptureError: "AbortError"
            }[a.name] || a.name,
            message: a.message,
            constraint: a.constraint || a.constraintName,
            toString() {
                return this.name + (this.message && ": ") + this.message
            }
        }
    }
        , o = function(a, l, c) {
        i(a, u=>{
                n.webkitGetUserMedia(u, l, f=>{
                        c && c(s(f))
                    }
                )
            }
        )
    };
    if (n.getUserMedia = o.bind(n),
        n.mediaDevices.getUserMedia) {
        const a = n.mediaDevices.getUserMedia.bind(n.mediaDevices);
        n.mediaDevices.getUserMedia = function(l) {
            return i(l, c=>a(c).then(u=>{
                    if (c.audio && !u.getAudioTracks().length || c.video && !u.getVideoTracks().length)
                        throw u.getTracks().forEach(f=>{
                                f.stop()
                            }
                        ),
                            new DOMException("","NotFoundError");
                    return u
                }
                , u=>Promise.reject(s(u))))
        }
    }
}
function tI(e, t) {
    if (!(e.navigator.mediaDevices && "getDisplayMedia"in e.navigator.mediaDevices) && e.navigator.mediaDevices) {
        if (typeof t != "function") {
            console.error("shimGetDisplayMedia: getSourceId argument is not a function");
            return
        }
        e.navigator.mediaDevices.getDisplayMedia = function(r) {
            return t(r).then(i=>{
                    const s = r.video && r.video.width
                        , o = r.video && r.video.height
                        , a = r.video && r.video.frameRate;
                    return r.video = {
                        mandatory: {
                            chromeMediaSource: "desktop",
                            chromeMediaSourceId: i,
                            maxFrameRate: a || 3
                        }
                    },
                    s && (r.video.mandatory.maxWidth = s),
                    o && (r.video.mandatory.maxHeight = o),
                        e.navigator.mediaDevices.getUserMedia(r)
                }
            )
        }
    }
}
function wb(e) {
    e.MediaStream = e.MediaStream || e.webkitMediaStream
}
function Sb(e) {
    if (typeof e == "object" && e.RTCPeerConnection && !("ontrack"in e.RTCPeerConnection.prototype)) {
        Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", {
            get() {
                return this._ontrack
            },
            set(n) {
                this._ontrack && this.removeEventListener("track", this._ontrack),
                    this.addEventListener("track", this._ontrack = n)
            },
            enumerable: !0,
            configurable: !0
        });
        const t = e.RTCPeerConnection.prototype.setRemoteDescription;
        e.RTCPeerConnection.prototype.setRemoteDescription = function() {
            return this._ontrackpoly || (this._ontrackpoly = r=>{
                r.stream.addEventListener("addtrack", i=>{
                        let s;
                        e.RTCPeerConnection.prototype.getReceivers ? s = this.getReceivers().find(a=>a.track && a.track.id === i.track.id) : s = {
                            track: i.track
                        };
                        const o = new Event("track");
                        o.track = i.track,
                            o.receiver = s,
                            o.transceiver = {
                                receiver: s
                            },
                            o.streams = [r.stream],
                            this.dispatchEvent(o)
                    }
                ),
                    r.stream.getTracks().forEach(i=>{
                            let s;
                            e.RTCPeerConnection.prototype.getReceivers ? s = this.getReceivers().find(a=>a.track && a.track.id === i.id) : s = {
                                track: i
                            };
                            const o = new Event("track");
                            o.track = i,
                                o.receiver = s,
                                o.transceiver = {
                                    receiver: s
                                },
                                o.streams = [r.stream],
                                this.dispatchEvent(o)
                        }
                    )
            }
                ,
                this.addEventListener("addstream", this._ontrackpoly)),
                t.apply(this, arguments)
        }
    } else
        ni(e, "track", t=>(t.transceiver || Object.defineProperty(t, "transceiver", {
            value: {
                receiver: t.receiver
            }
        }),
            t))
}
function _b(e) {
    if (typeof e == "object" && e.RTCPeerConnection && !("getSenders"in e.RTCPeerConnection.prototype) && "createDTMFSender"in e.RTCPeerConnection.prototype) {
        const t = function(i, s) {
            return {
                track: s,
                get dtmf() {
                    return this._dtmf === void 0 && (s.kind === "audio" ? this._dtmf = i.createDTMFSender(s) : this._dtmf = null),
                        this._dtmf
                },
                _pc: i
            }
        };
        if (!e.RTCPeerConnection.prototype.getSenders) {
            e.RTCPeerConnection.prototype.getSenders = function() {
                return this._senders = this._senders || [],
                    this._senders.slice()
            }
            ;
            const i = e.RTCPeerConnection.prototype.addTrack;
            e.RTCPeerConnection.prototype.addTrack = function(a, l) {
                let c = i.apply(this, arguments);
                return c || (c = t(this, a),
                    this._senders.push(c)),
                    c
            }
            ;
            const s = e.RTCPeerConnection.prototype.removeTrack;
            e.RTCPeerConnection.prototype.removeTrack = function(a) {
                s.apply(this, arguments);
                const l = this._senders.indexOf(a);
                l !== -1 && this._senders.splice(l, 1)
            }
        }
        const n = e.RTCPeerConnection.prototype.addStream;
        e.RTCPeerConnection.prototype.addStream = function(s) {
            this._senders = this._senders || [],
                n.apply(this, [s]),
                s.getTracks().forEach(o=>{
                        this._senders.push(t(this, o))
                    }
                )
        }
        ;
        const r = e.RTCPeerConnection.prototype.removeStream;
        e.RTCPeerConnection.prototype.removeStream = function(s) {
            this._senders = this._senders || [],
                r.apply(this, [s]),
                s.getTracks().forEach(o=>{
                        const a = this._senders.find(l=>l.track === o);
                        a && this._senders.splice(this._senders.indexOf(a), 1)
                    }
                )
        }
    } else if (typeof e == "object" && e.RTCPeerConnection && "getSenders"in e.RTCPeerConnection.prototype && "createDTMFSender"in e.RTCPeerConnection.prototype && e.RTCRtpSender && !("dtmf"in e.RTCRtpSender.prototype)) {
        const t = e.RTCPeerConnection.prototype.getSenders;
        e.RTCPeerConnection.prototype.getSenders = function() {
            const r = t.apply(this, []);
            return r.forEach(i=>i._pc = this),
                r
        }
            ,
            Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", {
                get() {
                    return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null),
                        this._dtmf
                }
            })
    }
}
function Eb(e) {
    if (!e.RTCPeerConnection)
        return;
    const t = e.RTCPeerConnection.prototype.getStats;
    e.RTCPeerConnection.prototype.getStats = function() {
        const [r,i,s] = arguments;
        if (arguments.length > 0 && typeof r == "function")
            return t.apply(this, arguments);
        if (t.length === 0 && (arguments.length === 0 || typeof r != "function"))
            return t.apply(this, []);
        const o = function(l) {
            const c = {};
            return l.result().forEach(f=>{
                    const d = {
                        id: f.id,
                        timestamp: f.timestamp,
                        type: {
                            localcandidate: "local-candidate",
                            remotecandidate: "remote-candidate"
                        }[f.type] || f.type
                    };
                    f.names().forEach(h=>{
                            d[h] = f.stat(h)
                        }
                    ),
                        c[d.id] = d
                }
            ),
                c
        }
            , a = function(l) {
            return new Map(Object.keys(l).map(c=>[c, l[c]]))
        };
        if (arguments.length >= 2) {
            const l = function(c) {
                i(a(o(c)))
            };
            return t.apply(this, [l, r])
        }
        return new Promise((l,c)=>{
                t.apply(this, [function(u) {
                    l(a(o(u)))
                }
                    , c])
            }
        ).then(i, s)
    }
}
function Cb(e) {
    if (!(typeof e == "object" && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver))
        return;
    if (!("getStats"in e.RTCRtpSender.prototype)) {
        const n = e.RTCPeerConnection.prototype.getSenders;
        n && (e.RTCPeerConnection.prototype.getSenders = function() {
                const s = n.apply(this, []);
                return s.forEach(o=>o._pc = this),
                    s
            }
        );
        const r = e.RTCPeerConnection.prototype.addTrack;
        r && (e.RTCPeerConnection.prototype.addTrack = function() {
                const s = r.apply(this, arguments);
                return s._pc = this,
                    s
            }
        ),
            e.RTCRtpSender.prototype.getStats = function() {
                const s = this;
                return this._pc.getStats().then(o=>jh(o, s.track, !0))
            }
    }
    if (!("getStats"in e.RTCRtpReceiver.prototype)) {
        const n = e.RTCPeerConnection.prototype.getReceivers;
        n && (e.RTCPeerConnection.prototype.getReceivers = function() {
                const i = n.apply(this, []);
                return i.forEach(s=>s._pc = this),
                    i
            }
        ),
            ni(e, "track", r=>(r.receiver._pc = r.srcElement,
                r)),
            e.RTCRtpReceiver.prototype.getStats = function() {
                const i = this;
                return this._pc.getStats().then(s=>jh(s, i.track, !1))
            }
    }
    if (!("getStats"in e.RTCRtpSender.prototype && "getStats"in e.RTCRtpReceiver.prototype))
        return;
    const t = e.RTCPeerConnection.prototype.getStats;
    e.RTCPeerConnection.prototype.getStats = function() {
        if (arguments.length > 0 && arguments[0]instanceof e.MediaStreamTrack) {
            const r = arguments[0];
            let i, s, o;
            return this.getSenders().forEach(a=>{
                    a.track === r && (i ? o = !0 : i = a)
                }
            ),
                this.getReceivers().forEach(a=>(a.track === r && (s ? o = !0 : s = a),
                a.track === r)),
                o || i && s ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.","InvalidAccessError")) : i ? i.getStats() : s ? s.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.","InvalidAccessError"))
        }
        return t.apply(this, arguments)
    }
}
function Tb(e) {
    e.RTCPeerConnection.prototype.getLocalStreams = function() {
        return this._shimmedLocalStreams = this._shimmedLocalStreams || {},
            Object.keys(this._shimmedLocalStreams).map(o=>this._shimmedLocalStreams[o][0])
    }
    ;
    const t = e.RTCPeerConnection.prototype.addTrack;
    e.RTCPeerConnection.prototype.addTrack = function(o, a) {
        if (!a)
            return t.apply(this, arguments);
        this._shimmedLocalStreams = this._shimmedLocalStreams || {};
        const l = t.apply(this, arguments);
        return this._shimmedLocalStreams[a.id] ? this._shimmedLocalStreams[a.id].indexOf(l) === -1 && this._shimmedLocalStreams[a.id].push(l) : this._shimmedLocalStreams[a.id] = [a, l],
            l
    }
    ;
    const n = e.RTCPeerConnection.prototype.addStream;
    e.RTCPeerConnection.prototype.addStream = function(o) {
        this._shimmedLocalStreams = this._shimmedLocalStreams || {},
            o.getTracks().forEach(c=>{
                    if (this.getSenders().find(f=>f.track === c))
                        throw new DOMException("Track already exists.","InvalidAccessError")
                }
            );
        const a = this.getSenders();
        n.apply(this, arguments);
        const l = this.getSenders().filter(c=>a.indexOf(c) === -1);
        this._shimmedLocalStreams[o.id] = [o].concat(l)
    }
    ;
    const r = e.RTCPeerConnection.prototype.removeStream;
    e.RTCPeerConnection.prototype.removeStream = function(o) {
        return this._shimmedLocalStreams = this._shimmedLocalStreams || {},
            delete this._shimmedLocalStreams[o.id],
            r.apply(this, arguments)
    }
    ;
    const i = e.RTCPeerConnection.prototype.removeTrack;
    e.RTCPeerConnection.prototype.removeTrack = function(o) {
        return this._shimmedLocalStreams = this._shimmedLocalStreams || {},
        o && Object.keys(this._shimmedLocalStreams).forEach(a=>{
                const l = this._shimmedLocalStreams[a].indexOf(o);
                l !== -1 && this._shimmedLocalStreams[a].splice(l, 1),
                this._shimmedLocalStreams[a].length === 1 && delete this._shimmedLocalStreams[a]
            }
        ),
            i.apply(this, arguments)
    }
}
function xb(e, t) {
    if (!e.RTCPeerConnection)
        return;
    if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65)
        return Tb(e);
    const n = e.RTCPeerConnection.prototype.getLocalStreams;
    e.RTCPeerConnection.prototype.getLocalStreams = function() {
        const u = n.apply(this);
        return this._reverseStreams = this._reverseStreams || {},
            u.map(f=>this._reverseStreams[f.id])
    }
    ;
    const r = e.RTCPeerConnection.prototype.addStream;
    e.RTCPeerConnection.prototype.addStream = function(u) {
        if (this._streams = this._streams || {},
            this._reverseStreams = this._reverseStreams || {},
            u.getTracks().forEach(f=>{
                    if (this.getSenders().find(h=>h.track === f))
                        throw new DOMException("Track already exists.","InvalidAccessError")
                }
            ),
            !this._reverseStreams[u.id]) {
            const f = new e.MediaStream(u.getTracks());
            this._streams[u.id] = f,
                this._reverseStreams[f.id] = u,
                u = f
        }
        r.apply(this, [u])
    }
    ;
    const i = e.RTCPeerConnection.prototype.removeStream;
    e.RTCPeerConnection.prototype.removeStream = function(u) {
        this._streams = this._streams || {},
            this._reverseStreams = this._reverseStreams || {},
            i.apply(this, [this._streams[u.id] || u]),
            delete this._reverseStreams[this._streams[u.id] ? this._streams[u.id].id : u.id],
            delete this._streams[u.id]
    }
        ,
        e.RTCPeerConnection.prototype.addTrack = function(u, f) {
            if (this.signalingState === "closed")
                throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.","InvalidStateError");
            const d = [].slice.call(arguments, 1);
            if (d.length !== 1 || !d[0].getTracks().find(p=>p === u))
                throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.","NotSupportedError");
            if (this.getSenders().find(p=>p.track === u))
                throw new DOMException("Track already exists.","InvalidAccessError");
            this._streams = this._streams || {},
                this._reverseStreams = this._reverseStreams || {};
            const y = this._streams[f.id];
            if (y)
                y.addTrack(u),
                    Promise.resolve().then(()=>{
                            this.dispatchEvent(new Event("negotiationneeded"))
                        }
                    );
            else {
                const p = new e.MediaStream([u]);
                this._streams[f.id] = p,
                    this._reverseStreams[p.id] = f,
                    this.addStream(p)
            }
            return this.getSenders().find(p=>p.track === u)
        }
    ;
    function s(c, u) {
        let f = u.sdp;
        return Object.keys(c._reverseStreams || []).forEach(d=>{
                const h = c._reverseStreams[d]
                    , y = c._streams[h.id];
                f = f.replace(new RegExp(y.id,"g"), h.id)
            }
        ),
            new RTCSessionDescription({
                type: u.type,
                sdp: f
            })
    }
    function o(c, u) {
        let f = u.sdp;
        return Object.keys(c._reverseStreams || []).forEach(d=>{
                const h = c._reverseStreams[d]
                    , y = c._streams[h.id];
                f = f.replace(new RegExp(h.id,"g"), y.id)
            }
        ),
            new RTCSessionDescription({
                type: u.type,
                sdp: f
            })
    }
    ["createOffer", "createAnswer"].forEach(function(c) {
        const u = e.RTCPeerConnection.prototype[c]
            , f = {
            [c]() {
                const d = arguments;
                return arguments.length && typeof arguments[0] == "function" ? u.apply(this, [y=>{
                    const p = s(this, y);
                    d[0].apply(null, [p])
                }
                    , y=>{
                        d[1] && d[1].apply(null, y)
                    }
                    , arguments[2]]) : u.apply(this, arguments).then(y=>s(this, y))
            }
        };
        e.RTCPeerConnection.prototype[c] = f[c]
    });
    const a = e.RTCPeerConnection.prototype.setLocalDescription;
    e.RTCPeerConnection.prototype.setLocalDescription = function() {
        return !arguments.length || !arguments[0].type ? a.apply(this, arguments) : (arguments[0] = o(this, arguments[0]),
            a.apply(this, arguments))
    }
    ;
    const l = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, "localDescription");
    Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", {
        get() {
            const c = l.get.apply(this);
            return c.type === "" ? c : s(this, c)
        }
    }),
        e.RTCPeerConnection.prototype.removeTrack = function(u) {
            if (this.signalingState === "closed")
                throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.","InvalidStateError");
            if (!u._pc)
                throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.","TypeError");
            if (!(u._pc === this))
                throw new DOMException("Sender was not created by this connection.","InvalidAccessError");
            this._streams = this._streams || {};
            let d;
            Object.keys(this._streams).forEach(h=>{
                    this._streams[h].getTracks().find(p=>u.track === p) && (d = this._streams[h])
                }
            ),
            d && (d.getTracks().length === 1 ? this.removeStream(this._reverseStreams[d.id]) : d.removeTrack(u.track),
                this.dispatchEvent(new Event("negotiationneeded")))
        }
}
function Zc(e, t) {
    !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection),
    e.RTCPeerConnection && t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(n) {
        const r = e.RTCPeerConnection.prototype[n]
            , i = {
            [n]() {
                return arguments[0] = new (n === "addIceCandidate" ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]),
                    r.apply(this, arguments)
            }
        };
        e.RTCPeerConnection.prototype[n] = i[n]
    })
}
function Pb(e, t) {
    ni(e, "negotiationneeded", n=>{
            const r = n.target;
            if (!((t.version < 72 || r.getConfiguration && r.getConfiguration().sdpSemantics === "plan-b") && r.signalingState !== "stable"))
                return n
        }
    )
}
const Bh = Object.freeze(Object.defineProperty({
    __proto__: null,
    fixNegotiationNeeded: Pb,
    shimAddTrackRemoveTrack: xb,
    shimAddTrackRemoveTrackWithNative: Tb,
    shimGetDisplayMedia: tI,
    shimGetSendersWithDtmf: _b,
    shimGetStats: Eb,
    shimGetUserMedia: bb,
    shimMediaStream: wb,
    shimOnTrack: Sb,
    shimPeerConnection: Zc,
    shimSenderReceiverGetStats: Cb
}, Symbol.toStringTag, {
    value: "Module"
}));
function kb(e, t) {
    const n = e && e.navigator
        , r = e && e.MediaStreamTrack;
    if (n.getUserMedia = function(i, s, o) {
        Mf("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"),
            n.mediaDevices.getUserMedia(i).then(s, o)
    }
        ,
        !(t.version > 55 && "autoGainControl"in n.mediaDevices.getSupportedConstraints())) {
        const i = function(o, a, l) {
            a in o && !(l in o) && (o[l] = o[a],
                delete o[a])
        }
            , s = n.mediaDevices.getUserMedia.bind(n.mediaDevices);
        if (n.mediaDevices.getUserMedia = function(o) {
            return typeof o == "object" && typeof o.audio == "object" && (o = JSON.parse(JSON.stringify(o)),
                i(o.audio, "autoGainControl", "mozAutoGainControl"),
                i(o.audio, "noiseSuppression", "mozNoiseSuppression")),
                s(o)
        }
            ,
        r && r.prototype.getSettings) {
            const o = r.prototype.getSettings;
            r.prototype.getSettings = function() {
                const a = o.apply(this, arguments);
                return i(a, "mozAutoGainControl", "autoGainControl"),
                    i(a, "mozNoiseSuppression", "noiseSuppression"),
                    a
            }
        }
        if (r && r.prototype.applyConstraints) {
            const o = r.prototype.applyConstraints;
            r.prototype.applyConstraints = function(a) {
                return this.kind === "audio" && typeof a == "object" && (a = JSON.parse(JSON.stringify(a)),
                    i(a, "autoGainControl", "mozAutoGainControl"),
                    i(a, "noiseSuppression", "mozNoiseSuppression")),
                    o.apply(this, [a])
            }
        }
    }
}
function nI(e, t) {
    e.navigator.mediaDevices && "getDisplayMedia"in e.navigator.mediaDevices || e.navigator.mediaDevices && (e.navigator.mediaDevices.getDisplayMedia = function(r) {
            if (!(r && r.video)) {
                const i = new DOMException("getDisplayMedia without video constraints is undefined");
                return i.name = "NotFoundError",
                    i.code = 8,
                    Promise.reject(i)
            }
            return r.video === !0 ? r.video = {
                mediaSource: t
            } : r.video.mediaSource = t,
                e.navigator.mediaDevices.getUserMedia(r)
        }
    )
}
function Rb(e) {
    typeof e == "object" && e.RTCTrackEvent && "receiver"in e.RTCTrackEvent.prototype && !("transceiver"in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", {
        get() {
            return {
                receiver: this.receiver
            }
        }
    })
}
function Qc(e, t) {
    if (typeof e != "object" || !(e.RTCPeerConnection || e.mozRTCPeerConnection))
        return;
    !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection),
    t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(i) {
        const s = e.RTCPeerConnection.prototype[i]
            , o = {
            [i]() {
                return arguments[0] = new (i === "addIceCandidate" ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]),
                    s.apply(this, arguments)
            }
        };
        e.RTCPeerConnection.prototype[i] = o[i]
    });
    const n = {
        inboundrtp: "inbound-rtp",
        outboundrtp: "outbound-rtp",
        candidatepair: "candidate-pair",
        localcandidate: "local-candidate",
        remotecandidate: "remote-candidate"
    }
        , r = e.RTCPeerConnection.prototype.getStats;
    e.RTCPeerConnection.prototype.getStats = function() {
        const [s,o,a] = arguments;
        return r.apply(this, [s || null]).then(l=>{
                if (t.version < 53 && !o)
                    try {
                        l.forEach(c=>{
                                c.type = n[c.type] || c.type
                            }
                        )
                    } catch (c) {
                        if (c.name !== "TypeError")
                            throw c;
                        l.forEach((u,f)=>{
                                l.set(f, Object.assign({}, u, {
                                    type: n[u.type] || u.type
                                }))
                            }
                        )
                    }
                return l
            }
        ).then(o, a)
    }
}
function Lb(e) {
    if (!(typeof e == "object" && e.RTCPeerConnection && e.RTCRtpSender) || e.RTCRtpSender && "getStats"in e.RTCRtpSender.prototype)
        return;
    const t = e.RTCPeerConnection.prototype.getSenders;
    t && (e.RTCPeerConnection.prototype.getSenders = function() {
            const i = t.apply(this, []);
            return i.forEach(s=>s._pc = this),
                i
        }
    );
    const n = e.RTCPeerConnection.prototype.addTrack;
    n && (e.RTCPeerConnection.prototype.addTrack = function() {
            const i = n.apply(this, arguments);
            return i._pc = this,
                i
        }
    ),
        e.RTCRtpSender.prototype.getStats = function() {
            return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map)
        }
}
function Ob(e) {
    if (!(typeof e == "object" && e.RTCPeerConnection && e.RTCRtpSender) || e.RTCRtpSender && "getStats"in e.RTCRtpReceiver.prototype)
        return;
    const t = e.RTCPeerConnection.prototype.getReceivers;
    t && (e.RTCPeerConnection.prototype.getReceivers = function() {
            const r = t.apply(this, []);
            return r.forEach(i=>i._pc = this),
                r
        }
    ),
        ni(e, "track", n=>(n.receiver._pc = n.srcElement,
            n)),
        e.RTCRtpReceiver.prototype.getStats = function() {
            return this._pc.getStats(this.track)
        }
}
function Ab(e) {
    !e.RTCPeerConnection || "removeStream"in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function(n) {
            Mf("removeStream", "removeTrack"),
                this.getSenders().forEach(r=>{
                        r.track && n.getTracks().includes(r.track) && this.removeTrack(r)
                    }
                )
        }
    )
}
function Ib(e) {
    e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel)
}
function Mb(e) {
    if (!(typeof e == "object" && e.RTCPeerConnection))
        return;
    const t = e.RTCPeerConnection.prototype.addTransceiver;
    t && (e.RTCPeerConnection.prototype.addTransceiver = function() {
            this.setParametersPromises = [];
            let r = arguments[1] && arguments[1].sendEncodings;
            r === void 0 && (r = []),
                r = [...r];
            const i = r.length > 0;
            i && r.forEach(o=>{
                    if ("rid"in o && !/^[a-z0-9]{0,16}$/i.test(o.rid))
                        throw new TypeError("Invalid RID value provided.");
                    if ("scaleResolutionDownBy"in o && !(parseFloat(o.scaleResolutionDownBy) >= 1))
                        throw new RangeError("scale_resolution_down_by must be >= 1.0");
                    if ("maxFramerate"in o && !(parseFloat(o.maxFramerate) >= 0))
                        throw new RangeError("max_framerate must be >= 0.0")
                }
            );
            const s = t.apply(this, arguments);
            if (i) {
                const {sender: o} = s
                    , a = o.getParameters();
                (!("encodings"in a) || a.encodings.length === 1 && Object.keys(a.encodings[0]).length === 0) && (a.encodings = r,
                    o.sendEncodings = r,
                    this.setParametersPromises.push(o.setParameters(a).then(()=>{
                            delete o.sendEncodings
                        }
                    ).catch(()=>{
                            delete o.sendEncodings
                        }
                    )))
            }
            return s
        }
    )
}
function Db(e) {
    if (!(typeof e == "object" && e.RTCRtpSender))
        return;
    const t = e.RTCRtpSender.prototype.getParameters;
    t && (e.RTCRtpSender.prototype.getParameters = function() {
            const r = t.apply(this, arguments);
            return "encodings"in r || (r.encodings = [].concat(this.sendEncodings || [{}])),
                r
        }
    )
}
function Nb(e) {
    if (!(typeof e == "object" && e.RTCPeerConnection))
        return;
    const t = e.RTCPeerConnection.prototype.createOffer;
    e.RTCPeerConnection.prototype.createOffer = function() {
        return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(()=>t.apply(this, arguments)).finally(()=>{
                this.setParametersPromises = []
            }
        ) : t.apply(this, arguments)
    }
}
function $b(e) {
    if (!(typeof e == "object" && e.RTCPeerConnection))
        return;
    const t = e.RTCPeerConnection.prototype.createAnswer;
    e.RTCPeerConnection.prototype.createAnswer = function() {
        return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(()=>t.apply(this, arguments)).finally(()=>{
                this.setParametersPromises = []
            }
        ) : t.apply(this, arguments)
    }
}
const Vh = Object.freeze(Object.defineProperty({
    __proto__: null,
    shimAddTransceiver: Mb,
    shimCreateAnswer: $b,
    shimCreateOffer: Nb,
    shimGetDisplayMedia: nI,
    shimGetParameters: Db,
    shimGetUserMedia: kb,
    shimOnTrack: Rb,
    shimPeerConnection: Qc,
    shimRTCDataChannel: Ib,
    shimReceiverGetStats: Ob,
    shimRemoveStream: Ab,
    shimSenderGetStats: Lb
}, Symbol.toStringTag, {
    value: "Module"
}));
function Fb(e) {
    if (!(typeof e != "object" || !e.RTCPeerConnection)) {
        if ("getLocalStreams"in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function() {
                return this._localStreams || (this._localStreams = []),
                    this._localStreams
            }
        ),
            !("addStream"in e.RTCPeerConnection.prototype)) {
            const t = e.RTCPeerConnection.prototype.addTrack;
            e.RTCPeerConnection.prototype.addStream = function(r) {
                this._localStreams || (this._localStreams = []),
                this._localStreams.includes(r) || this._localStreams.push(r),
                    r.getAudioTracks().forEach(i=>t.call(this, i, r)),
                    r.getVideoTracks().forEach(i=>t.call(this, i, r))
            }
                ,
                e.RTCPeerConnection.prototype.addTrack = function(r, ...i) {
                    return i && i.forEach(s=>{
                            this._localStreams ? this._localStreams.includes(s) || this._localStreams.push(s) : this._localStreams = [s]
                        }
                    ),
                        t.apply(this, arguments)
                }
        }
        "removeStream"in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function(n) {
                this._localStreams || (this._localStreams = []);
                const r = this._localStreams.indexOf(n);
                if (r === -1)
                    return;
                this._localStreams.splice(r, 1);
                const i = n.getTracks();
                this.getSenders().forEach(s=>{
                        i.includes(s.track) && this.removeTrack(s)
                    }
                )
            }
        )
    }
}
function jb(e) {
    if (!(typeof e != "object" || !e.RTCPeerConnection) && ("getRemoteStreams"in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function() {
            return this._remoteStreams ? this._remoteStreams : []
        }
    ),
        !("onaddstream"in e.RTCPeerConnection.prototype))) {
        Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", {
            get() {
                return this._onaddstream
            },
            set(n) {
                this._onaddstream && (this.removeEventListener("addstream", this._onaddstream),
                    this.removeEventListener("track", this._onaddstreampoly)),
                    this.addEventListener("addstream", this._onaddstream = n),
                    this.addEventListener("track", this._onaddstreampoly = r=>{
                            r.streams.forEach(i=>{
                                    if (this._remoteStreams || (this._remoteStreams = []),
                                        this._remoteStreams.includes(i))
                                        return;
                                    this._remoteStreams.push(i);
                                    const s = new Event("addstream");
                                    s.stream = i,
                                        this.dispatchEvent(s)
                                }
                            )
                        }
                    )
            }
        });
        const t = e.RTCPeerConnection.prototype.setRemoteDescription;
        e.RTCPeerConnection.prototype.setRemoteDescription = function() {
            const r = this;
            return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(i) {
                    i.streams.forEach(s=>{
                            if (r._remoteStreams || (r._remoteStreams = []),
                            r._remoteStreams.indexOf(s) >= 0)
                                return;
                            r._remoteStreams.push(s);
                            const o = new Event("addstream");
                            o.stream = s,
                                r.dispatchEvent(o)
                        }
                    )
                }
            ),
                t.apply(r, arguments)
        }
    }
}
function Hb(e) {
    if (typeof e != "object" || !e.RTCPeerConnection)
        return;
    const t = e.RTCPeerConnection.prototype
        , n = t.createOffer
        , r = t.createAnswer
        , i = t.setLocalDescription
        , s = t.setRemoteDescription
        , o = t.addIceCandidate;
    t.createOffer = function(c, u) {
        const f = arguments.length >= 2 ? arguments[2] : arguments[0]
            , d = n.apply(this, [f]);
        return u ? (d.then(c, u),
            Promise.resolve()) : d
    }
        ,
        t.createAnswer = function(c, u) {
            const f = arguments.length >= 2 ? arguments[2] : arguments[0]
                , d = r.apply(this, [f]);
            return u ? (d.then(c, u),
                Promise.resolve()) : d
        }
    ;
    let a = function(l, c, u) {
        const f = i.apply(this, [l]);
        return u ? (f.then(c, u),
            Promise.resolve()) : f
    };
    t.setLocalDescription = a,
        a = function(l, c, u) {
            const f = s.apply(this, [l]);
            return u ? (f.then(c, u),
                Promise.resolve()) : f
        }
        ,
        t.setRemoteDescription = a,
        a = function(l, c, u) {
            const f = o.apply(this, [l]);
            return u ? (f.then(c, u),
                Promise.resolve()) : f
        }
        ,
        t.addIceCandidate = a
}
function Bb(e) {
    const t = e && e.navigator;
    if (t.mediaDevices && t.mediaDevices.getUserMedia) {
        const n = t.mediaDevices
            , r = n.getUserMedia.bind(n);
        t.mediaDevices.getUserMedia = i=>r(Vb(i))
    }
    !t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function(r, i, s) {
        t.mediaDevices.getUserMedia(r).then(i, s)
    }
        .bind(t))
}
function Vb(e) {
    return e && e.video !== void 0 ? Object.assign({}, e, {
        video: yb(e.video)
    }) : e
}
function zb(e) {
    if (!e.RTCPeerConnection)
        return;
    const t = e.RTCPeerConnection;
    e.RTCPeerConnection = function(r, i) {
        if (r && r.iceServers) {
            const s = [];
            for (let o = 0; o < r.iceServers.length; o++) {
                let a = r.iceServers[o];
                a.urls === void 0 && a.url ? (Mf("RTCIceServer.url", "RTCIceServer.urls"),
                    a = JSON.parse(JSON.stringify(a)),
                    a.urls = a.url,
                    delete a.url,
                    s.push(a)) : s.push(r.iceServers[o])
            }
            r.iceServers = s
        }
        return new t(r,i)
    }
        ,
        e.RTCPeerConnection.prototype = t.prototype,
    "generateCertificate"in t && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", {
        get() {
            return t.generateCertificate
        }
    })
}
function Ub(e) {
    typeof e == "object" && e.RTCTrackEvent && "receiver"in e.RTCTrackEvent.prototype && !("transceiver"in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", {
        get() {
            return {
                receiver: this.receiver
            }
        }
    })
}
function Wb(e) {
    const t = e.RTCPeerConnection.prototype.createOffer;
    e.RTCPeerConnection.prototype.createOffer = function(r) {
        if (r) {
            typeof r.offerToReceiveAudio < "u" && (r.offerToReceiveAudio = !!r.offerToReceiveAudio);
            const i = this.getTransceivers().find(o=>o.receiver.track.kind === "audio");
            r.offerToReceiveAudio === !1 && i ? i.direction === "sendrecv" ? i.setDirection ? i.setDirection("sendonly") : i.direction = "sendonly" : i.direction === "recvonly" && (i.setDirection ? i.setDirection("inactive") : i.direction = "inactive") : r.offerToReceiveAudio === !0 && !i && this.addTransceiver("audio", {
                direction: "recvonly"
            }),
            typeof r.offerToReceiveVideo < "u" && (r.offerToReceiveVideo = !!r.offerToReceiveVideo);
            const s = this.getTransceivers().find(o=>o.receiver.track.kind === "video");
            r.offerToReceiveVideo === !1 && s ? s.direction === "sendrecv" ? s.setDirection ? s.setDirection("sendonly") : s.direction = "sendonly" : s.direction === "recvonly" && (s.setDirection ? s.setDirection("inactive") : s.direction = "inactive") : r.offerToReceiveVideo === !0 && !s && this.addTransceiver("video", {
                direction: "recvonly"
            })
        }
        return t.apply(this, arguments)
    }
}
function Gb(e) {
    typeof e != "object" || e.AudioContext || (e.AudioContext = e.webkitAudioContext)
}
const zh = Object.freeze(Object.defineProperty({
    __proto__: null,
    shimAudioContext: Gb,
    shimCallbacksAPI: Hb,
    shimConstraints: Vb,
    shimCreateOfferLegacy: Wb,
    shimGetUserMedia: Bb,
    shimLocalStreamsAPI: Fb,
    shimRTCIceServerUrls: zb,
    shimRemoteStreamsAPI: jb,
    shimTrackEventTransceiver: Ub
}, Symbol.toStringTag, {
    value: "Module"
}));
var Xb = {
    exports: {}
};
(function(e) {
        const t = {};
        t.generateIdentifier = function() {
            return Math.random().toString(36).substring(2, 12)
        }
            ,
            t.localCName = t.generateIdentifier(),
            t.splitLines = function(n) {
                return n.trim().split(`
`).map(r=>r.trim())
            }
            ,
            t.splitSections = function(n) {
                return n.split(`
m=`).map((i,s)=>(s > 0 ? "m=" + i : i).trim() + `\r
`)
            }
            ,
            t.getDescription = function(n) {
                const r = t.splitSections(n);
                return r && r[0]
            }
            ,
            t.getMediaSections = function(n) {
                const r = t.splitSections(n);
                return r.shift(),
                    r
            }
            ,
            t.matchPrefix = function(n, r) {
                return t.splitLines(n).filter(i=>i.indexOf(r) === 0)
            }
            ,
            t.parseCandidate = function(n) {
                let r;
                n.indexOf("a=candidate:") === 0 ? r = n.substring(12).split(" ") : r = n.substring(10).split(" ");
                const i = {
                    foundation: r[0],
                    component: {
                        1: "rtp",
                        2: "rtcp"
                    }[r[1]] || r[1],
                    protocol: r[2].toLowerCase(),
                    priority: parseInt(r[3], 10),
                    ip: r[4],
                    address: r[4],
                    port: parseInt(r[5], 10),
                    type: r[7]
                };
                for (let s = 8; s < r.length; s += 2)
                    switch (r[s]) {
                        case "raddr":
                            i.relatedAddress = r[s + 1];
                            break;
                        case "rport":
                            i.relatedPort = parseInt(r[s + 1], 10);
                            break;
                        case "tcptype":
                            i.tcpType = r[s + 1];
                            break;
                        case "ufrag":
                            i.ufrag = r[s + 1],
                                i.usernameFragment = r[s + 1];
                            break;
                        default:
                            i[r[s]] === void 0 && (i[r[s]] = r[s + 1]);
                            break
                    }
                return i
            }
            ,
            t.writeCandidate = function(n) {
                const r = [];
                r.push(n.foundation);
                const i = n.component;
                i === "rtp" ? r.push(1) : i === "rtcp" ? r.push(2) : r.push(i),
                    r.push(n.protocol.toUpperCase()),
                    r.push(n.priority),
                    r.push(n.address || n.ip),
                    r.push(n.port);
                const s = n.type;
                return r.push("typ"),
                    r.push(s),
                s !== "host" && n.relatedAddress && n.relatedPort && (r.push("raddr"),
                    r.push(n.relatedAddress),
                    r.push("rport"),
                    r.push(n.relatedPort)),
                n.tcpType && n.protocol.toLowerCase() === "tcp" && (r.push("tcptype"),
                    r.push(n.tcpType)),
                (n.usernameFragment || n.ufrag) && (r.push("ufrag"),
                    r.push(n.usernameFragment || n.ufrag)),
                "candidate:" + r.join(" ")
            }
            ,
            t.parseIceOptions = function(n) {
                return n.substring(14).split(" ")
            }
            ,
            t.parseRtpMap = function(n) {
                let r = n.substring(9).split(" ");
                const i = {
                    payloadType: parseInt(r.shift(), 10)
                };
                return r = r[0].split("/"),
                    i.name = r[0],
                    i.clockRate = parseInt(r[1], 10),
                    i.channels = r.length === 3 ? parseInt(r[2], 10) : 1,
                    i.numChannels = i.channels,
                    i
            }
            ,
            t.writeRtpMap = function(n) {
                let r = n.payloadType;
                n.preferredPayloadType !== void 0 && (r = n.preferredPayloadType);
                const i = n.channels || n.numChannels || 1;
                return "a=rtpmap:" + r + " " + n.name + "/" + n.clockRate + (i !== 1 ? "/" + i : "") + `\r
`
            }
            ,
            t.parseExtmap = function(n) {
                const r = n.substring(9).split(" ");
                return {
                    id: parseInt(r[0], 10),
                    direction: r[0].indexOf("/") > 0 ? r[0].split("/")[1] : "sendrecv",
                    uri: r[1],
                    attributes: r.slice(2).join(" ")
                }
            }
            ,
            t.writeExtmap = function(n) {
                return "a=extmap:" + (n.id || n.preferredId) + (n.direction && n.direction !== "sendrecv" ? "/" + n.direction : "") + " " + n.uri + (n.attributes ? " " + n.attributes : "") + `\r
`
            }
            ,
            t.parseFmtp = function(n) {
                const r = {};
                let i;
                const s = n.substring(n.indexOf(" ") + 1).split(";");
                for (let o = 0; o < s.length; o++)
                    i = s[o].trim().split("="),
                        r[i[0].trim()] = i[1];
                return r
            }
            ,
            t.writeFmtp = function(n) {
                let r = ""
                    , i = n.payloadType;
                if (n.preferredPayloadType !== void 0 && (i = n.preferredPayloadType),
                n.parameters && Object.keys(n.parameters).length) {
                    const s = [];
                    Object.keys(n.parameters).forEach(o=>{
                            n.parameters[o] !== void 0 ? s.push(o + "=" + n.parameters[o]) : s.push(o)
                        }
                    ),
                        r += "a=fmtp:" + i + " " + s.join(";") + `\r
`
                }
                return r
            }
            ,
            t.parseRtcpFb = function(n) {
                const r = n.substring(n.indexOf(" ") + 1).split(" ");
                return {
                    type: r.shift(),
                    parameter: r.join(" ")
                }
            }
            ,
            t.writeRtcpFb = function(n) {
                let r = ""
                    , i = n.payloadType;
                return n.preferredPayloadType !== void 0 && (i = n.preferredPayloadType),
                n.rtcpFeedback && n.rtcpFeedback.length && n.rtcpFeedback.forEach(s=>{
                        r += "a=rtcp-fb:" + i + " " + s.type + (s.parameter && s.parameter.length ? " " + s.parameter : "") + `\r
`
                    }
                ),
                    r
            }
            ,
            t.parseSsrcMedia = function(n) {
                const r = n.indexOf(" ")
                    , i = {
                    ssrc: parseInt(n.substring(7, r), 10)
                }
                    , s = n.indexOf(":", r);
                return s > -1 ? (i.attribute = n.substring(r + 1, s),
                    i.value = n.substring(s + 1)) : i.attribute = n.substring(r + 1),
                    i
            }
            ,
            t.parseSsrcGroup = function(n) {
                const r = n.substring(13).split(" ");
                return {
                    semantics: r.shift(),
                    ssrcs: r.map(i=>parseInt(i, 10))
                }
            }
            ,
            t.getMid = function(n) {
                const r = t.matchPrefix(n, "a=mid:")[0];
                if (r)
                    return r.substring(6)
            }
            ,
            t.parseFingerprint = function(n) {
                const r = n.substring(14).split(" ");
                return {
                    algorithm: r[0].toLowerCase(),
                    value: r[1].toUpperCase()
                }
            }
            ,
            t.getDtlsParameters = function(n, r) {
                return {
                    role: "auto",
                    fingerprints: t.matchPrefix(n + r, "a=fingerprint:").map(t.parseFingerprint)
                }
            }
            ,
            t.writeDtlsParameters = function(n, r) {
                let i = "a=setup:" + r + `\r
`;
                return n.fingerprints.forEach(s=>{
                        i += "a=fingerprint:" + s.algorithm + " " + s.value + `\r
`
                    }
                ),
                    i
            }
            ,
            t.parseCryptoLine = function(n) {
                const r = n.substring(9).split(" ");
                return {
                    tag: parseInt(r[0], 10),
                    cryptoSuite: r[1],
                    keyParams: r[2],
                    sessionParams: r.slice(3)
                }
            }
            ,
            t.writeCryptoLine = function(n) {
                return "a=crypto:" + n.tag + " " + n.cryptoSuite + " " + (typeof n.keyParams == "object" ? t.writeCryptoKeyParams(n.keyParams) : n.keyParams) + (n.sessionParams ? " " + n.sessionParams.join(" ") : "") + `\r
`
            }
            ,
            t.parseCryptoKeyParams = function(n) {
                if (n.indexOf("inline:") !== 0)
                    return null;
                const r = n.substring(7).split("|");
                return {
                    keyMethod: "inline",
                    keySalt: r[0],
                    lifeTime: r[1],
                    mkiValue: r[2] ? r[2].split(":")[0] : void 0,
                    mkiLength: r[2] ? r[2].split(":")[1] : void 0
                }
            }
            ,
            t.writeCryptoKeyParams = function(n) {
                return n.keyMethod + ":" + n.keySalt + (n.lifeTime ? "|" + n.lifeTime : "") + (n.mkiValue && n.mkiLength ? "|" + n.mkiValue + ":" + n.mkiLength : "")
            }
            ,
            t.getCryptoParameters = function(n, r) {
                return t.matchPrefix(n + r, "a=crypto:").map(t.parseCryptoLine)
            }
            ,
            t.getIceParameters = function(n, r) {
                const i = t.matchPrefix(n + r, "a=ice-ufrag:")[0]
                    , s = t.matchPrefix(n + r, "a=ice-pwd:")[0];
                return i && s ? {
                    usernameFragment: i.substring(12),
                    password: s.substring(10)
                } : null
            }
            ,
            t.writeIceParameters = function(n) {
                let r = "a=ice-ufrag:" + n.usernameFragment + `\r
a=ice-pwd:` + n.password + `\r
`;
                return n.iceLite && (r += `a=ice-lite\r
`),
                    r
            }
            ,
            t.parseRtpParameters = function(n) {
                const r = {
                    codecs: [],
                    headerExtensions: [],
                    fecMechanisms: [],
                    rtcp: []
                }
                    , s = t.splitLines(n)[0].split(" ");
                r.profile = s[2];
                for (let a = 3; a < s.length; a++) {
                    const l = s[a]
                        , c = t.matchPrefix(n, "a=rtpmap:" + l + " ")[0];
                    if (c) {
                        const u = t.parseRtpMap(c)
                            , f = t.matchPrefix(n, "a=fmtp:" + l + " ");
                        switch (u.parameters = f.length ? t.parseFmtp(f[0]) : {},
                            u.rtcpFeedback = t.matchPrefix(n, "a=rtcp-fb:" + l + " ").map(t.parseRtcpFb),
                            r.codecs.push(u),
                            u.name.toUpperCase()) {
                            case "RED":
                            case "ULPFEC":
                                r.fecMechanisms.push(u.name.toUpperCase());
                                break
                        }
                    }
                }
                t.matchPrefix(n, "a=extmap:").forEach(a=>{
                        r.headerExtensions.push(t.parseExtmap(a))
                    }
                );
                const o = t.matchPrefix(n, "a=rtcp-fb:* ").map(t.parseRtcpFb);
                return r.codecs.forEach(a=>{
                        o.forEach(l=>{
                                a.rtcpFeedback.find(u=>u.type === l.type && u.parameter === l.parameter) || a.rtcpFeedback.push(l)
                            }
                        )
                    }
                ),
                    r
            }
            ,
            t.writeRtpDescription = function(n, r) {
                let i = "";
                i += "m=" + n + " ",
                    i += r.codecs.length > 0 ? "9" : "0",
                    i += " " + (r.profile || "UDP/TLS/RTP/SAVPF") + " ",
                    i += r.codecs.map(o=>o.preferredPayloadType !== void 0 ? o.preferredPayloadType : o.payloadType).join(" ") + `\r
`,
                    i += `c=IN IP4 0.0.0.0\r
`,
                    i += `a=rtcp:9 IN IP4 0.0.0.0\r
`,
                    r.codecs.forEach(o=>{
                            i += t.writeRtpMap(o),
                                i += t.writeFmtp(o),
                                i += t.writeRtcpFb(o)
                        }
                    );
                let s = 0;
                return r.codecs.forEach(o=>{
                        o.maxptime > s && (s = o.maxptime)
                    }
                ),
                s > 0 && (i += "a=maxptime:" + s + `\r
`),
                r.headerExtensions && r.headerExtensions.forEach(o=>{
                        i += t.writeExtmap(o)
                    }
                ),
                    i
            }
            ,
            t.parseRtpEncodingParameters = function(n) {
                const r = []
                    , i = t.parseRtpParameters(n)
                    , s = i.fecMechanisms.indexOf("RED") !== -1
                    , o = i.fecMechanisms.indexOf("ULPFEC") !== -1
                    , a = t.matchPrefix(n, "a=ssrc:").map(d=>t.parseSsrcMedia(d)).filter(d=>d.attribute === "cname")
                    , l = a.length > 0 && a[0].ssrc;
                let c;
                const u = t.matchPrefix(n, "a=ssrc-group:FID").map(d=>d.substring(17).split(" ").map(y=>parseInt(y, 10)));
                u.length > 0 && u[0].length > 1 && u[0][0] === l && (c = u[0][1]),
                    i.codecs.forEach(d=>{
                            if (d.name.toUpperCase() === "RTX" && d.parameters.apt) {
                                let h = {
                                    ssrc: l,
                                    codecPayloadType: parseInt(d.parameters.apt, 10)
                                };
                                l && c && (h.rtx = {
                                    ssrc: c
                                }),
                                    r.push(h),
                                s && (h = JSON.parse(JSON.stringify(h)),
                                    h.fec = {
                                        ssrc: l,
                                        mechanism: o ? "red+ulpfec" : "red"
                                    },
                                    r.push(h))
                            }
                        }
                    ),
                r.length === 0 && l && r.push({
                    ssrc: l
                });
                let f = t.matchPrefix(n, "b=");
                return f.length && (f[0].indexOf("b=TIAS:") === 0 ? f = parseInt(f[0].substring(7), 10) : f[0].indexOf("b=AS:") === 0 ? f = parseInt(f[0].substring(5), 10) * 1e3 * .95 - 50 * 40 * 8 : f = void 0,
                    r.forEach(d=>{
                            d.maxBitrate = f
                        }
                    )),
                    r
            }
            ,
            t.parseRtcpParameters = function(n) {
                const r = {}
                    , i = t.matchPrefix(n, "a=ssrc:").map(a=>t.parseSsrcMedia(a)).filter(a=>a.attribute === "cname")[0];
                i && (r.cname = i.value,
                    r.ssrc = i.ssrc);
                const s = t.matchPrefix(n, "a=rtcp-rsize");
                r.reducedSize = s.length > 0,
                    r.compound = s.length === 0;
                const o = t.matchPrefix(n, "a=rtcp-mux");
                return r.mux = o.length > 0,
                    r
            }
            ,
            t.writeRtcpParameters = function(n) {
                let r = "";
                return n.reducedSize && (r += `a=rtcp-rsize\r
`),
                n.mux && (r += `a=rtcp-mux\r
`),
                n.ssrc !== void 0 && n.cname && (r += "a=ssrc:" + n.ssrc + " cname:" + n.cname + `\r
`),
                    r
            }
            ,
            t.parseMsid = function(n) {
                let r;
                const i = t.matchPrefix(n, "a=msid:");
                if (i.length === 1)
                    return r = i[0].substring(7).split(" "),
                        {
                            stream: r[0],
                            track: r[1]
                        };
                const s = t.matchPrefix(n, "a=ssrc:").map(o=>t.parseSsrcMedia(o)).filter(o=>o.attribute === "msid");
                if (s.length > 0)
                    return r = s[0].value.split(" "),
                        {
                            stream: r[0],
                            track: r[1]
                        }
            }
            ,
            t.parseSctpDescription = function(n) {
                const r = t.parseMLine(n)
                    , i = t.matchPrefix(n, "a=max-message-size:");
                let s;
                i.length > 0 && (s = parseInt(i[0].substring(19), 10)),
                isNaN(s) && (s = 65536);
                const o = t.matchPrefix(n, "a=sctp-port:");
                if (o.length > 0)
                    return {
                        port: parseInt(o[0].substring(12), 10),
                        protocol: r.fmt,
                        maxMessageSize: s
                    };
                const a = t.matchPrefix(n, "a=sctpmap:");
                if (a.length > 0) {
                    const l = a[0].substring(10).split(" ");
                    return {
                        port: parseInt(l[0], 10),
                        protocol: l[1],
                        maxMessageSize: s
                    }
                }
            }
            ,
            t.writeSctpDescription = function(n, r) {
                let i = [];
                return n.protocol !== "DTLS/SCTP" ? i = ["m=" + n.kind + " 9 " + n.protocol + " " + r.protocol + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctp-port:" + r.port + `\r
`] : i = ["m=" + n.kind + " 9 " + n.protocol + " " + r.port + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctpmap:" + r.port + " " + r.protocol + ` 65535\r
`],
                r.maxMessageSize !== void 0 && i.push("a=max-message-size:" + r.maxMessageSize + `\r
`),
                    i.join("")
            }
            ,
            t.generateSessionId = function() {
                return Math.random().toString().substr(2, 22)
            }
            ,
            t.writeSessionBoilerplate = function(n, r, i) {
                let s;
                const o = r !== void 0 ? r : 2;
                return n ? s = n : s = t.generateSessionId(),
                `v=0\r
o=` + (i || "thisisadapterortc") + " " + s + " " + o + ` IN IP4 127.0.0.1\r
s=-\r
t=0 0\r
`
            }
            ,
            t.getDirection = function(n, r) {
                const i = t.splitLines(n);
                for (let s = 0; s < i.length; s++)
                    switch (i[s]) {
                        case "a=sendrecv":
                        case "a=sendonly":
                        case "a=recvonly":
                        case "a=inactive":
                            return i[s].substring(2)
                    }
                return r ? t.getDirection(r) : "sendrecv"
            }
            ,
            t.getKind = function(n) {
                return t.splitLines(n)[0].split(" ")[0].substring(2)
            }
            ,
            t.isRejected = function(n) {
                return n.split(" ", 2)[1] === "0"
            }
            ,
            t.parseMLine = function(n) {
                const i = t.splitLines(n)[0].substring(2).split(" ");
                return {
                    kind: i[0],
                    port: parseInt(i[1], 10),
                    protocol: i[2],
                    fmt: i.slice(3).join(" ")
                }
            }
            ,
            t.parseOLine = function(n) {
                const i = t.matchPrefix(n, "o=")[0].substring(2).split(" ");
                return {
                    username: i[0],
                    sessionId: i[1],
                    sessionVersion: parseInt(i[2], 10),
                    netType: i[3],
                    addressType: i[4],
                    address: i[5]
                }
            }
            ,
            t.isValidSDP = function(n) {
                if (typeof n != "string" || n.length === 0)
                    return !1;
                const r = t.splitLines(n);
                for (let i = 0; i < r.length; i++)
                    if (r[i].length < 2 || r[i].charAt(1) !== "=")
                        return !1;
                return !0
            }
            ,
            e.exports = t
    }
)(Xb);
var Kb = Xb.exports;
const Pi = _v(Kb)
    , rI = Z0({
    __proto__: null,
    default: Pi
}, [Kb]);
function Ho(e) {
    if (!e.RTCIceCandidate || e.RTCIceCandidate && "foundation"in e.RTCIceCandidate.prototype)
        return;
    const t = e.RTCIceCandidate;
    e.RTCIceCandidate = function(r) {
        if (typeof r == "object" && r.candidate && r.candidate.indexOf("a=") === 0 && (r = JSON.parse(JSON.stringify(r)),
            r.candidate = r.candidate.substring(2)),
        r.candidate && r.candidate.length) {
            const i = new t(r)
                , s = Pi.parseCandidate(r.candidate);
            for (const o in s)
                o in i || Object.defineProperty(i, o, {
                    value: s[o]
                });
            return i.toJSON = function() {
                return {
                    candidate: i.candidate,
                    sdpMid: i.sdpMid,
                    sdpMLineIndex: i.sdpMLineIndex,
                    usernameFragment: i.usernameFragment
                }
            }
                ,
                i
        }
        return new t(r)
    }
        ,
        e.RTCIceCandidate.prototype = t.prototype,
        ni(e, "icecandidate", n=>(n.candidate && Object.defineProperty(n, "candidate", {
            value: new e.RTCIceCandidate(n.candidate),
            writable: "false"
        }),
            n))
}
function eu(e) {
    !e.RTCIceCandidate || e.RTCIceCandidate && "relayProtocol"in e.RTCIceCandidate.prototype || ni(e, "icecandidate", t=>{
            if (t.candidate) {
                const n = Pi.parseCandidate(t.candidate.candidate);
                n.type === "relay" && (t.candidate.relayProtocol = {
                    0: "tls",
                    1: "tcp",
                    2: "udp"
                }[n.priority >> 24])
            }
            return t
        }
    )
}
function Bo(e, t) {
    if (!e.RTCPeerConnection)
        return;
    "sctp"in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "sctp", {
        get() {
            return typeof this._sctp > "u" ? null : this._sctp
        }
    });
    const n = function(a) {
        if (!a || !a.sdp)
            return !1;
        const l = Pi.splitSections(a.sdp);
        return l.shift(),
            l.some(c=>{
                    const u = Pi.parseMLine(c);
                    return u && u.kind === "application" && u.protocol.indexOf("SCTP") !== -1
                }
            )
    }
        , r = function(a) {
        const l = a.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
        if (l === null || l.length < 2)
            return -1;
        const c = parseInt(l[1], 10);
        return c !== c ? -1 : c
    }
        , i = function(a) {
        let l = 65536;
        return t.browser === "firefox" && (t.version < 57 ? a === -1 ? l = 16384 : l = 2147483637 : t.version < 60 ? l = t.version === 57 ? 65535 : 65536 : l = 2147483637),
            l
    }
        , s = function(a, l) {
        let c = 65536;
        t.browser === "firefox" && t.version === 57 && (c = 65535);
        const u = Pi.matchPrefix(a.sdp, "a=max-message-size:");
        return u.length > 0 ? c = parseInt(u[0].substring(19), 10) : t.browser === "firefox" && l !== -1 && (c = 2147483637),
            c
    }
        , o = e.RTCPeerConnection.prototype.setRemoteDescription;
    e.RTCPeerConnection.prototype.setRemoteDescription = function() {
        if (this._sctp = null,
        t.browser === "chrome" && t.version >= 76) {
            const {sdpSemantics: l} = this.getConfiguration();
            l === "plan-b" && Object.defineProperty(this, "sctp", {
                get() {
                    return typeof this._sctp > "u" ? null : this._sctp
                },
                enumerable: !0,
                configurable: !0
            })
        }
        if (n(arguments[0])) {
            const l = r(arguments[0])
                , c = i(l)
                , u = s(arguments[0], l);
            let f;
            c === 0 && u === 0 ? f = Number.POSITIVE_INFINITY : c === 0 || u === 0 ? f = Math.max(c, u) : f = Math.min(c, u);
            const d = {};
            Object.defineProperty(d, "maxMessageSize", {
                get() {
                    return f
                }
            }),
                this._sctp = d
        }
        return o.apply(this, arguments)
    }
}
function Vo(e) {
    if (!(e.RTCPeerConnection && "createDataChannel"in e.RTCPeerConnection.prototype))
        return;
    function t(r, i) {
        const s = r.send;
        r.send = function() {
            const a = arguments[0]
                , l = a.length || a.size || a.byteLength;
            if (r.readyState === "open" && i.sctp && l > i.sctp.maxMessageSize)
                throw new TypeError("Message too large (can send a maximum of " + i.sctp.maxMessageSize + " bytes)");
            return s.apply(r, arguments)
        }
    }
    const n = e.RTCPeerConnection.prototype.createDataChannel;
    e.RTCPeerConnection.prototype.createDataChannel = function() {
        const i = n.apply(this, arguments);
        return t(i, this),
            i
    }
        ,
        ni(e, "datachannel", r=>(t(r.channel, r.target),
            r))
}
function tu(e) {
    if (!e.RTCPeerConnection || "connectionState"in e.RTCPeerConnection.prototype)
        return;
    const t = e.RTCPeerConnection.prototype;
    Object.defineProperty(t, "connectionState", {
        get() {
            return {
                completed: "connected",
                checking: "connecting"
            }[this.iceConnectionState] || this.iceConnectionState
        },
        enumerable: !0,
        configurable: !0
    }),
        Object.defineProperty(t, "onconnectionstatechange", {
            get() {
                return this._onconnectionstatechange || null
            },
            set(n) {
                this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange),
                    delete this._onconnectionstatechange),
                n && this.addEventListener("connectionstatechange", this._onconnectionstatechange = n)
            },
            enumerable: !0,
            configurable: !0
        }),
        ["setLocalDescription", "setRemoteDescription"].forEach(n=>{
                const r = t[n];
                t[n] = function() {
                    return this._connectionstatechangepoly || (this._connectionstatechangepoly = i=>{
                        const s = i.target;
                        if (s._lastConnectionState !== s.connectionState) {
                            s._lastConnectionState = s.connectionState;
                            const o = new Event("connectionstatechange",i);
                            s.dispatchEvent(o)
                        }
                        return i
                    }
                        ,
                        this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)),
                        r.apply(this, arguments)
                }
            }
        )
}
function nu(e, t) {
    if (!e.RTCPeerConnection || t.browser === "chrome" && t.version >= 71 || t.browser === "safari" && t.version >= 605)
        return;
    const n = e.RTCPeerConnection.prototype.setRemoteDescription;
    e.RTCPeerConnection.prototype.setRemoteDescription = function(i) {
        if (i && i.sdp && i.sdp.indexOf(`
a=extmap-allow-mixed`) !== -1) {
            const s = i.sdp.split(`
`).filter(o=>o.trim() !== "a=extmap-allow-mixed").join(`
`);
            e.RTCSessionDescription && i instanceof e.RTCSessionDescription ? arguments[0] = new e.RTCSessionDescription({
                type: i.type,
                sdp: s
            }) : i.sdp = s
        }
        return n.apply(this, arguments)
    }
}
function zo(e, t) {
    if (!(e.RTCPeerConnection && e.RTCPeerConnection.prototype))
        return;
    const n = e.RTCPeerConnection.prototype.addIceCandidate;
    !n || n.length === 0 || (e.RTCPeerConnection.prototype.addIceCandidate = function() {
            return arguments[0] ? (t.browser === "chrome" && t.version < 78 || t.browser === "firefox" && t.version < 68 || t.browser === "safari") && arguments[0] && arguments[0].candidate === "" ? Promise.resolve() : n.apply(this, arguments) : (arguments[1] && arguments[1].apply(null),
                Promise.resolve())
        }
    )
}
function Uo(e, t) {
    if (!(e.RTCPeerConnection && e.RTCPeerConnection.prototype))
        return;
    const n = e.RTCPeerConnection.prototype.setLocalDescription;
    !n || n.length === 0 || (e.RTCPeerConnection.prototype.setLocalDescription = function() {
            let i = arguments[0] || {};
            if (typeof i != "object" || i.type && i.sdp)
                return n.apply(this, arguments);
            if (i = {
                type: i.type,
                sdp: i.sdp
            },
                !i.type)
                switch (this.signalingState) {
                    case "stable":
                    case "have-local-offer":
                    case "have-remote-pranswer":
                        i.type = "offer";
                        break;
                    default:
                        i.type = "answer";
                        break
                }
            return i.sdp || i.type !== "offer" && i.type !== "answer" ? n.apply(this, [i]) : (i.type === "offer" ? this.createOffer : this.createAnswer).apply(this).then(o=>n.apply(this, [o]))
        }
    )
}
const iI = Object.freeze(Object.defineProperty({
    __proto__: null,
    removeExtmapAllowMixed: nu,
    shimAddIceCandidateNullOrEmpty: zo,
    shimConnectionState: tu,
    shimMaxMessageSize: Bo,
    shimParameterlessSetLocalDescription: Uo,
    shimRTCIceCandidate: Ho,
    shimRTCIceCandidateRelayProtocol: eu,
    shimSendThrowTypeError: Vo
}, Symbol.toStringTag, {
    value: "Module"
}));
function sI({window: e}={}, t={
    shimChrome: !0,
    shimFirefox: !0,
    shimSafari: !0
}) {
    const n = vb
        , r = eI(e)
        , i = {
        browserDetails: r,
        commonShim: iI,
        extractVersion: jo,
        disableLog: ZA,
        disableWarnings: QA,
        sdp: rI
    };
    switch (r.browser) {
        case "chrome":
            if (!Bh || !Zc || !t.shimChrome)
                return n("Chrome shim is not included in this adapter release."),
                    i;
            if (r.version === null)
                return n("Chrome shim can not determine version, not shimming."),
                    i;
            n("adapter.js shimming chrome."),
                i.browserShim = Bh,
                zo(e, r),
                Uo(e),
                bb(e, r),
                wb(e),
                Zc(e, r),
                Sb(e),
                xb(e, r),
                _b(e),
                Eb(e),
                Cb(e),
                Pb(e, r),
                Ho(e),
                eu(e),
                tu(e),
                Bo(e, r),
                Vo(e),
                nu(e, r);
            break;
        case "firefox":
            if (!Vh || !Qc || !t.shimFirefox)
                return n("Firefox shim is not included in this adapter release."),
                    i;
            n("adapter.js shimming firefox."),
                i.browserShim = Vh,
                zo(e, r),
                Uo(e),
                kb(e, r),
                Qc(e, r),
                Rb(e),
                Ab(e),
                Lb(e),
                Ob(e),
                Ib(e),
                Mb(e),
                Db(e),
                Nb(e),
                $b(e),
                Ho(e),
                tu(e),
                Bo(e, r),
                Vo(e);
            break;
        case "safari":
            if (!zh || !t.shimSafari)
                return n("Safari shim is not included in this adapter release."),
                    i;
            n("adapter.js shimming safari."),
                i.browserShim = zh,
                zo(e, r),
                Uo(e),
                zb(e),
                Wb(e),
                Hb(e),
                Fb(e),
                jb(e),
                Ub(e),
                Bb(e),
                Gb(e),
                Ho(e),
                eu(e),
                Bo(e, r),
                Vo(e),
                nu(e, r);
            break;
        default:
            n("Unsupported browser!");
            break
    }
    return i
}
const rs = sI({
    window: typeof window > "u" ? void 0 : window
})
    , ri = At(()=>{
        const {videoInputs: e, audioInputs: t, permissionGranted: n, ensurePermissions: r, audioOutputs: i, isSupported: s} = zL({
            requestPermissions: !1,
            onUpdated() {
                P()
            }
        })
            , o = X(!1)
            , a = X(!1)
            , l = X(!1)
            , c = X(!1)
            , u = X(0)
            , f = async()=>{
            let I = !1;
            c.value = !0,
                a.value = !0,
                l.value = !0;
            try {
                I = await r()
            } catch {
                I = !1
            }
            return l.value = !1,
            I && u.value++,
                I
        }
            , d = Gr("camera", null)
            , h = Gr("mic", null)
            , y = fe(()=>e.value.find(I=>I.deviceId === d.value))
            , p = fe(()=>t.value.find(I=>I.deviceId === h.value));
        let w = navigator.mediaDevices.getSupportedConstraints();
        Ve(()=>{
                w = navigator.mediaDevices.getSupportedConstraints()
            }
        );
        const m = fe(()=>({
            video: d.value ? {
                deviceId: d.value
            } : !0,
            audio: h.value ? {
                deviceId: h.value,
                echoCancellation: w.echoCancellation ? !0 : void 0,
                noiseSuppression: w.noiseSuppression ? !0 : void 0
            } : !0
        }))
            , {stream: g, start: b, stop: v, restart: S} = cO({
            autoSwitch: !0,
            constraints: m
        });
        Se(m, ()=>{
                f()
            }
        ),
            Se(u, ()=>{
                    S()
                }
            );
        const _ = NR(g, 50);
        function E(I, L) {
            return I = Math.ceil(I),
                L = Math.floor(L),
                Math.floor(Math.random() * (L - I) + I)
        }
        let T = null;
        Se(g, async I=>{
                if (I != null) {
                    c.value = !0;
                    let L = E(1, 1e5);
                    T = L,
                    await new Promise(async A=>{
                            for (; !(I != null && I.getAudioTracks().length && (I != null && I.getVideoTracks().length)); )
                                if (await hb(500),
                                L !== T)
                                    return A(!1);
                            return A(L === T)
                        }
                    ) && (c.value = !1,
                        o.value = !0)
                }
            }
        );
        async function P() {
            var I, L, x, A;
            n.value && (y.value == null && (d.value = (L = (I = e.value) == null ? void 0 : I[0]) == null ? void 0 : L.deviceId),
            p.value == null && (h.value = (A = (x = t.value) == null ? void 0 : x[0]) == null ? void 0 : A.deviceId))
        }
        return {
            camera: d,
            mic: h,
            cameras: e,
            mics: t,
            audioOutputs: i,
            stream: _,
            start: b,
            stop: v,
            isSupported: s,
            update: P,
            cameraDevice: y,
            micDevice: p,
            cameraAndMicPermissionGranted: n,
            isWaitingForMedia: l,
            ensurePermissions: f,
            isWaitingForStream: c,
            setMic(I) {
                h.value = I == null ? void 0 : I.deviceId
            },
            setCamera(I) {
                d.value = I == null ? void 0 : I.deviceId
            },
            isMediaRequested: a,
            isMediaInited: o
        }
    }
)
    , oI = ["au", "at", "al", "ar", "am", "by", "be", "bg", "ba", "br", "gb", "hu", "ve", "de", "gr", "dk", "il", "in", "id", "ie", "es", "it", "kz", "ca", "cn", "co", "kr", "lv", "lt", "lu", "my", "mx", "md", "nl", "nz", "no", "pe", "pl", "pt", "ru", "ro", "mk", "rs", "sk", "si", "us", "th", "tw", "tr", "ua", "ph", "fi", "fr", "hr", "cz", "cl", "ch", "se", "za", "jp"]
    , Yb = At(()=>{
        const {t: e} = $n()
            , t = {
            country: "un",
            label: e("country.world")
        }
            , n = X()
            , r = Gr("selected-countries", [])
            , i = X(oI)
            , s = fe(()=>[t, ...i.value.map(f=>({
            country: f,
            label: e("country." + f)
        }))]);
        function o(f) {
            r.value = f.filter(d=>!!s.value.find(h=>h.country === d) && d !== t.country)
        }
        function a() {
            r.value = []
        }
        function l(f) {
            o(f.map(d=>d.country))
        }
        const c = fe(()=>{
                const f = s.value.filter(d=>r.value.includes(d.country));
                return f.length ? f : [t]
            }
        );
        return {
            currentCountry: n,
            selectedCountriesISO: r,
            countries: s,
            setSelectedCountry: l,
            setSelectedCountryISO: o,
            setAllCountries: a,
            selectedCountries: c,
            initCountry: f=>{
                f && (r.value.length || o([f]),
                    n.value = f)
            }
            ,
            allCountries: t
        }
    }
);
var ru = function() {
    return ru = Object.assign || function(t) {
        for (var n, r = 1, i = arguments.length; r < i; r++) {
            n = arguments[r];
            for (var s in n)
                Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s])
        }
        return t
    }
        ,
        ru.apply(this, arguments)
};
function Qn(e, t, n, r) {
    function i(s) {
        return s instanceof n ? s : new n(function(o) {
                o(s)
            }
        )
    }
    return new (n || (n = Promise))(function(s, o) {
            function a(u) {
                try {
                    c(r.next(u))
                } catch (f) {
                    o(f)
                }
            }
            function l(u) {
                try {
                    c(r.throw(u))
                } catch (f) {
                    o(f)
                }
            }
            function c(u) {
                u.done ? s(u.value) : i(u.value).then(a, l)
            }
            c((r = r.apply(e, t || [])).next())
        }
    )
}
function er(e, t) {
    var n = {
        label: 0,
        sent: function() {
            if (s[0] & 1)
                throw s[1];
            return s[1]
        },
        trys: [],
        ops: []
    }, r, i, s, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    },
    typeof Symbol == "function" && (o[Symbol.iterator] = function() {
            return this
        }
    ),
        o;
    function a(c) {
        return function(u) {
            return l([c, u])
        }
    }
    function l(c) {
        if (r)
            throw new TypeError("Generator is already executing.");
        for (; o && (o = 0,
        c[0] && (n = 0)),
                   n; )
            try {
                if (r = 1,
                i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i),
                    0) : i.next) && !(s = s.call(i, c[1])).done)
                    return s;
                switch (i = 0,
                s && (c = [c[0] & 2, s.value]),
                    c[0]) {
                    case 0:
                    case 1:
                        s = c;
                        break;
                    case 4:
                        return n.label++,
                            {
                                value: c[1],
                                done: !1
                            };
                    case 5:
                        n.label++,
                            i = c[1],
                            c = [0];
                        continue;
                    case 7:
                        c = n.ops.pop(),
                            n.trys.pop();
                        continue;
                    default:
                        if (s = n.trys,
                        !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                            n = 0;
                            continue
                        }
                        if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
                            n.label = c[1];
                            break
                        }
                        if (c[0] === 6 && n.label < s[1]) {
                            n.label = s[1],
                                s = c;
                            break
                        }
                        if (s && n.label < s[2]) {
                            n.label = s[2],
                                n.ops.push(c);
                            break
                        }
                        s[2] && n.ops.pop(),
                            n.trys.pop();
                        continue
                }
                c = t.call(e, n)
            } catch (u) {
                c = [6, u],
                    i = 0
            } finally {
                r = s = 0
            }
        if (c[0] & 5)
            throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        }
    }
}
function qb(e, t, n) {
    if (n || arguments.length === 2)
        for (var r = 0, i = t.length, s; r < i; r++)
            (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)),
                s[r] = t[r]);
    return e.concat(s || Array.prototype.slice.call(t))
}
var Jb = "3.4.2";
function Us(e, t) {
    return new Promise(function(n) {
            return setTimeout(n, e, t)
        }
    )
}
function aI(e, t) {
    t === void 0 && (t = 1 / 0);
    var n = window.requestIdleCallback;
    return n ? new Promise(function(r) {
            return n.call(window, function() {
                return r()
            }, {
                timeout: t
            })
        }
    ) : Us(Math.min(e, t))
}
function Zb(e) {
    return !!e && typeof e.then == "function"
}
function Uh(e, t) {
    try {
        var n = e();
        Zb(n) ? n.then(function(r) {
            return t(!0, r)
        }, function(r) {
            return t(!1, r)
        }) : t(!0, n)
    } catch (r) {
        t(!1, r)
    }
}
function Wh(e, t, n) {
    return n === void 0 && (n = 16),
        Qn(this, void 0, void 0, function() {
            var r, i, s, o;
            return er(this, function(a) {
                switch (a.label) {
                    case 0:
                        r = Array(e.length),
                            i = Date.now(),
                            s = 0,
                            a.label = 1;
                    case 1:
                        return s < e.length ? (r[s] = t(e[s], s),
                            o = Date.now(),
                            o >= i + n ? (i = o,
                                [4, Us(0)]) : [3, 3]) : [3, 4];
                    case 2:
                        a.sent(),
                            a.label = 3;
                    case 3:
                        return ++s,
                            [3, 1];
                    case 4:
                        return [2, r]
                }
            })
        })
}
function Ws(e) {
    e.then(void 0, function() {})
}
function sr(e, t) {
    e = [e[0] >>> 16, e[0] & 65535, e[1] >>> 16, e[1] & 65535],
        t = [t[0] >>> 16, t[0] & 65535, t[1] >>> 16, t[1] & 65535];
    var n = [0, 0, 0, 0];
    return n[3] += e[3] + t[3],
        n[2] += n[3] >>> 16,
        n[3] &= 65535,
        n[2] += e[2] + t[2],
        n[1] += n[2] >>> 16,
        n[2] &= 65535,
        n[1] += e[1] + t[1],
        n[0] += n[1] >>> 16,
        n[1] &= 65535,
        n[0] += e[0] + t[0],
        n[0] &= 65535,
        [n[0] << 16 | n[1], n[2] << 16 | n[3]]
}
function an(e, t) {
    e = [e[0] >>> 16, e[0] & 65535, e[1] >>> 16, e[1] & 65535],
        t = [t[0] >>> 16, t[0] & 65535, t[1] >>> 16, t[1] & 65535];
    var n = [0, 0, 0, 0];
    return n[3] += e[3] * t[3],
        n[2] += n[3] >>> 16,
        n[3] &= 65535,
        n[2] += e[2] * t[3],
        n[1] += n[2] >>> 16,
        n[2] &= 65535,
        n[2] += e[3] * t[2],
        n[1] += n[2] >>> 16,
        n[2] &= 65535,
        n[1] += e[1] * t[3],
        n[0] += n[1] >>> 16,
        n[1] &= 65535,
        n[1] += e[2] * t[2],
        n[0] += n[1] >>> 16,
        n[1] &= 65535,
        n[1] += e[3] * t[1],
        n[0] += n[1] >>> 16,
        n[1] &= 65535,
        n[0] += e[0] * t[3] + e[1] * t[2] + e[2] * t[1] + e[3] * t[0],
        n[0] &= 65535,
        [n[0] << 16 | n[1], n[2] << 16 | n[3]]
}
function ui(e, t) {
    return t %= 64,
        t === 32 ? [e[1], e[0]] : t < 32 ? [e[0] << t | e[1] >>> 32 - t, e[1] << t | e[0] >>> 32 - t] : (t -= 32,
            [e[1] << t | e[0] >>> 32 - t, e[0] << t | e[1] >>> 32 - t])
}
function Yt(e, t) {
    return t %= 64,
        t === 0 ? e : t < 32 ? [e[0] << t | e[1] >>> 32 - t, e[1] << t] : [e[1] << t - 32, 0]
}
function tt(e, t) {
    return [e[0] ^ t[0], e[1] ^ t[1]]
}
function Gh(e) {
    return e = tt(e, [0, e[0] >>> 1]),
        e = an(e, [4283543511, 3981806797]),
        e = tt(e, [0, e[0] >>> 1]),
        e = an(e, [3301882366, 444984403]),
        e = tt(e, [0, e[0] >>> 1]),
        e
}
function lI(e, t) {
    e = e || "",
        t = t || 0;
    var n = e.length % 16, r = e.length - n, i = [0, t], s = [0, t], o = [0, 0], a = [0, 0], l = [2277735313, 289559509], c = [1291169091, 658871167], u;
    for (u = 0; u < r; u = u + 16)
        o = [e.charCodeAt(u + 4) & 255 | (e.charCodeAt(u + 5) & 255) << 8 | (e.charCodeAt(u + 6) & 255) << 16 | (e.charCodeAt(u + 7) & 255) << 24, e.charCodeAt(u) & 255 | (e.charCodeAt(u + 1) & 255) << 8 | (e.charCodeAt(u + 2) & 255) << 16 | (e.charCodeAt(u + 3) & 255) << 24],
            a = [e.charCodeAt(u + 12) & 255 | (e.charCodeAt(u + 13) & 255) << 8 | (e.charCodeAt(u + 14) & 255) << 16 | (e.charCodeAt(u + 15) & 255) << 24, e.charCodeAt(u + 8) & 255 | (e.charCodeAt(u + 9) & 255) << 8 | (e.charCodeAt(u + 10) & 255) << 16 | (e.charCodeAt(u + 11) & 255) << 24],
            o = an(o, l),
            o = ui(o, 31),
            o = an(o, c),
            i = tt(i, o),
            i = ui(i, 27),
            i = sr(i, s),
            i = sr(an(i, [0, 5]), [0, 1390208809]),
            a = an(a, c),
            a = ui(a, 33),
            a = an(a, l),
            s = tt(s, a),
            s = ui(s, 31),
            s = sr(s, i),
            s = sr(an(s, [0, 5]), [0, 944331445]);
    switch (o = [0, 0],
        a = [0, 0],
        n) {
        case 15:
            a = tt(a, Yt([0, e.charCodeAt(u + 14)], 48));
        case 14:
            a = tt(a, Yt([0, e.charCodeAt(u + 13)], 40));
        case 13:
            a = tt(a, Yt([0, e.charCodeAt(u + 12)], 32));
        case 12:
            a = tt(a, Yt([0, e.charCodeAt(u + 11)], 24));
        case 11:
            a = tt(a, Yt([0, e.charCodeAt(u + 10)], 16));
        case 10:
            a = tt(a, Yt([0, e.charCodeAt(u + 9)], 8));
        case 9:
            a = tt(a, [0, e.charCodeAt(u + 8)]),
                a = an(a, c),
                a = ui(a, 33),
                a = an(a, l),
                s = tt(s, a);
        case 8:
            o = tt(o, Yt([0, e.charCodeAt(u + 7)], 56));
        case 7:
            o = tt(o, Yt([0, e.charCodeAt(u + 6)], 48));
        case 6:
            o = tt(o, Yt([0, e.charCodeAt(u + 5)], 40));
        case 5:
            o = tt(o, Yt([0, e.charCodeAt(u + 4)], 32));
        case 4:
            o = tt(o, Yt([0, e.charCodeAt(u + 3)], 24));
        case 3:
            o = tt(o, Yt([0, e.charCodeAt(u + 2)], 16));
        case 2:
            o = tt(o, Yt([0, e.charCodeAt(u + 1)], 8));
        case 1:
            o = tt(o, [0, e.charCodeAt(u)]),
                o = an(o, l),
                o = ui(o, 31),
                o = an(o, c),
                i = tt(i, o)
    }
    return i = tt(i, [0, e.length]),
        s = tt(s, [0, e.length]),
        i = sr(i, s),
        s = sr(s, i),
        i = Gh(i),
        s = Gh(s),
        i = sr(i, s),
        s = sr(s, i),
    ("00000000" + (i[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (i[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (s[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (s[1] >>> 0).toString(16)).slice(-8)
}
function cI(e) {
    var t;
    return ru({
        name: e.name,
        message: e.message,
        stack: (t = e.stack) === null || t === void 0 ? void 0 : t.split(`
`)
    }, e)
}
function uI(e, t) {
    for (var n = 0, r = e.length; n < r; ++n)
        if (e[n] === t)
            return !0;
    return !1
}
function fI(e, t) {
    return !uI(e, t)
}
function Df(e) {
    return parseInt(e)
}
function mn(e) {
    return parseFloat(e)
}
function Wn(e, t) {
    return typeof e == "number" && isNaN(e) ? t : e
}
function Pn(e) {
    return e.reduce(function(t, n) {
        return t + (n ? 1 : 0)
    }, 0)
}
function Qb(e, t) {
    if (t === void 0 && (t = 1),
    Math.abs(t) >= 1)
        return Math.round(e / t) * t;
    var n = 1 / t;
    return Math.round(e * n) / n
}
function dI(e) {
    for (var t, n, r = "Unexpected syntax '".concat(e, "'"), i = /^\s*([a-z-]*)(.*)$/i.exec(e), s = i[1] || void 0, o = {}, a = /([.:#][\w-]+|\[.+?\])/gi, l = function(d, h) {
        o[d] = o[d] || [],
            o[d].push(h)
    }; ; ) {
        var c = a.exec(i[2]);
        if (!c)
            break;
        var u = c[0];
        switch (u[0]) {
            case ".":
                l("class", u.slice(1));
                break;
            case "#":
                l("id", u.slice(1));
                break;
            case "[":
            {
                var f = /^\[([\w-]+)([~|^$*]?=("(.*?)"|([\w-]+)))?(\s+[is])?\]$/.exec(u);
                if (f)
                    l(f[1], (n = (t = f[4]) !== null && t !== void 0 ? t : f[5]) !== null && n !== void 0 ? n : "");
                else
                    throw new Error(r);
                break
            }
            default:
                throw new Error(r)
        }
    }
    return [s, o]
}
function Xh(e) {
    return e && typeof e == "object" && "message"in e ? e : {
        message: e
    }
}
function pI(e) {
    return typeof e != "function"
}
function hI(e, t) {
    var n = new Promise(function(r) {
            var i = Date.now();
            Uh(e.bind(null, t), function() {
                for (var s = [], o = 0; o < arguments.length; o++)
                    s[o] = arguments[o];
                var a = Date.now() - i;
                if (!s[0])
                    return r(function() {
                        return {
                            error: Xh(s[1]),
                            duration: a
                        }
                    });
                var l = s[1];
                if (pI(l))
                    return r(function() {
                        return {
                            value: l,
                            duration: a
                        }
                    });
                r(function() {
                    return new Promise(function(c) {
                            var u = Date.now();
                            Uh(l, function() {
                                for (var f = [], d = 0; d < arguments.length; d++)
                                    f[d] = arguments[d];
                                var h = a + Date.now() - u;
                                if (!f[0])
                                    return c({
                                        error: Xh(f[1]),
                                        duration: h
                                    });
                                c({
                                    value: f[1],
                                    duration: h
                                })
                            })
                        }
                    )
                })
            })
        }
    );
    return Ws(n),
        function() {
            return n.then(function(i) {
                return i()
            })
        }
}
function mI(e, t, n) {
    var r = Object.keys(e).filter(function(s) {
        return fI(n, s)
    })
        , i = Wh(r, function(s) {
        return hI(e[s], t)
    });
    return Ws(i),
        function() {
            return Qn(this, void 0, void 0, function() {
                var o, a, l, c, u;
                return er(this, function(f) {
                    switch (f.label) {
                        case 0:
                            return [4, i];
                        case 1:
                            return o = f.sent(),
                                [4, Wh(o, function(d) {
                                    var h = d();
                                    return Ws(h),
                                        h
                                })];
                        case 2:
                            return a = f.sent(),
                                [4, Promise.all(a)];
                        case 3:
                            for (l = f.sent(),
                                     c = {},
                                     u = 0; u < r.length; ++u)
                                c[r[u]] = l[u];
                            return [2, c]
                    }
                })
            })
        }
}
function e0() {
    var e = window
        , t = navigator;
    return Pn(["MSCSSMatrix"in e, "msSetImmediate"in e, "msIndexedDB"in e, "msMaxTouchPoints"in t, "msPointerEnabled"in t]) >= 4
}
function gI() {
    var e = window
        , t = navigator;
    return Pn(["msWriteProfilerMark"in e, "MSStream"in e, "msLaunchUri"in t, "msSaveBlob"in t]) >= 3 && !e0()
}
function Nf() {
    var e = window
        , t = navigator;
    return Pn(["webkitPersistentStorage"in t, "webkitTemporaryStorage"in t, t.vendor.indexOf("Google") === 0, "webkitResolveLocalFileSystemURL"in e, "BatteryManager"in e, "webkitMediaStream"in e, "webkitSpeechGrammar"in e]) >= 5
}
function so() {
    var e = window
        , t = navigator;
    return Pn(["ApplePayError"in e, "CSSPrimitiveValue"in e, "Counter"in e, t.vendor.indexOf("Apple") === 0, "getStorageUpdates"in t, "WebKitMediaKeys"in e]) >= 4
}
function $f() {
    var e = window;
    return Pn(["safari"in e, !("DeviceMotionEvent"in e), !("ongestureend"in e), !("standalone"in navigator)]) >= 3
}
function vI() {
    var e, t, n = window;
    return Pn(["buildID"in navigator, "MozAppearance"in ((t = (e = document.documentElement) === null || e === void 0 ? void 0 : e.style) !== null && t !== void 0 ? t : {}), "onmozfullscreenchange"in n, "mozInnerScreenX"in n, "CSSMozDocumentRule"in n, "CanvasCaptureMediaStream"in n]) >= 4
}
function yI() {
    var e = window;
    return Pn([!("MediaSettingsRange"in e), "RTCEncodedAudioFrame"in e, "" + e.Intl == "[object Intl]", "" + e.Reflect == "[object Reflect]"]) >= 3
}
function bI() {
    var e = window;
    return Pn(["DOMRectList"in e, "RTCPeerConnectionIceEvent"in e, "SVGGeometryElement"in e, "ontransitioncancel"in e]) >= 3
}
function wI() {
    if (navigator.platform === "iPad")
        return !0;
    var e = screen
        , t = e.width / e.height;
    return Pn(["MediaSource"in window, !!Element.prototype.webkitRequestFullscreen, t > .65 && t < 1.53]) >= 2
}
function SI() {
    var e = document;
    return e.fullscreenElement || e.msFullscreenElement || e.mozFullScreenElement || e.webkitFullscreenElement || null
}
function _I() {
    var e = document;
    return (e.exitFullscreen || e.msExitFullscreen || e.mozCancelFullScreen || e.webkitExitFullscreen).call(e)
}
function t0() {
    var e = Nf()
        , t = vI();
    if (!e && !t)
        return !1;
    var n = window;
    return Pn(["onorientationchange"in n, "orientation"in n, e && !("SharedWorker"in n), t && /android/i.test(navigator.appVersion)]) >= 2
}
function EI() {
    var e = window
        , t = e.OfflineAudioContext || e.webkitOfflineAudioContext;
    if (!t)
        return -2;
    if (CI())
        return -1;
    var n = 4500
        , r = 5e3
        , i = new t(1,r,44100)
        , s = i.createOscillator();
    s.type = "triangle",
        s.frequency.value = 1e4;
    var o = i.createDynamicsCompressor();
    o.threshold.value = -50,
        o.knee.value = 40,
        o.ratio.value = 12,
        o.attack.value = 0,
        o.release.value = .25,
        s.connect(o),
        o.connect(i.destination),
        s.start(0);
    var a = TI(i)
        , l = a[0]
        , c = a[1]
        , u = l.then(function(f) {
        return xI(f.getChannelData(0).subarray(n))
    }, function(f) {
        if (f.name === "timeout" || f.name === "suspended")
            return -3;
        throw f
    });
    return Ws(u),
        function() {
            return c(),
                u
        }
}
function CI() {
    return so() && !$f() && !bI()
}
function TI(e) {
    var t = 3
        , n = 500
        , r = 500
        , i = 5e3
        , s = function() {}
        , o = new Promise(function(a, l) {
            var c = !1
                , u = 0
                , f = 0;
            e.oncomplete = function(y) {
                return a(y.renderedBuffer)
            }
            ;
            var d = function() {
                setTimeout(function() {
                    return l(Kh("timeout"))
                }, Math.min(r, f + i - Date.now()))
            }
                , h = function() {
                try {
                    var y = e.startRendering();
                    switch (Zb(y) && Ws(y),
                        e.state) {
                        case "running":
                            f = Date.now(),
                            c && d();
                            break;
                        case "suspended":
                            document.hidden || u++,
                                c && u >= t ? l(Kh("suspended")) : setTimeout(h, n);
                            break
                    }
                } catch (p) {
                    l(p)
                }
            };
            h(),
                s = function() {
                    c || (c = !0,
                    f > 0 && d())
                }
        }
    );
    return [o, s]
}
function xI(e) {
    for (var t = 0, n = 0; n < e.length; ++n)
        t += Math.abs(e[n]);
    return t
}
function Kh(e) {
    var t = new Error(e);
    return t.name = e,
        t
}
function n0(e, t, n) {
    var r, i, s;
    return n === void 0 && (n = 50),
        Qn(this, void 0, void 0, function() {
            var o, a;
            return er(this, function(l) {
                switch (l.label) {
                    case 0:
                        o = document,
                            l.label = 1;
                    case 1:
                        return o.body ? [3, 3] : [4, Us(n)];
                    case 2:
                        return l.sent(),
                            [3, 1];
                    case 3:
                        a = o.createElement("iframe"),
                            l.label = 4;
                    case 4:
                        return l.trys.push([4, , 10, 11]),
                            [4, new Promise(function(c, u) {
                                    var f = !1
                                        , d = function() {
                                        f = !0,
                                            c()
                                    }
                                        , h = function(w) {
                                        f = !0,
                                            u(w)
                                    };
                                    a.onload = d,
                                        a.onerror = h;
                                    var y = a.style;
                                    y.setProperty("display", "block", "important"),
                                        y.position = "absolute",
                                        y.top = "0",
                                        y.left = "0",
                                        y.visibility = "hidden",
                                        t && "srcdoc"in a ? a.srcdoc = t : a.src = "about:blank",
                                        o.body.appendChild(a);
                                    var p = function() {
                                        var w, m;
                                        f || (((m = (w = a.contentWindow) === null || w === void 0 ? void 0 : w.document) === null || m === void 0 ? void 0 : m.readyState) === "complete" ? d() : setTimeout(p, 10))
                                    };
                                    p()
                                }
                            )];
                    case 5:
                        l.sent(),
                            l.label = 6;
                    case 6:
                        return !((i = (r = a.contentWindow) === null || r === void 0 ? void 0 : r.document) === null || i === void 0) && i.body ? [3, 8] : [4, Us(n)];
                    case 7:
                        return l.sent(),
                            [3, 6];
                    case 8:
                        return [4, e(a, a.contentWindow)];
                    case 9:
                        return [2, l.sent()];
                    case 10:
                        return (s = a.parentNode) === null || s === void 0 || s.removeChild(a),
                            [7];
                    case 11:
                        return [2]
                }
            })
        })
}
function PI(e) {
    for (var t = dI(e), n = t[0], r = t[1], i = document.createElement(n ?? "div"), s = 0, o = Object.keys(r); s < o.length; s++) {
        var a = o[s]
            , l = r[a].join(" ");
        a === "style" ? kI(i.style, l) : i.setAttribute(a, l)
    }
    return i
}
function kI(e, t) {
    for (var n = 0, r = t.split(";"); n < r.length; n++) {
        var i = r[n]
            , s = /^\s*([\w-]+)\s*:\s*(.+?)(\s*!([\w-]+))?\s*$/.exec(i);
        if (s) {
            var o = s[1]
                , a = s[2]
                , l = s[4];
            e.setProperty(o, a, l || "")
        }
    }
}
var RI = "mmMwWLliI0O&1"
    , LI = "48px"
    , fi = ["monospace", "sans-serif", "serif"]
    , Yh = ["sans-serif-thin", "ARNO PRO", "Agency FB", "Arabic Typesetting", "Arial Unicode MS", "AvantGarde Bk BT", "BankGothic Md BT", "Batang", "Bitstream Vera Sans Mono", "Calibri", "Century", "Century Gothic", "Clarendon", "EUROSTILE", "Franklin Gothic", "Futura Bk BT", "Futura Md BT", "GOTHAM", "Gill Sans", "HELV", "Haettenschweiler", "Helvetica Neue", "Humanst521 BT", "Leelawadee", "Letter Gothic", "Levenim MT", "Lucida Bright", "Lucida Sans", "Menlo", "MS Mincho", "MS Outlook", "MS Reference Specialty", "MS UI Gothic", "MT Extra", "MYRIAD PRO", "Marlett", "Meiryo UI", "Microsoft Uighur", "Minion Pro", "Monotype Corsiva", "PMingLiU", "Pristina", "SCRIPTINA", "Segoe UI Light", "Serifa", "SimHei", "Small Fonts", "Staccato222 BT", "TRAJAN PRO", "Univers CE 55 Medium", "Vrinda", "ZWAdobeF"];
function OI() {
    return n0(function(e, t) {
        var n = t.document
            , r = n.body;
        r.style.fontSize = LI;
        var i = n.createElement("div")
            , s = {}
            , o = {}
            , a = function(p) {
            var w = n.createElement("span")
                , m = w.style;
            return m.position = "absolute",
                m.top = "0",
                m.left = "0",
                m.fontFamily = p,
                w.textContent = RI,
                i.appendChild(w),
                w
        }
            , l = function(p, w) {
            return a("'".concat(p, "',").concat(w))
        }
            , c = function() {
            return fi.map(a)
        }
            , u = function() {
            for (var p = {}, w = function(v) {
                p[v] = fi.map(function(S) {
                    return l(v, S)
                })
            }, m = 0, g = Yh; m < g.length; m++) {
                var b = g[m];
                w(b)
            }
            return p
        }
            , f = function(p) {
            return fi.some(function(w, m) {
                return p[m].offsetWidth !== s[w] || p[m].offsetHeight !== o[w]
            })
        }
            , d = c()
            , h = u();
        r.appendChild(i);
        for (var y = 0; y < fi.length; y++)
            s[fi[y]] = d[y].offsetWidth,
                o[fi[y]] = d[y].offsetHeight;
        return Yh.filter(function(p) {
            return f(h[p])
        })
    })
}
function AI() {
    var e = navigator.plugins;
    if (e) {
        for (var t = [], n = 0; n < e.length; ++n) {
            var r = e[n];
            if (r) {
                for (var i = [], s = 0; s < r.length; ++s) {
                    var o = r[s];
                    i.push({
                        type: o.type,
                        suffixes: o.suffixes
                    })
                }
                t.push({
                    name: r.name,
                    description: r.description,
                    mimeTypes: i
                })
            }
        }
        return t
    }
}
function II() {
    var e = !1, t, n, r = MI(), i = r[0], s = r[1];
    if (!DI(i, s))
        t = n = "";
    else {
        e = NI(s),
            $I(i, s);
        var o = jl(i)
            , a = jl(i);
        o !== a ? t = n = "unstable" : (n = o,
            FI(i, s),
            t = jl(i))
    }
    return {
        winding: e,
        geometry: t,
        text: n
    }
}
function MI() {
    var e = document.createElement("canvas");
    return e.width = 1,
        e.height = 1,
        [e, e.getContext("2d")]
}
function DI(e, t) {
    return !!(t && e.toDataURL)
}
function NI(e) {
    return e.rect(0, 0, 10, 10),
        e.rect(2, 2, 6, 6),
        !e.isPointInPath(5, 5, "evenodd")
}
function $I(e, t) {
    e.width = 240,
        e.height = 60,
        t.textBaseline = "alphabetic",
        t.fillStyle = "#f60",
        t.fillRect(100, 1, 62, 20),
        t.fillStyle = "#069",
        t.font = '11pt "Times New Roman"';
    var n = "Cwm fjordbank gly ".concat(String.fromCharCode(55357, 56835));
    t.fillText(n, 2, 15),
        t.fillStyle = "rgba(102, 204, 0, 0.2)",
        t.font = "18pt Arial",
        t.fillText(n, 4, 45)
}
function FI(e, t) {
    e.width = 122,
        e.height = 110,
        t.globalCompositeOperation = "multiply";
    for (var n = 0, r = [["#f2f", 40, 40], ["#2ff", 80, 40], ["#ff2", 60, 80]]; n < r.length; n++) {
        var i = r[n]
            , s = i[0]
            , o = i[1]
            , a = i[2];
        t.fillStyle = s,
            t.beginPath(),
            t.arc(o, a, 40, 0, Math.PI * 2, !0),
            t.closePath(),
            t.fill()
    }
    t.fillStyle = "#f9c",
        t.arc(60, 60, 60, 0, Math.PI * 2, !0),
        t.arc(60, 60, 20, 0, Math.PI * 2, !0),
        t.fill("evenodd")
}
function jl(e) {
    return e.toDataURL()
}
function jI() {
    var e = navigator, t = 0, n;
    e.maxTouchPoints !== void 0 ? t = Df(e.maxTouchPoints) : e.msMaxTouchPoints !== void 0 && (t = e.msMaxTouchPoints);
    try {
        document.createEvent("TouchEvent"),
            n = !0
    } catch {
        n = !1
    }
    var r = "ontouchstart"in window;
    return {
        maxTouchPoints: t,
        touchEvent: n,
        touchStart: r
    }
}
function HI() {
    return navigator.oscpu
}
function BI() {
    var e = navigator
        , t = []
        , n = e.language || e.userLanguage || e.browserLanguage || e.systemLanguage;
    if (n !== void 0 && t.push([n]),
        Array.isArray(e.languages))
        Nf() && yI() || t.push(e.languages);
    else if (typeof e.languages == "string") {
        var r = e.languages;
        r && t.push(r.split(","))
    }
    return t
}
function VI() {
    return window.screen.colorDepth
}
function zI() {
    return Wn(mn(navigator.deviceMemory), void 0)
}
function UI() {
    var e = screen
        , t = function(r) {
        return Wn(Df(r), null)
    }
        , n = [t(e.width), t(e.height)];
    return n.sort().reverse(),
        n
}
var WI = 2500, GI = 10, Wo, Hl;
function XI() {
    if (Hl === void 0) {
        var e = function() {
            var t = iu();
            su(t) ? Hl = setTimeout(e, WI) : (Wo = t,
                Hl = void 0)
        };
        e()
    }
}
function KI() {
    var e = this;
    return XI(),
        function() {
            return Qn(e, void 0, void 0, function() {
                var t;
                return er(this, function(n) {
                    switch (n.label) {
                        case 0:
                            return t = iu(),
                                su(t) ? Wo ? [2, qb([], Wo, !0)] : SI() ? [4, _I()] : [3, 2] : [3, 2];
                        case 1:
                            n.sent(),
                                t = iu(),
                                n.label = 2;
                        case 2:
                            return su(t) || (Wo = t),
                                [2, t]
                    }
                })
            })
        }
}
function YI() {
    var e = this
        , t = KI();
    return function() {
        return Qn(e, void 0, void 0, function() {
            var n, r;
            return er(this, function(i) {
                switch (i.label) {
                    case 0:
                        return [4, t()];
                    case 1:
                        return n = i.sent(),
                            r = function(s) {
                                return s === null ? null : Qb(s, GI)
                            }
                            ,
                            [2, [r(n[0]), r(n[1]), r(n[2]), r(n[3])]]
                }
            })
        })
    }
}
function iu() {
    var e = screen;
    return [Wn(mn(e.availTop), null), Wn(mn(e.width) - mn(e.availWidth) - Wn(mn(e.availLeft), 0), null), Wn(mn(e.height) - mn(e.availHeight) - Wn(mn(e.availTop), 0), null), Wn(mn(e.availLeft), null)]
}
function su(e) {
    for (var t = 0; t < 4; ++t)
        if (e[t])
            return !1;
    return !0
}
function qI() {
    return Wn(Df(navigator.hardwareConcurrency), void 0)
}
function JI() {
    var e, t = (e = window.Intl) === null || e === void 0 ? void 0 : e.DateTimeFormat;
    if (t) {
        var n = new t().resolvedOptions().timeZone;
        if (n)
            return n
    }
    var r = -ZI();
    return "UTC".concat(r >= 0 ? "+" : "").concat(Math.abs(r))
}
function ZI() {
    var e = new Date().getFullYear();
    return Math.max(mn(new Date(e,0,1).getTimezoneOffset()), mn(new Date(e,6,1).getTimezoneOffset()))
}
function QI() {
    try {
        return !!window.sessionStorage
    } catch {
        return !0
    }
}
function eM() {
    try {
        return !!window.localStorage
    } catch {
        return !0
    }
}
function tM() {
    if (!(e0() || gI()))
        try {
            return !!window.indexedDB
        } catch {
            return !0
        }
}
function nM() {
    return !!window.openDatabase
}
function rM() {
    return navigator.cpuClass
}
function iM() {
    var e = navigator.platform;
    return e === "MacIntel" && so() && !$f() ? wI() ? "iPad" : "iPhone" : e
}
function sM() {
    return navigator.vendor || ""
}
function oM() {
    for (var e = [], t = 0, n = ["chrome", "safari", "__crWeb", "__gCrWeb", "yandex", "__yb", "__ybro", "__firefox__", "__edgeTrackingPreventionStatistics", "webkit", "oprt", "samsungAr", "ucweb", "UCShellJava", "puffinDevice"]; t < n.length; t++) {
        var r = n[t]
            , i = window[r];
        i && typeof i == "object" && e.push(r)
    }
    return e.sort()
}
function aM() {
    var e = document;
    try {
        e.cookie = "cookietest=1; SameSite=Strict;";
        var t = e.cookie.indexOf("cookietest=") !== -1;
        return e.cookie = "cookietest=1; SameSite=Strict; expires=Thu, 01-Jan-1970 00:00:01 GMT",
            t
    } catch {
        return !1
    }
}
function lM() {
    var e = atob;
    return {
        abpIndo: ["#Iklan-Melayang", "#Kolom-Iklan-728", "#SidebarIklan-wrapper", '[title="ALIENBOLA" i]', e("I0JveC1CYW5uZXItYWRz")],
        abpvn: [".quangcao", "#mobileCatfish", e("LmNsb3NlLWFkcw=="), '[id^="bn_bottom_fixed_"]', "#pmadv"],
        adBlockFinland: [".mainostila", e("LnNwb25zb3JpdA=="), ".ylamainos", e("YVtocmVmKj0iL2NsaWNrdGhyZ2guYXNwPyJd"), e("YVtocmVmXj0iaHR0cHM6Ly9hcHAucmVhZHBlYWsuY29tL2FkcyJd")],
        adBlockPersian: ["#navbar_notice_50", ".kadr", 'TABLE[width="140px"]', "#divAgahi", e("YVtocmVmXj0iaHR0cDovL2cxLnYuZndtcm0ubmV0L2FkLyJd")],
        adBlockWarningRemoval: ["#adblock-honeypot", ".adblocker-root", ".wp_adblock_detect", e("LmhlYWRlci1ibG9ja2VkLWFk"), e("I2FkX2Jsb2NrZXI=")],
        adGuardAnnoyances: [".hs-sosyal", "#cookieconsentdiv", 'div[class^="app_gdpr"]', ".as-oil", '[data-cypress="soft-push-notification-modal"]'],
        adGuardBase: [".BetterJsPopOverlay", e("I2FkXzMwMFgyNTA="), e("I2Jhbm5lcmZsb2F0MjI="), e("I2NhbXBhaWduLWJhbm5lcg=="), e("I0FkLUNvbnRlbnQ=")],
        adGuardChinese: [e("LlppX2FkX2FfSA=="), e("YVtocmVmKj0iLmh0aGJldDM0LmNvbSJd"), "#widget-quan", e("YVtocmVmKj0iLzg0OTkyMDIwLnh5eiJd"), e("YVtocmVmKj0iLjE5NTZobC5jb20vIl0=")],
        adGuardFrench: ["#pavePub", e("LmFkLWRlc2t0b3AtcmVjdGFuZ2xl"), ".mobile_adhesion", ".widgetadv", e("LmFkc19iYW4=")],
        adGuardGerman: ['aside[data-portal-id="leaderboard"]'],
        adGuardJapanese: ["#kauli_yad_1", e("YVtocmVmXj0iaHR0cDovL2FkMi50cmFmZmljZ2F0ZS5uZXQvIl0="), e("Ll9wb3BJbl9pbmZpbml0ZV9hZA=="), e("LmFkZ29vZ2xl"), e("Ll9faXNib29zdFJldHVybkFk")],
        adGuardMobile: [e("YW1wLWF1dG8tYWRz"), e("LmFtcF9hZA=="), 'amp-embed[type="24smi"]', "#mgid_iframe1", e("I2FkX2ludmlld19hcmVh")],
        adGuardRussian: [e("YVtocmVmXj0iaHR0cHM6Ly9hZC5sZXRtZWFkcy5jb20vIl0="), e("LnJlY2xhbWE="), 'div[id^="smi2adblock"]', e("ZGl2W2lkXj0iQWRGb3hfYmFubmVyXyJd"), "#psyduckpockeball"],
        adGuardSocial: [e("YVtocmVmXj0iLy93d3cuc3R1bWJsZXVwb24uY29tL3N1Ym1pdD91cmw9Il0="), e("YVtocmVmXj0iLy90ZWxlZ3JhbS5tZS9zaGFyZS91cmw/Il0="), ".etsy-tweet", "#inlineShare", ".popup-social"],
        adGuardSpanishPortuguese: ["#barraPublicidade", "#Publicidade", "#publiEspecial", "#queTooltip", ".cnt-publi"],
        adGuardTrackingProtection: ["#qoo-counter", e("YVtocmVmXj0iaHR0cDovL2NsaWNrLmhvdGxvZy5ydS8iXQ=="), e("YVtocmVmXj0iaHR0cDovL2hpdGNvdW50ZXIucnUvdG9wL3N0YXQucGhwIl0="), e("YVtocmVmXj0iaHR0cDovL3RvcC5tYWlsLnJ1L2p1bXAiXQ=="), "#top100counter"],
        adGuardTurkish: ["#backkapat", e("I3Jla2xhbWk="), e("YVtocmVmXj0iaHR0cDovL2Fkc2Vydi5vbnRlay5jb20udHIvIl0="), e("YVtocmVmXj0iaHR0cDovL2l6bGVuemkuY29tL2NhbXBhaWduLyJd"), e("YVtocmVmXj0iaHR0cDovL3d3dy5pbnN0YWxsYWRzLm5ldC8iXQ==")],
        bulgarian: [e("dGQjZnJlZW5ldF90YWJsZV9hZHM="), "#ea_intext_div", ".lapni-pop-over", "#xenium_hot_offers"],
        easyList: [".yb-floorad", e("LndpZGdldF9wb19hZHNfd2lkZ2V0"), e("LnRyYWZmaWNqdW5reS1hZA=="), ".textad_headline", e("LnNwb25zb3JlZC10ZXh0LWxpbmtz")],
        easyListChina: [e("LmFwcGd1aWRlLXdyYXBbb25jbGljayo9ImJjZWJvcy5jb20iXQ=="), e("LmZyb250cGFnZUFkdk0="), "#taotaole", "#aafoot.top_box", ".cfa_popup"],
        easyListCookie: [".ezmob-footer", ".cc-CookieWarning", "[data-cookie-number]", e("LmF3LWNvb2tpZS1iYW5uZXI="), ".sygnal24-gdpr-modal-wrap"],
        easyListCzechSlovak: ["#onlajny-stickers", e("I3Jla2xhbW5pLWJveA=="), e("LnJla2xhbWEtbWVnYWJvYXJk"), ".sklik", e("W2lkXj0ic2tsaWtSZWtsYW1hIl0=")],
        easyListDutch: [e("I2FkdmVydGVudGll"), e("I3ZpcEFkbWFya3RCYW5uZXJCbG9jaw=="), ".adstekst", e("YVtocmVmXj0iaHR0cHM6Ly94bHR1YmUubmwvY2xpY2svIl0="), "#semilo-lrectangle"],
        easyListGermany: ["#SSpotIMPopSlider", e("LnNwb25zb3JsaW5rZ3J1ZW4="), e("I3dlcmJ1bmdza3k="), e("I3Jla2xhbWUtcmVjaHRzLW1pdHRl"), e("YVtocmVmXj0iaHR0cHM6Ly9iZDc0Mi5jb20vIl0=")],
        easyListItaly: [e("LmJveF9hZHZfYW5udW5jaQ=="), ".sb-box-pubbliredazionale", e("YVtocmVmXj0iaHR0cDovL2FmZmlsaWF6aW9uaWFkcy5zbmFpLml0LyJd"), e("YVtocmVmXj0iaHR0cHM6Ly9hZHNlcnZlci5odG1sLml0LyJd"), e("YVtocmVmXj0iaHR0cHM6Ly9hZmZpbGlhemlvbmlhZHMuc25haS5pdC8iXQ==")],
        easyListLithuania: [e("LnJla2xhbW9zX3RhcnBhcw=="), e("LnJla2xhbW9zX251b3JvZG9z"), e("aW1nW2FsdD0iUmVrbGFtaW5pcyBza3lkZWxpcyJd"), e("aW1nW2FsdD0iRGVkaWt1b3RpLmx0IHNlcnZlcmlhaSJd"), e("aW1nW2FsdD0iSG9zdGluZ2FzIFNlcnZlcmlhaS5sdCJd")],
        estonian: [e("QVtocmVmKj0iaHR0cDovL3BheTRyZXN1bHRzMjQuZXUiXQ==")],
        fanboyAnnoyances: ["#ac-lre-player", ".navigate-to-top", "#subscribe_popup", ".newsletter_holder", "#back-top"],
        fanboyAntiFacebook: [".util-bar-module-firefly-visible"],
        fanboyEnhancedTrackers: [".open.pushModal", "#issuem-leaky-paywall-articles-zero-remaining-nag", "#sovrn_container", 'div[class$="-hide"][zoompage-fontsize][style="display: block;"]', ".BlockNag__Card"],
        fanboySocial: ["#FollowUs", "#meteored_share", "#social_follow", ".article-sharer", ".community__social-desc"],
        frellwitSwedish: [e("YVtocmVmKj0iY2FzaW5vcHJvLnNlIl1bdGFyZ2V0PSJfYmxhbmsiXQ=="), e("YVtocmVmKj0iZG9rdG9yLXNlLm9uZWxpbmsubWUiXQ=="), "article.category-samarbete", e("ZGl2LmhvbGlkQWRz"), "ul.adsmodern"],
        greekAdBlock: [e("QVtocmVmKj0iYWRtYW4ub3RlbmV0LmdyL2NsaWNrPyJd"), e("QVtocmVmKj0iaHR0cDovL2F4aWFiYW5uZXJzLmV4b2R1cy5nci8iXQ=="), e("QVtocmVmKj0iaHR0cDovL2ludGVyYWN0aXZlLmZvcnRobmV0LmdyL2NsaWNrPyJd"), "DIV.agores300", "TABLE.advright"],
        hungarian: ["#cemp_doboz", ".optimonk-iframe-container", e("LmFkX19tYWlu"), e("W2NsYXNzKj0iR29vZ2xlQWRzIl0="), "#hirdetesek_box"],
        iDontCareAboutCookies: ['.alert-info[data-block-track*="CookieNotice"]', ".ModuleTemplateCookieIndicator", ".o--cookies--container", "#cookies-policy-sticky", "#stickyCookieBar"],
        icelandicAbp: [e("QVtocmVmXj0iL2ZyYW1ld29yay9yZXNvdXJjZXMvZm9ybXMvYWRzLmFzcHgiXQ==")],
        latvian: [e("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMjBweDsgaGVpZ2h0OiA0MHB4OyBvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7Il0="), e("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiA4OHB4OyBoZWlnaHQ6IDMxcHg7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsiXQ==")],
        listKr: [e("YVtocmVmKj0iLy9hZC5wbGFuYnBsdXMuY28ua3IvIl0="), e("I2xpdmVyZUFkV3JhcHBlcg=="), e("YVtocmVmKj0iLy9hZHYuaW1hZHJlcC5jby5rci8iXQ=="), e("aW5zLmZhc3R2aWV3LWFk"), ".revenue_unit_item.dable"],
        listeAr: [e("LmdlbWluaUxCMUFk"), ".right-and-left-sponsers", e("YVtocmVmKj0iLmFmbGFtLmluZm8iXQ=="), e("YVtocmVmKj0iYm9vcmFxLm9yZyJd"), e("YVtocmVmKj0iZHViaXp6bGUuY29tL2FyLz91dG1fc291cmNlPSJd")],
        listeFr: [e("YVtocmVmXj0iaHR0cDovL3Byb21vLnZhZG9yLmNvbS8iXQ=="), e("I2FkY29udGFpbmVyX3JlY2hlcmNoZQ=="), e("YVtocmVmKj0id2Vib3JhbWEuZnIvZmNnaS1iaW4vIl0="), ".site-pub-interstitiel", 'div[id^="crt-"][data-criteo-id]'],
        officialPolish: ["#ceneo-placeholder-ceneo-12", e("W2hyZWZePSJodHRwczovL2FmZi5zZW5kaHViLnBsLyJd"), e("YVtocmVmXj0iaHR0cDovL2Fkdm1hbmFnZXIudGVjaGZ1bi5wbC9yZWRpcmVjdC8iXQ=="), e("YVtocmVmXj0iaHR0cDovL3d3dy50cml6ZXIucGwvP3V0bV9zb3VyY2UiXQ=="), e("ZGl2I3NrYXBpZWNfYWQ=")],
        ro: [e("YVtocmVmXj0iLy9hZmZ0cmsuYWx0ZXgucm8vQ291bnRlci9DbGljayJd"), e("YVtocmVmXj0iaHR0cHM6Ly9ibGFja2ZyaWRheXNhbGVzLnJvL3Ryay9zaG9wLyJd"), e("YVtocmVmXj0iaHR0cHM6Ly9ldmVudC4ycGVyZm9ybWFudC5jb20vZXZlbnRzL2NsaWNrIl0="), e("YVtocmVmXj0iaHR0cHM6Ly9sLnByb2ZpdHNoYXJlLnJvLyJd"), 'a[href^="/url/"]'],
        ruAd: [e("YVtocmVmKj0iLy9mZWJyYXJlLnJ1LyJd"), e("YVtocmVmKj0iLy91dGltZy5ydS8iXQ=="), e("YVtocmVmKj0iOi8vY2hpa2lkaWtpLnJ1Il0="), "#pgeldiz", ".yandex-rtb-block"],
        thaiAds: ["a[href*=macau-uta-popup]", e("I2Fkcy1nb29nbGUtbWlkZGxlX3JlY3RhbmdsZS1ncm91cA=="), e("LmFkczMwMHM="), ".bumq", ".img-kosana"],
        webAnnoyancesUltralist: ["#mod-social-share-2", "#social-tools", e("LmN0cGwtZnVsbGJhbm5lcg=="), ".zergnet-recommend", ".yt.btn-link.btn-md.btn"]
    }
}
function cM(e) {
    var t = e === void 0 ? {} : e
        , n = t.debug;
    return Qn(this, void 0, void 0, function() {
        var r, i, s, o, a, l;
        return er(this, function(c) {
            switch (c.label) {
                case 0:
                    return uM() ? (r = lM(),
                        i = Object.keys(r),
                        s = (l = []).concat.apply(l, i.map(function(u) {
                            return r[u]
                        })),
                        [4, fM(s)]) : [2, void 0];
                case 1:
                    return o = c.sent(),
                    n && dM(r, o),
                        a = i.filter(function(u) {
                            var f = r[u]
                                , d = Pn(f.map(function(h) {
                                return o[h]
                            }));
                            return d > f.length * .6
                        }),
                        a.sort(),
                        [2, a]
            }
        })
    })
}
function uM() {
    return so() || t0()
}
function fM(e) {
    var t;
    return Qn(this, void 0, void 0, function() {
        var n, r, i, s, l, o, a, l;
        return er(this, function(c) {
            switch (c.label) {
                case 0:
                    for (n = document,
                             r = n.createElement("div"),
                             i = new Array(e.length),
                             s = {},
                             qh(r),
                             l = 0; l < e.length; ++l)
                        o = PI(e[l]),
                        o.tagName === "DIALOG" && o.show(),
                            a = n.createElement("div"),
                            qh(a),
                            a.appendChild(o),
                            r.appendChild(a),
                            i[l] = o;
                    c.label = 1;
                case 1:
                    return n.body ? [3, 3] : [4, Us(50)];
                case 2:
                    return c.sent(),
                        [3, 1];
                case 3:
                    n.body.appendChild(r);
                    try {
                        for (l = 0; l < e.length; ++l)
                            i[l].offsetParent || (s[e[l]] = !0)
                    } finally {
                        (t = r.parentNode) === null || t === void 0 || t.removeChild(r)
                    }
                    return [2, s]
            }
        })
    })
}
function qh(e) {
    e.style.setProperty("display", "block", "important")
}
function dM(e, t) {
    for (var n = "DOM blockers debug:\n```", r = 0, i = Object.keys(e); r < i.length; r++) {
        var s = i[r];
        n += `
`.concat(s, ":");
        for (var o = 0, a = e[s]; o < a.length; o++) {
            var l = a[o];
            n += `
  `.concat(t[l] ? "🚫" : "➡️", " ").concat(l)
        }
    }
    console.log("".concat(n, "\n```"))
}
function pM() {
    for (var e = 0, t = ["rec2020", "p3", "srgb"]; e < t.length; e++) {
        var n = t[e];
        if (matchMedia("(color-gamut: ".concat(n, ")")).matches)
            return n
    }
}
function hM() {
    if (Jh("inverted"))
        return !0;
    if (Jh("none"))
        return !1
}
function Jh(e) {
    return matchMedia("(inverted-colors: ".concat(e, ")")).matches
}
function mM() {
    if (Zh("active"))
        return !0;
    if (Zh("none"))
        return !1
}
function Zh(e) {
    return matchMedia("(forced-colors: ".concat(e, ")")).matches
}
var gM = 100;
function vM() {
    if (matchMedia("(min-monochrome: 0)").matches) {
        for (var e = 0; e <= gM; ++e)
            if (matchMedia("(max-monochrome: ".concat(e, ")")).matches)
                return e;
        throw new Error("Too high value")
    }
}
function yM() {
    if (di("no-preference"))
        return 0;
    if (di("high") || di("more"))
        return 1;
    if (di("low") || di("less"))
        return -1;
    if (di("forced"))
        return 10
}
function di(e) {
    return matchMedia("(prefers-contrast: ".concat(e, ")")).matches
}
function bM() {
    if (Qh("reduce"))
        return !0;
    if (Qh("no-preference"))
        return !1
}
function Qh(e) {
    return matchMedia("(prefers-reduced-motion: ".concat(e, ")")).matches
}
function wM() {
    if (em("high"))
        return !0;
    if (em("standard"))
        return !1
}
function em(e) {
    return matchMedia("(dynamic-range: ".concat(e, ")")).matches
}
var Ge = Math
    , It = function() {
    return 0
};
function SM() {
    var e = Ge.acos || It
        , t = Ge.acosh || It
        , n = Ge.asin || It
        , r = Ge.asinh || It
        , i = Ge.atanh || It
        , s = Ge.atan || It
        , o = Ge.sin || It
        , a = Ge.sinh || It
        , l = Ge.cos || It
        , c = Ge.cosh || It
        , u = Ge.tan || It
        , f = Ge.tanh || It
        , d = Ge.exp || It
        , h = Ge.expm1 || It
        , y = Ge.log1p || It
        , p = function(T) {
        return Ge.pow(Ge.PI, T)
    }
        , w = function(T) {
        return Ge.log(T + Ge.sqrt(T * T - 1))
    }
        , m = function(T) {
        return Ge.log(T + Ge.sqrt(T * T + 1))
    }
        , g = function(T) {
        return Ge.log((1 + T) / (1 - T)) / 2
    }
        , b = function(T) {
        return Ge.exp(T) - 1 / Ge.exp(T) / 2
    }
        , v = function(T) {
        return (Ge.exp(T) + 1 / Ge.exp(T)) / 2
    }
        , S = function(T) {
        return Ge.exp(T) - 1
    }
        , _ = function(T) {
        return (Ge.exp(2 * T) - 1) / (Ge.exp(2 * T) + 1)
    }
        , E = function(T) {
        return Ge.log(1 + T)
    };
    return {
        acos: e(.12312423423423424),
        acosh: t(1e308),
        acoshPf: w(1e154),
        asin: n(.12312423423423424),
        asinh: r(1),
        asinhPf: m(1),
        atanh: i(.5),
        atanhPf: g(.5),
        atan: s(.5),
        sin: o(-1e300),
        sinh: a(1),
        sinhPf: b(1),
        cos: l(10.000000000123),
        cosh: c(1),
        coshPf: v(1),
        tan: u(-1e300),
        tanh: f(1),
        tanhPf: _(1),
        exp: d(1),
        expm1: h(1),
        expm1Pf: S(1),
        log1p: y(10),
        log1pPf: E(10),
        powPI: p(-100)
    }
}
var _M = "mmMwWLliI0fiflO&1"
    , Bl = {
    default: [],
    apple: [{
        font: "-apple-system-body"
    }],
    serif: [{
        fontFamily: "serif"
    }],
    sans: [{
        fontFamily: "sans-serif"
    }],
    mono: [{
        fontFamily: "monospace"
    }],
    min: [{
        fontSize: "1px"
    }],
    system: [{
        fontFamily: "system-ui"
    }]
};
function EM() {
    return CM(function(e, t) {
        for (var n = {}, r = {}, i = 0, s = Object.keys(Bl); i < s.length; i++) {
            var o = s[i]
                , a = Bl[o]
                , l = a[0]
                , c = l === void 0 ? {} : l
                , u = a[1]
                , f = u === void 0 ? _M : u
                , d = e.createElement("span");
            d.textContent = f,
                d.style.whiteSpace = "nowrap";
            for (var h = 0, y = Object.keys(c); h < y.length; h++) {
                var p = y[h]
                    , w = c[p];
                w !== void 0 && (d.style[p] = w)
            }
            n[o] = d,
                t.appendChild(e.createElement("br")),
                t.appendChild(d)
        }
        for (var m = 0, g = Object.keys(Bl); m < g.length; m++) {
            var o = g[m];
            r[o] = n[o].getBoundingClientRect().width
        }
        return r
    })
}
function CM(e, t) {
    return t === void 0 && (t = 4e3),
        n0(function(n, r) {
            var i = r.document
                , s = i.body
                , o = s.style;
            o.width = "".concat(t, "px"),
                o.webkitTextSizeAdjust = o.textSizeAdjust = "none",
                Nf() ? s.style.zoom = "".concat(1 / r.devicePixelRatio) : so() && (s.style.zoom = "reset");
            var a = i.createElement("div");
            return a.textContent = qb([], Array(t / 20 << 0), !0).map(function() {
                return "word"
            }).join(" "),
                s.appendChild(a),
                e(i, s)
        }, '<!doctype html><html><head><meta name="viewport" content="width=device-width, initial-scale=1">')
}
function TM() {
    var e, t = document.createElement("canvas"), n = (e = t.getContext("webgl")) !== null && e !== void 0 ? e : t.getContext("experimental-webgl");
    if (n && "getExtension"in n) {
        var r = n.getExtension("WEBGL_debug_renderer_info");
        if (r)
            return {
                vendor: (n.getParameter(r.UNMASKED_VENDOR_WEBGL) || "").toString(),
                renderer: (n.getParameter(r.UNMASKED_RENDERER_WEBGL) || "").toString()
            }
    }
}
function xM() {
    return navigator.pdfViewerEnabled
}
function PM() {
    var e = new Float32Array(1)
        , t = new Uint8Array(e.buffer);
    return e[0] = 1 / 0,
        e[0] = e[0] - e[0],
        t[3]
}
var kM = {
    fonts: OI,
    domBlockers: cM,
    fontPreferences: EM,
    audio: EI,
    screenFrame: YI,
    osCpu: HI,
    languages: BI,
    colorDepth: VI,
    deviceMemory: zI,
    screenResolution: UI,
    hardwareConcurrency: qI,
    timezone: JI,
    sessionStorage: QI,
    localStorage: eM,
    indexedDB: tM,
    openDatabase: nM,
    cpuClass: rM,
    platform: iM,
    plugins: AI,
    canvas: II,
    touchSupport: jI,
    vendor: sM,
    vendorFlavors: oM,
    cookiesEnabled: aM,
    colorGamut: pM,
    invertedColors: hM,
    forcedColors: mM,
    monochrome: vM,
    contrast: yM,
    reducedMotion: bM,
    hdr: wM,
    math: SM,
    videoCard: TM,
    pdfViewerEnabled: xM,
    architecture: PM
};
function RM(e) {
    return mI(kM, e, [])
}
var LM = "$ if upgrade to Pro: https://fpjs.dev/pro";
function OM(e) {
    var t = AM(e)
        , n = IM(t);
    return {
        score: t,
        comment: LM.replace(/\$/g, "".concat(n))
    }
}
function AM(e) {
    if (t0())
        return .4;
    if (so())
        return $f() ? .5 : .3;
    var t = e.platform.value || "";
    return /^Win/.test(t) ? .6 : /^Mac/.test(t) ? .5 : .7
}
function IM(e) {
    return Qb(.99 + .01 * e, 1e-4)
}
function MM(e) {
    for (var t = "", n = 0, r = Object.keys(e).sort(); n < r.length; n++) {
        var i = r[n]
            , s = e[i]
            , o = s.error ? "error" : JSON.stringify(s.value);
        t += "".concat(t ? "|" : "").concat(i.replace(/([:|\\])/g, "\\$1"), ":").concat(o)
    }
    return t
}
function r0(e) {
    return JSON.stringify(e, function(t, n) {
        return n instanceof Error ? cI(n) : n
    }, 2)
}
function i0(e) {
    return lI(MM(e))
}
function DM(e) {
    var t, n = OM(e);
    return {
        get visitorId() {
            return t === void 0 && (t = i0(this.components)),
                t
        },
        set visitorId(r) {
            t = r
        },
        confidence: n,
        components: e,
        version: Jb
    }
}
function NM(e) {
    return e === void 0 && (e = 50),
        aI(e, e * 2)
}
function $M(e, t) {
    var n = Date.now();
    return {
        get: function(r) {
            return Qn(this, void 0, void 0, function() {
                var i, s, o;
                return er(this, function(a) {
                    switch (a.label) {
                        case 0:
                            return i = Date.now(),
                                [4, e()];
                        case 1:
                            return s = a.sent(),
                                o = DM(s),
                            (t || r != null && r.debug) && console.log("Copy the text below to get the debug data:\n\n```\nversion: ".concat(o.version, `
userAgent: `).concat(navigator.userAgent, `
timeBetweenLoadAndGet: `).concat(i - n, `
visitorId: `).concat(o.visitorId, `
components: `).concat(r0(s), "\n```")),
                                [2, o]
                    }
                })
            })
        }
    }
}
function FM() {
    if (!(window.__fpjs_d_m || Math.random() >= .001))
        try {
            var e = new XMLHttpRequest;
            e.open("get", "https://m1.openfpcdn.io/fingerprintjs/v".concat(Jb, "/npm-monitoring"), !0),
                e.send()
        } catch (t) {
            console.error(t)
        }
}
function jM(e) {
    var t = e === void 0 ? {} : e
        , n = t.delayFallback
        , r = t.debug
        , i = t.monitoring
        , s = i === void 0 ? !0 : i;
    return Qn(this, void 0, void 0, function() {
        var o;
        return er(this, function(a) {
            switch (a.label) {
                case 0:
                    return s && FM(),
                        [4, NM(n)];
                case 1:
                    return a.sent(),
                        o = RM({
                            debug: r
                        }),
                        [2, $M(o, r)]
            }
        })
    })
}
var HM = {
    load: jM,
    hashComponents: i0,
    componentsToDebugString: r0
};
const s0 = ({hardwareOnly: e=!1, enableWebgl: t=!1, debug: n=!1}={})=>{
        const {cookieEnabled: r, deviceMemory: i, doNotTrack: s, hardwareConcurrency: o, language: a, languages: l, maxTouchPoints: c, platform: u, userAgent: f, vendor: d} = window.navigator
            , {width: h, height: y, colorDepth: p, pixelDepth: w} = window.screen
            , m = new Date().getTimezoneOffset()
            , g = Intl.DateTimeFormat().resolvedOptions().timeZone
            , b = "ontouchstart"in window
            , v = window.devicePixelRatio
            , S = BM(n)
            , _ = t ? VM(n) : void 0
            , E = t ? zM() : void 0
            , T = JSON.stringify(e ? {
            canvas: S,
            colorDepth: p,
            deviceMemory: i,
            devicePixelRatio: v,
            hardwareConcurrency: o,
            height: y,
            maxTouchPoints: c,
            pixelDepth: w,
            platform: u,
            touchSupport: b,
            webgl: _,
            webglInfo: E,
            width: h
        } : {
            canvas: S,
            colorDepth: p,
            cookieEnabled: r,
            deviceMemory: i,
            devicePixelRatio: v,
            doNotTrack: s,
            hardwareConcurrency: o,
            height: y,
            language: a,
            languages: l,
            maxTouchPoints: c,
            pixelDepth: w,
            platform: u,
            timezone: g,
            timezoneOffset: m,
            touchSupport: b,
            userAgent: f,
            vendor: d,
            webgl: _,
            webglInfo: E,
            width: h
        })
            , P = JSON.stringify(T, null, 4);
        return n && console.log("fingerprint data", P),
            Ff(P)
    }
    , BM = e=>{
        try {
            const t = document.createElement("canvas")
                , n = t.getContext("2d")
                , r = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`~1!2@3#4$5%6^7&8*9(0)-_=+[{]}|;:',<.>/?";
            n.textBaseline = "top",
                n.font = "14px 'Arial'",
                n.textBaseline = "alphabetic",
                n.fillStyle = "#f60",
                n.fillRect(125, 1, 62, 20),
                n.fillStyle = "#069",
                n.fillText(r, 2, 15),
                n.fillStyle = "rgba(102, 204, 0, 0.7)",
                n.fillText(r, 4, 17);
            const i = t.toDataURL();
            return e ? document.body.appendChild(t) : n.clearRect(0, 0, t.width, t.height),
                Ff(i)
        } catch {
            return null
        }
    }
    , VM = e=>{
        try {
            const t = document.createElement("canvas")
                , n = t.getContext("webgl");
            t.width = 256,
                t.height = 128;
            const r = "attribute vec2 attrVertex;varying vec2 varyinTexCoordinate;uniform vec2 uniformOffset;void main(){varyinTexCoordinate=attrVertex+uniformOffset;gl_Position=vec4(attrVertex,0,1);}"
                , i = "precision mediump float;varying vec2 varyinTexCoordinate;void main() {gl_FragColor=vec4(varyinTexCoordinate,0,1);}"
                , s = n.createBuffer();
            n.bindBuffer(n.ARRAY_BUFFER, s);
            const o = new Float32Array([-.2, -.9, 0, .4, -.26, 0, 0, .7321, 0]);
            n.bufferData(n.ARRAY_BUFFER, o, n.STATIC_DRAW),
                s.itemSize = 3,
                s.numItems = 3;
            const a = n.createProgram()
                , l = n.createShader(n.VERTEX_SHADER);
            n.shaderSource(l, r),
                n.compileShader(l);
            const c = n.createShader(n.FRAGMENT_SHADER);
            n.shaderSource(c, i),
                n.compileShader(c),
                n.attachShader(a, l),
                n.attachShader(a, c),
                n.linkProgram(a),
                n.useProgram(a),
                a.vertexPosAttrib = n.getAttribLocation(a, "attrVertex"),
                a.offsetUniform = n.getUniformLocation(a, "uniformOffset"),
                n.enableVertexAttribArray(a.vertexPosArray),
                n.vertexAttribPointer(a.vertexPosAttrib, s.itemSize, n.FLOAT, !1, 0, 0),
                n.uniform2f(a.offsetUniform, 1, 1),
                n.drawArrays(n.TRIANGLE_STRIP, 0, s.numItems);
            const u = new Uint8Array(t.width * t.height * 4);
            n.readPixels(0, 0, t.width, t.height, n.RGBA, n.UNSIGNED_BYTE, u);
            const f = JSON.stringify(u).replace(/,?"[0-9]+":/g, "");
            return e ? document.body.appendChild(t) : n.clear(n.COLOR_BUFFER_BIT | n.DEPTH_BUFFER_BIT | n.STENCIL_BUFFER_BIT),
                Ff(f)
        } catch {
            return null
        }
    }
    , zM = ()=>{
        try {
            const e = document.createElement("canvas").getContext("webgl");
            return {
                VERSION: e.getParameter(e.VERSION),
                SHADING_LANGUAGE_VERSION: e.getParameter(e.SHADING_LANGUAGE_VERSION),
                VENDOR: e.getParameter(e.VENDOR),
                SUPORTED_EXTENSIONS: e.getSupportedExtensions()
            }
        } catch {
            return null
        }
    }
    , Ff = e=>{
        const t = e.length & 3
            , n = e.length - t
            , r = 3432918353
            , i = 461845907;
        let s, o, a;
        for (let c = 0; c < n; c++)
            a = e.charCodeAt(c) & 255 | (e.charCodeAt(++c) & 255) << 8 | (e.charCodeAt(++c) & 255) << 16 | (e.charCodeAt(++c) & 255) << 24,
                ++c,
                a = (a & 65535) * r + (((a >>> 16) * r & 65535) << 16) & 4294967295,
                a = a << 15 | a >>> 17,
                a = (a & 65535) * i + (((a >>> 16) * i & 65535) << 16) & 4294967295,
                s ^= a,
                s = s << 13 | s >>> 19,
                o = (s & 65535) * 5 + (((s >>> 16) * 5 & 65535) << 16) & 4294967295,
                s = (o & 65535) + 27492 + (((o >>> 16) + 58964 & 65535) << 16);
        const l = n - 1;
        switch (a = 0,
            t) {
            case 3:
            {
                a ^= (e.charCodeAt(l + 2) & 255) << 16;
                break
            }
            case 2:
            {
                a ^= (e.charCodeAt(l + 1) & 255) << 8;
                break
            }
            case 1:
            {
                a ^= e.charCodeAt(l) & 255;
                break
            }
        }
        return a = (a & 65535) * r + (((a >>> 16) * r & 65535) << 16) & 4294967295,
            a = a << 15 | a >>> 17,
            a = (a & 65535) * i + (((a >>> 16) * i & 65535) << 16) & 4294967295,
            s ^= a,
            s ^= e.length,
            s ^= s >>> 16,
            s = (s & 65535) * 2246822507 + (((s >>> 16) * 2246822507 & 65535) << 16) & 4294967295,
            s ^= s >>> 13,
            s = (s & 65535) * 3266489909 + (((s >>> 16) * 3266489909 & 65535) << 16) & 4294967295,
            s ^= s >>> 16,
        s >>> 0
    }
;
window.getBrowserFingerprint = s0;
var o0 = {
    exports: {}
};
(function(e) {
        (function() {
                var t = "Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45"
                    , S = typeof process == "object" && typeof process.versions == "object" && process.versions.node && !process.browser;
                if (S) {
                    var n = process.versions.node.toString().replace("v", "");
                    t = "Nodejs/" + n + " (NodeOS) AppleWebKit/" + n + " (KHTML, like Gecko) Nodejs/" + n + " Nodejs/" + n
                }
                (function($) {
                        typeof window < "u" || (typeof window > "u" && typeof mi < "u" && (mi.navigator = {
                            userAgent: t,
                            getUserMedia: function() {}
                        },
                            $.window = mi),
                        typeof location > "u" && ($.location = {
                            protocol: "file:",
                            href: "",
                            hash: ""
                        }),
                        typeof screen > "u" && ($.screen = {
                            width: 0,
                            height: 0
                        }))
                    }
                )(typeof mi < "u" ? mi : window);
                var r = window.navigator;
                typeof r < "u" ? (typeof r.webkitGetUserMedia < "u" && (r.getUserMedia = r.webkitGetUserMedia),
                typeof r.mozGetUserMedia < "u" && (r.getUserMedia = r.mozGetUserMedia)) : r = {
                    getUserMedia: function() {},
                    userAgent: t
                };
                var i = !!/Android|webOS|iPhone|iPad|iPod|BB10|BlackBerry|IEMobile|Opera Mini|Mobile|mobile/i.test(r.userAgent || "")
                    , s = r.userAgent.indexOf("Edge") !== -1 && (!!r.msSaveOrOpenBlob || !!r.msSaveBlob)
                    , o = !!window.opera || r.userAgent.indexOf(" OPR/") >= 0
                    , a = r.userAgent.toLowerCase().indexOf("firefox") > -1 && "netscape"in window && / rv:/.test(r.userAgent)
                    , l = /^((?!chrome|android).)*safari/i.test(r.userAgent)
                    , c = !!window.chrome && !o
                    , u = typeof document < "u" && !!document.documentMode && !s;
                function f() {
                    r.appVersion;
                    var $ = r.userAgent, Z = r.appName, te = "" + parseFloat(r.appVersion), pe = parseInt(r.appVersion, 10), oe, me, Me;
                    if (o) {
                        Z = "Opera";
                        try {
                            te = r.userAgent.split("OPR/")[1].split(" ")[0],
                                pe = te.split(".")[0]
                        } catch {
                            te = "0.0.0.0",
                                pe = 0
                        }
                    } else
                        u ? (me = $.indexOf("rv:"),
                            me > 0 ? te = $.substring(me + 3) : (me = $.indexOf("MSIE"),
                                te = $.substring(me + 5)),
                            Z = "IE") : c ? (me = $.indexOf("Chrome"),
                            Z = "Chrome",
                            te = $.substring(me + 7)) : l ? $.indexOf("CriOS") !== -1 ? (me = $.indexOf("CriOS"),
                            Z = "Chrome",
                            te = $.substring(me + 6)) : $.indexOf("FxiOS") !== -1 ? (me = $.indexOf("FxiOS"),
                            Z = "Firefox",
                            te = $.substring(me + 6)) : (me = $.indexOf("Safari"),
                            Z = "Safari",
                            te = $.substring(me + 7),
                        (me = $.indexOf("Version")) !== -1 && (te = $.substring(me + 8)),
                        r.userAgent.indexOf("Version/") !== -1 && (te = r.userAgent.split("Version/")[1].split(" ")[0])) : a ? (me = $.indexOf("Firefox"),
                            Z = "Firefox",
                            te = $.substring(me + 8)) : (oe = $.lastIndexOf(" ") + 1) < (me = $.lastIndexOf("/")) && (Z = $.substring(oe, me),
                            te = $.substring(me + 1),
                        Z.toLowerCase() === Z.toUpperCase() && (Z = r.appName));
                    return s && (Z = "Edge",
                        te = r.userAgent.split("Edge/")[1]),
                    (Me = te.search(/[; \)]/)) !== -1 && (te = te.substring(0, Me)),
                        pe = parseInt("" + te, 10),
                    isNaN(pe) && (te = "" + parseFloat(r.appVersion),
                        pe = parseInt(r.appVersion, 10)),
                        {
                            fullVersion: te,
                            version: pe,
                            name: Z,
                            isPrivateBrowsing: !1
                        }
                }
                function d($, Z) {
                    var te = 0
                        , pe = 50
                        , oe = !1
                        , me = window.setInterval(function() {
                        $() && (window.clearInterval(me),
                            Z(oe)),
                        te++ > pe && (window.clearInterval(me),
                            oe = !0,
                            Z(oe))
                    }, 10)
                }
                function h($) {
                    var Z = $.toLowerCase();
                    if (Z.indexOf("msie") === 0 && Z.indexOf("trident") === 0)
                        return !1;
                    var te = /(?:msie|rv:)\s?([\d\.]+)/.exec(Z);
                    return !!(te && parseInt(te[1], 10) >= 10)
                }
                function y($) {
                    var Z;
                    try {
                        if (window.webkitRequestFileSystem)
                            window.webkitRequestFileSystem(window.TEMPORARY, 1, function() {
                                Z = !1
                            }, function(pe) {
                                Z = !0
                            });
                        else if (window.indexedDB && /Firefox/.test(window.navigator.userAgent)) {
                            var te;
                            try {
                                te = window.indexedDB.open("test"),
                                    te.onerror = function() {
                                        return !0
                                    }
                            } catch {
                                Z = !0
                            }
                            typeof Z > "u" && d(function() {
                                return te.readyState === "done"
                            }, function(oe) {
                                oe || (Z = !te.result)
                            })
                        } else if (h(window.navigator.userAgent)) {
                            Z = !1;
                            try {
                                window.indexedDB || (Z = !0)
                            } catch {
                                Z = !0
                            }
                        } else if (window.localStorage && /Safari/.test(window.navigator.userAgent)) {
                            try {
                                window.localStorage.setItem("test", 1)
                            } catch {
                                Z = !0
                            }
                            typeof Z > "u" && (Z = !1,
                                window.localStorage.removeItem("test"))
                        }
                    } catch {
                        Z = !1
                    }
                    d(function() {
                        return typeof Z < "u"
                    }, function(oe) {
                        $(Z)
                    })
                }
                var p = {
                    Android: function() {
                        return r.userAgent.match(/Android/i)
                    },
                    BlackBerry: function() {
                        return r.userAgent.match(/BlackBerry|BB10/i)
                    },
                    iOS: function() {
                        return r.userAgent.match(/iPhone|iPad|iPod/i)
                    },
                    Opera: function() {
                        return r.userAgent.match(/Opera Mini/i)
                    },
                    Windows: function() {
                        return r.userAgent.match(/IEMobile/i)
                    },
                    any: function() {
                        return p.Android() || p.BlackBerry() || p.iOS() || p.Opera() || p.Windows()
                    },
                    getOsName: function() {
                        var $ = "Unknown OS";
                        return p.Android() && ($ = "Android"),
                        p.BlackBerry() && ($ = "BlackBerry"),
                        p.iOS() && ($ = "iOS"),
                        p.Opera() && ($ = "Opera Mini"),
                        p.Windows() && ($ = "Windows"),
                            $
                    }
                };
                function w() {
                    for (var $ = "-", Z = r.appVersion, te = r.userAgent, pe = $, oe = [{
                        s: "Chrome OS",
                        r: /CrOS/
                    }, {
                        s: "Windows 10",
                        r: /(Windows 10.0|Windows NT 10.0)/
                    }, {
                        s: "Windows 8.1",
                        r: /(Windows 8.1|Windows NT 6.3)/
                    }, {
                        s: "Windows 8",
                        r: /(Windows 8|Windows NT 6.2)/
                    }, {
                        s: "Windows 7",
                        r: /(Windows 7|Windows NT 6.1)/
                    }, {
                        s: "Windows Vista",
                        r: /Windows NT 6.0/
                    }, {
                        s: "Windows Server 2003",
                        r: /Windows NT 5.2/
                    }, {
                        s: "Windows XP",
                        r: /(Windows NT 5.1|Windows XP)/
                    }, {
                        s: "Windows 2000",
                        r: /(Windows NT 5.0|Windows 2000)/
                    }, {
                        s: "Windows ME",
                        r: /(Win 9x 4.90|Windows ME)/
                    }, {
                        s: "Windows 98",
                        r: /(Windows 98|Win98)/
                    }, {
                        s: "Windows 95",
                        r: /(Windows 95|Win95|Windows_95)/
                    }, {
                        s: "Windows NT 4.0",
                        r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/
                    }, {
                        s: "Windows CE",
                        r: /Windows CE/
                    }, {
                        s: "Windows 3.11",
                        r: /Win16/
                    }, {
                        s: "Android",
                        r: /Android/
                    }, {
                        s: "Open BSD",
                        r: /OpenBSD/
                    }, {
                        s: "Sun OS",
                        r: /SunOS/
                    }, {
                        s: "Linux",
                        r: /(Linux|X11)/
                    }, {
                        s: "iOS",
                        r: /(iPhone|iPad|iPod)/
                    }, {
                        s: "Mac OS X",
                        r: /Mac OS X/
                    }, {
                        s: "Mac OS",
                        r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/
                    }, {
                        s: "QNX",
                        r: /QNX/
                    }, {
                        s: "UNIX",
                        r: /UNIX/
                    }, {
                        s: "BeOS",
                        r: /BeOS/
                    }, {
                        s: "OS/2",
                        r: /OS\/2/
                    }, {
                        s: "Search Bot",
                        r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/
                    }], me = 0, Me; Me = oe[me]; me++)
                        if (Me.r.test(te)) {
                            pe = Me.s;
                            break
                        }
                    var Ne = $;
                    switch (/Windows/.test(pe) && (/Windows (.*)/.test(pe) && (Ne = /Windows (.*)/.exec(pe)[1]),
                        pe = "Windows"),
                        pe) {
                        case "Mac OS X":
                            /Mac OS X (10[\.\_\d]+)/.test(te) && (Ne = /Mac OS X (10[\.\_\d]+)/.exec(te)[1]);
                            break;
                        case "Android":
                            /Android ([\.\_\d]+)/.test(te) && (Ne = /Android ([\.\_\d]+)/.exec(te)[1]);
                            break;
                        case "iOS":
                            /OS (\d+)_(\d+)_?(\d+)?/.test(te) && (Ne = /OS (\d+)_(\d+)_?(\d+)?/.exec(Z),
                            Ne && Ne.length > 3 && (Ne = Ne[1] + "." + Ne[2] + "." + (Ne[3] | 0)));
                            break
                    }
                    return {
                        osName: pe,
                        osVersion: Ne
                    }
                }
                var m = "Unknown OS"
                    , g = "Unknown OS Version";
                function b($) {
                    $ = ($ || r.userAgent).toLowerCase();
                    var Z = $.match(/android\s([0-9\.]*)/);
                    return Z ? Z[1] : !1
                }
                var v = w();
                v && v.osName && v.osName != "-" ? (m = v.osName,
                    g = v.osVersion) : p.any() && (m = p.getOsName(),
                m == "Android" && (g = b()));
                var S = typeof process == "object" && typeof process.versions == "object" && process.versions.node;
                m === "Unknown OS" && S && (m = "Nodejs",
                    g = process.versions.node.toString().replace("v", ""));
                var _ = !1
                    , E = !1;
                ["captureStream", "mozCaptureStream", "webkitCaptureStream"].forEach(function($) {
                    typeof document > "u" || typeof document.createElement != "function" || (!_ && $ in document.createElement("canvas") && (_ = !0),
                    !E && $ in document.createElement("video") && (E = !0))
                });
                var T = /^(192\.168\.|169\.254\.|10\.|172\.(1[6-9]|2\d|3[01]))/
                    , P = /([0-9]{1,3}(\.[0-9]{1,3}){3})/
                    , I = /[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7}/;
                function L($, Z) {
                    if (z.isWebRTCSupported) {
                        var te = !0
                            , pe = !0;
                        x(function(oe) {
                            oe ? oe.match(T) ? (te = !1,
                                $("Local: " + oe, te, pe)) : (oe.match(I) && (pe = !1),
                                $("Public: " + oe, te, pe)) : $()
                        }, Z)
                    }
                }
                function x($, Z) {
                    if (typeof document > "u" || typeof document.getElementById != "function")
                        return;
                    var te = {}
                        , pe = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
                    if (!pe) {
                        var oe = document.getElementById("iframe");
                        if (!oe)
                            return;
                        var me = oe.contentWindow;
                        pe = me.RTCPeerConnection || me.mozRTCPeerConnection || me.webkitRTCPeerConnection
                    }
                    if (!pe)
                        return;
                    var Me = null;
                    z.browser === "Chrome" && z.browser.version < 58 && (Me = {
                        optional: [{
                            RtpDataChannels: !0
                        }]
                    });
                    var Ne = {
                        iceServers: [{
                            urls: "stun:stun.l.google.com:19302"
                        }]
                    }
                        , et = new pe(Ne,Me);
                    Z && (et.addStream ? et.addStream(Z) : et.addTrack && Z.getTracks()[0] && et.addTrack(Z.getTracks()[0], Z));
                    function se(De) {
                        if (!De) {
                            $();
                            return
                        }
                        var ze = P.exec(De);
                        if (ze) {
                            var $e = ze[1]
                                , Ue = De.match(T)
                                , kn = !0;
                            te[$e] === void 0 && $($e, Ue, kn),
                                te[$e] = !0
                        }
                    }
                    if (et.onicecandidate = function(De) {
                        De.candidate && De.candidate.candidate ? se(De.candidate.candidate) : se()
                    }
                        ,
                        !Z)
                        try {
                            et.createDataChannel("sctp", {})
                        } catch {}
                    z.isPromisesSupported ? et.createOffer().then(function(De) {
                        et.setLocalDescription(De).then(Ie)
                    }) : et.createOffer(function(De) {
                        et.setLocalDescription(De, Ie, function() {})
                    }, function() {});
                    function Ie() {
                        var De = et.localDescription.sdp.split(`
`);
                        De.forEach(function(ze) {
                            ze && ze.indexOf("a=candidate:") === 0 && se(ze)
                        })
                    }
                }
                var A = []
                    , k = []
                    , O = []
                    , N = [];
                r.mediaDevices && r.mediaDevices.enumerateDevices && (r.enumerateDevices = function($) {
                        var Z = r.mediaDevices.enumerateDevices();
                        Z && Z.then ? r.mediaDevices.enumerateDevices().then($).catch(function() {
                            $([])
                        }) : $([])
                    }
                );
                var D = !1;
                (typeof MediaStreamTrack < "u" && "getSources"in MediaStreamTrack || r.mediaDevices && r.mediaDevices.enumerateDevices) && (D = !0);
                var W = !1
                    , G = !1
                    , le = !1
                    , ge = !1
                    , ye = !1;
                function de($) {
                    if (!D) {
                        $ && $();
                        return
                    }
                    if (!r.enumerateDevices && window.MediaStreamTrack && window.MediaStreamTrack.getSources && (r.enumerateDevices = window.MediaStreamTrack.getSources.bind(window.MediaStreamTrack)),
                    !r.enumerateDevices && r.enumerateDevices && (r.enumerateDevices = r.enumerateDevices.bind(r)),
                        !r.enumerateDevices) {
                        $ && $();
                        return
                    }
                    A = [],
                        k = [],
                        O = [],
                        N = [],
                        W = !1,
                        G = !1,
                        le = !1,
                        ge = !1,
                        ye = !1;
                    var Z = {};
                    r.enumerateDevices(function(te) {
                        A = [],
                            k = [],
                            O = [],
                            N = [],
                            te.forEach(function(pe) {
                                var oe = {};
                                for (var me in pe)
                                    try {
                                        typeof pe[me] != "function" && (oe[me] = pe[me])
                                    } catch {}
                                Z[oe.deviceId + oe.label + oe.kind] || (oe.kind === "audio" && (oe.kind = "audioinput"),
                                oe.kind === "video" && (oe.kind = "videoinput"),
                                oe.deviceId || (oe.deviceId = oe.id),
                                oe.id || (oe.id = oe.deviceId),
                                    oe.label ? (oe.kind === "videoinput" && !ye && (ye = !0),
                                    oe.kind === "audioinput" && !ge && (ge = !0)) : (oe.isCustomLabel = !0,
                                        oe.kind === "videoinput" ? oe.label = "Camera " + (N.length + 1) : oe.kind === "audioinput" ? oe.label = "Microphone " + (k.length + 1) : oe.kind === "audiooutput" ? oe.label = "Speaker " + (O.length + 1) : oe.label = "Please invoke getUserMedia once.",
                                    typeof z < "u" && z.browser.isChrome && z.browser.version >= 46 && !/^(https:|chrome-extension:)$/g.test(location.protocol || "") && typeof document < "u" && typeof document.domain == "string" && document.domain.search && document.domain.search(/localhost|127.0./g) === -1 && (oe.label = "HTTPs is required to get label of this " + oe.kind + " device.")),
                                oe.kind === "audioinput" && (W = !0,
                                k.indexOf(oe) === -1 && k.push(oe)),
                                oe.kind === "audiooutput" && (G = !0,
                                O.indexOf(oe) === -1 && O.push(oe)),
                                oe.kind === "videoinput" && (le = !0,
                                N.indexOf(oe) === -1 && N.push(oe)),
                                    A.push(oe),
                                    Z[oe.deviceId + oe.label + oe.kind] = oe)
                            }),
                        typeof z < "u" && (z.MediaDevices = A,
                            z.hasMicrophone = W,
                            z.hasSpeakers = G,
                            z.hasWebcam = le,
                            z.isWebsiteHasWebcamPermissions = ye,
                            z.isWebsiteHasMicrophonePermissions = ge,
                            z.audioInputDevices = k,
                            z.audioOutputDevices = O,
                            z.videoInputDevices = N),
                        $ && $()
                    })
                }
                var z = window.DetectRTC || {};
                z.browser = f(),
                    y(function($) {
                        z.browser.isPrivateBrowsing = !!$
                    }),
                    z.browser["is" + z.browser.name] = !0,
                    z.osName = m,
                    z.osVersion = g,
                typeof process == "object" && typeof process.versions == "object" && process.versions["node-webkit"];
                var Pe = !1;
                ["RTCPeerConnection", "webkitRTCPeerConnection", "mozRTCPeerConnection", "RTCIceGatherer"].forEach(function($) {
                    Pe || $ in window && (Pe = !0)
                }),
                    z.isWebRTCSupported = Pe,
                    z.isORTCSupported = typeof RTCIceGatherer < "u";
                var _e = !1;
                if ((z.browser.isChrome && z.browser.version >= 35 || z.browser.isFirefox && z.browser.version >= 34 || z.browser.isEdge && z.browser.version >= 17 || z.osName === "Android" && z.browser.isChrome) && (_e = !0),
                (r.getDisplayMedia || r.mediaDevices && r.mediaDevices.getDisplayMedia) && (_e = !0),
                    !/^(https:|chrome-extension:)$/g.test(location.protocol || "")) {
                    var J = typeof document < "u" && typeof document.domain == "string" && document.domain.search && document.domain.search(/localhost|127.0./g) === -1;
                    (J && (z.browser.isChrome || z.browser.isEdge || z.browser.isOpera) || z.browser.isFirefox) && (_e = !1)
                }
                z.isScreenCapturingSupported = _e;
                var ne = {
                    isSupported: !1,
                    isCreateMediaStreamSourceSupported: !1
                };
                ["AudioContext", "webkitAudioContext", "mozAudioContext", "msAudioContext"].forEach(function($) {
                    ne.isSupported || $ in window && (ne.isSupported = !0,
                    window[$] && "createMediaStreamSource"in window[$].prototype && (ne.isCreateMediaStreamSourceSupported = !0))
                }),
                    z.isAudioContextSupported = ne.isSupported,
                    z.isCreateMediaStreamSourceSupported = ne.isCreateMediaStreamSourceSupported;
                var ee = !1;
                z.browser.isChrome && z.browser.version > 31 && (ee = !0),
                    z.isRtpDataChannelsSupported = ee;
                var ce = !1;
                (z.browser.isFirefox && z.browser.version > 28 || z.browser.isChrome && z.browser.version > 25 || z.browser.isOpera && z.browser.version >= 11) && (ce = !0),
                    z.isSctpDataChannelsSupported = ce,
                    z.isMobileDevice = i;
                var Ce = !1;
                (r.getUserMedia || r.mediaDevices && r.mediaDevices.getUserMedia) && (Ce = !0),
                z.browser.isChrome && z.browser.version >= 46 && !/^(https:|chrome-extension:)$/g.test(location.protocol || "") && typeof document < "u" && typeof document.domain == "string" && document.domain.search && document.domain.search(/localhost|127.0./g) === -1 && (Ce = "Requires HTTPs"),
                z.osName === "Nodejs" && (Ce = !1),
                    z.isGetUserMediaSupported = Ce;
                var M = "";
                if (screen.width) {
                    var C = screen.width ? screen.width : ""
                        , R = screen.height ? screen.height : "";
                    M += "" + C + " x " + R
                }
                z.displayResolution = M;
                function F($, Z) {
                    function te(oe, me) {
                        return me == 0 ? oe : te(me, oe % me)
                    }
                    var pe = te($, Z);
                    return $ / pe / (Z / pe)
                }
                z.displayAspectRatio = F(screen.width, screen.height).toFixed(2),
                    z.isCanvasSupportsStreamCapturing = _,
                    z.isVideoSupportsStreamCapturing = E,
                z.browser.name == "Chrome" && z.browser.version >= 53 && (z.isCanvasSupportsStreamCapturing || (z.isCanvasSupportsStreamCapturing = "Requires chrome flag: enable-experimental-web-platform-features"),
                z.isVideoSupportsStreamCapturing || (z.isVideoSupportsStreamCapturing = "Requires chrome flag: enable-experimental-web-platform-features")),
                    z.DetectLocalIPAddress = L,
                    z.isWebSocketsSupported = "WebSocket"in window && window.WebSocket.CLOSING === 2,
                    z.isWebSocketsBlocked = !z.isWebSocketsSupported,
                z.osName === "Nodejs" && (z.isWebSocketsSupported = !0,
                    z.isWebSocketsBlocked = !1),
                    z.checkWebSocketsSupport = function($) {
                        $ = $ || function() {}
                        ;
                        try {
                            var Z, te = new WebSocket("wss://echo.websocket.org:443/");
                            te.onopen = function() {
                                z.isWebSocketsBlocked = !1,
                                    Z = new Date().getTime(),
                                    te.send("ping")
                            }
                                ,
                                te.onmessage = function() {
                                    z.WebsocketLatency = new Date().getTime() - Z + "ms",
                                        $(),
                                        te.close(),
                                        te = null
                                }
                                ,
                                te.onerror = function() {
                                    z.isWebSocketsBlocked = !0,
                                        $()
                                }
                        } catch {
                            z.isWebSocketsBlocked = !0,
                                $()
                        }
                    }
                    ,
                    z.load = function($) {
                        $ = $ || function() {}
                            ,
                            de($)
                    }
                    ,
                    typeof A < "u" ? z.MediaDevices = A : z.MediaDevices = [],
                    z.hasMicrophone = W,
                    z.hasSpeakers = G,
                    z.hasWebcam = le,
                    z.isWebsiteHasWebcamPermissions = ye,
                    z.isWebsiteHasMicrophonePermissions = ge,
                    z.audioInputDevices = k,
                    z.audioOutputDevices = O,
                    z.videoInputDevices = N;
                var V = !1;
                typeof document < "u" && typeof document.createElement == "function" && "setSinkId"in document.createElement("video") && (V = !0),
                    z.isSetSinkIdSupported = V;
                var Y = !1;
                z.browser.isFirefox && typeof mozRTCPeerConnection < "u" ? "getSenders"in mozRTCPeerConnection.prototype && (Y = !0) : z.browser.isChrome && typeof webkitRTCPeerConnection < "u" && "getSenders"in webkitRTCPeerConnection.prototype && (Y = !0),
                    z.isRTPSenderReplaceTracksSupported = Y;
                var re = !1;
                z.browser.isFirefox && z.browser.version > 38 && (re = !0),
                    z.isRemoteStreamProcessingSupported = re;
                var ie = !1;
                typeof MediaStreamTrack < "u" && "applyConstraints"in MediaStreamTrack.prototype && (ie = !0),
                    z.isApplyConstraintsSupported = ie;
                var ae = !1;
                z.browser.isFirefox && z.browser.version >= 43 && (ae = !0),
                    z.isMultiMonitorScreenCapturingSupported = ae,
                    z.isPromisesSupported = "Promise"in window,
                    z.version = "1.4.1",
                typeof z > "u" && (window.DetectRTC = {});
                var Q = window.MediaStream;
                typeof Q > "u" && typeof webkitMediaStream < "u" && (Q = webkitMediaStream),
                    typeof Q < "u" && typeof Q == "function" ? z.MediaStream = Object.keys(Q.prototype) : z.MediaStream = !1,
                    typeof MediaStreamTrack < "u" ? z.MediaStreamTrack = Object.keys(MediaStreamTrack.prototype) : z.MediaStreamTrack = !1;
                var U = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
                typeof U < "u" ? z.RTCPeerConnection = Object.keys(U.prototype) : z.RTCPeerConnection = !1,
                    window.DetectRTC = z,
                    e.exports = z
            }
        )()
    }
)(o0);
var Io = o0.exports
    , ou = {
    exports: {}
};
(function(e, t) {
        (function(n, r) {
                var i = {
                    version: "3.0.0",
                    x86: {},
                    x64: {},
                    inputValidation: !0
                };
                function s(p) {
                    if (!Array.isArray(p) && !ArrayBuffer.isView(p))
                        return !1;
                    for (var w = 0; w < p.length; w++)
                        if (!Number.isInteger(p[w]) || p[w] < 0 || p[w] > 255)
                            return !1;
                    return !0
                }
                function o(p, w) {
                    return (p & 65535) * w + (((p >>> 16) * w & 65535) << 16)
                }
                function a(p, w) {
                    return p << w | p >>> 32 - w
                }
                function l(p) {
                    return p ^= p >>> 16,
                        p = o(p, 2246822507),
                        p ^= p >>> 13,
                        p = o(p, 3266489909),
                        p ^= p >>> 16,
                        p
                }
                function c(p, w) {
                    p = [p[0] >>> 16, p[0] & 65535, p[1] >>> 16, p[1] & 65535],
                        w = [w[0] >>> 16, w[0] & 65535, w[1] >>> 16, w[1] & 65535];
                    var m = [0, 0, 0, 0];
                    return m[3] += p[3] + w[3],
                        m[2] += m[3] >>> 16,
                        m[3] &= 65535,
                        m[2] += p[2] + w[2],
                        m[1] += m[2] >>> 16,
                        m[2] &= 65535,
                        m[1] += p[1] + w[1],
                        m[0] += m[1] >>> 16,
                        m[1] &= 65535,
                        m[0] += p[0] + w[0],
                        m[0] &= 65535,
                        [m[0] << 16 | m[1], m[2] << 16 | m[3]]
                }
                function u(p, w) {
                    p = [p[0] >>> 16, p[0] & 65535, p[1] >>> 16, p[1] & 65535],
                        w = [w[0] >>> 16, w[0] & 65535, w[1] >>> 16, w[1] & 65535];
                    var m = [0, 0, 0, 0];
                    return m[3] += p[3] * w[3],
                        m[2] += m[3] >>> 16,
                        m[3] &= 65535,
                        m[2] += p[2] * w[3],
                        m[1] += m[2] >>> 16,
                        m[2] &= 65535,
                        m[2] += p[3] * w[2],
                        m[1] += m[2] >>> 16,
                        m[2] &= 65535,
                        m[1] += p[1] * w[3],
                        m[0] += m[1] >>> 16,
                        m[1] &= 65535,
                        m[1] += p[2] * w[2],
                        m[0] += m[1] >>> 16,
                        m[1] &= 65535,
                        m[1] += p[3] * w[1],
                        m[0] += m[1] >>> 16,
                        m[1] &= 65535,
                        m[0] += p[0] * w[3] + p[1] * w[2] + p[2] * w[1] + p[3] * w[0],
                        m[0] &= 65535,
                        [m[0] << 16 | m[1], m[2] << 16 | m[3]]
                }
                function f(p, w) {
                    return w %= 64,
                        w === 32 ? [p[1], p[0]] : w < 32 ? [p[0] << w | p[1] >>> 32 - w, p[1] << w | p[0] >>> 32 - w] : (w -= 32,
                            [p[1] << w | p[0] >>> 32 - w, p[0] << w | p[1] >>> 32 - w])
                }
                function d(p, w) {
                    return w %= 64,
                        w === 0 ? p : w < 32 ? [p[0] << w | p[1] >>> 32 - w, p[1] << w] : [p[1] << w - 32, 0]
                }
                function h(p, w) {
                    return [p[0] ^ w[0], p[1] ^ w[1]]
                }
                function y(p) {
                    return p = h(p, [0, p[0] >>> 1]),
                        p = u(p, [4283543511, 3981806797]),
                        p = h(p, [0, p[0] >>> 1]),
                        p = u(p, [3301882366, 444984403]),
                        p = h(p, [0, p[0] >>> 1]),
                        p
                }
                i.x86.hash32 = function(p, w) {
                    if (i.inputValidation && !s(p))
                        return r;
                    w = w || 0;
                    for (var m = p.length % 4, g = p.length - m, b = w, v = 0, S = 3432918353, _ = 461845907, E = 0; E < g; E = E + 4)
                        v = p[E] | p[E + 1] << 8 | p[E + 2] << 16 | p[E + 3] << 24,
                            v = o(v, S),
                            v = a(v, 15),
                            v = o(v, _),
                            b ^= v,
                            b = a(b, 13),
                            b = o(b, 5) + 3864292196;
                    switch (v = 0,
                        m) {
                        case 3:
                            v ^= p[E + 2] << 16;
                        case 2:
                            v ^= p[E + 1] << 8;
                        case 1:
                            v ^= p[E],
                                v = o(v, S),
                                v = a(v, 15),
                                v = o(v, _),
                                b ^= v
                    }
                    return b ^= p.length,
                        b = l(b),
                    b >>> 0
                }
                    ,
                    i.x86.hash128 = function(p, w) {
                        if (i.inputValidation && !s(p))
                            return r;
                        w = w || 0;
                        for (var m = p.length % 16, g = p.length - m, b = w, v = w, S = w, _ = w, E = 0, T = 0, P = 0, I = 0, L = 597399067, x = 2869860233, A = 951274213, k = 2716044179, O = 0; O < g; O = O + 16)
                            E = p[O] | p[O + 1] << 8 | p[O + 2] << 16 | p[O + 3] << 24,
                                T = p[O + 4] | p[O + 5] << 8 | p[O + 6] << 16 | p[O + 7] << 24,
                                P = p[O + 8] | p[O + 9] << 8 | p[O + 10] << 16 | p[O + 11] << 24,
                                I = p[O + 12] | p[O + 13] << 8 | p[O + 14] << 16 | p[O + 15] << 24,
                                E = o(E, L),
                                E = a(E, 15),
                                E = o(E, x),
                                b ^= E,
                                b = a(b, 19),
                                b += v,
                                b = o(b, 5) + 1444728091,
                                T = o(T, x),
                                T = a(T, 16),
                                T = o(T, A),
                                v ^= T,
                                v = a(v, 17),
                                v += S,
                                v = o(v, 5) + 197830471,
                                P = o(P, A),
                                P = a(P, 17),
                                P = o(P, k),
                                S ^= P,
                                S = a(S, 15),
                                S += _,
                                S = o(S, 5) + 2530024501,
                                I = o(I, k),
                                I = a(I, 18),
                                I = o(I, L),
                                _ ^= I,
                                _ = a(_, 13),
                                _ += b,
                                _ = o(_, 5) + 850148119;
                        switch (E = 0,
                            T = 0,
                            P = 0,
                            I = 0,
                            m) {
                            case 15:
                                I ^= p[O + 14] << 16;
                            case 14:
                                I ^= p[O + 13] << 8;
                            case 13:
                                I ^= p[O + 12],
                                    I = o(I, k),
                                    I = a(I, 18),
                                    I = o(I, L),
                                    _ ^= I;
                            case 12:
                                P ^= p[O + 11] << 24;
                            case 11:
                                P ^= p[O + 10] << 16;
                            case 10:
                                P ^= p[O + 9] << 8;
                            case 9:
                                P ^= p[O + 8],
                                    P = o(P, A),
                                    P = a(P, 17),
                                    P = o(P, k),
                                    S ^= P;
                            case 8:
                                T ^= p[O + 7] << 24;
                            case 7:
                                T ^= p[O + 6] << 16;
                            case 6:
                                T ^= p[O + 5] << 8;
                            case 5:
                                T ^= p[O + 4],
                                    T = o(T, x),
                                    T = a(T, 16),
                                    T = o(T, A),
                                    v ^= T;
                            case 4:
                                E ^= p[O + 3] << 24;
                            case 3:
                                E ^= p[O + 2] << 16;
                            case 2:
                                E ^= p[O + 1] << 8;
                            case 1:
                                E ^= p[O],
                                    E = o(E, L),
                                    E = a(E, 15),
                                    E = o(E, x),
                                    b ^= E
                        }
                        return b ^= p.length,
                            v ^= p.length,
                            S ^= p.length,
                            _ ^= p.length,
                            b += v,
                            b += S,
                            b += _,
                            v += b,
                            S += b,
                            _ += b,
                            b = l(b),
                            v = l(v),
                            S = l(S),
                            _ = l(_),
                            b += v,
                            b += S,
                            b += _,
                            v += b,
                            S += b,
                            _ += b,
                        ("00000000" + (b >>> 0).toString(16)).slice(-8) + ("00000000" + (v >>> 0).toString(16)).slice(-8) + ("00000000" + (S >>> 0).toString(16)).slice(-8) + ("00000000" + (_ >>> 0).toString(16)).slice(-8)
                    }
                    ,
                    i.x64.hash128 = function(p, w) {
                        if (i.inputValidation && !s(p))
                            return r;
                        w = w || 0;
                        for (var m = p.length % 16, g = p.length - m, b = [0, w], v = [0, w], S = [0, 0], _ = [0, 0], E = [2277735313, 289559509], T = [1291169091, 658871167], P = 0; P < g; P = P + 16)
                            S = [p[P + 4] | p[P + 5] << 8 | p[P + 6] << 16 | p[P + 7] << 24, p[P] | p[P + 1] << 8 | p[P + 2] << 16 | p[P + 3] << 24],
                                _ = [p[P + 12] | p[P + 13] << 8 | p[P + 14] << 16 | p[P + 15] << 24, p[P + 8] | p[P + 9] << 8 | p[P + 10] << 16 | p[P + 11] << 24],
                                S = u(S, E),
                                S = f(S, 31),
                                S = u(S, T),
                                b = h(b, S),
                                b = f(b, 27),
                                b = c(b, v),
                                b = c(u(b, [0, 5]), [0, 1390208809]),
                                _ = u(_, T),
                                _ = f(_, 33),
                                _ = u(_, E),
                                v = h(v, _),
                                v = f(v, 31),
                                v = c(v, b),
                                v = c(u(v, [0, 5]), [0, 944331445]);
                        switch (S = [0, 0],
                            _ = [0, 0],
                            m) {
                            case 15:
                                _ = h(_, d([0, p[P + 14]], 48));
                            case 14:
                                _ = h(_, d([0, p[P + 13]], 40));
                            case 13:
                                _ = h(_, d([0, p[P + 12]], 32));
                            case 12:
                                _ = h(_, d([0, p[P + 11]], 24));
                            case 11:
                                _ = h(_, d([0, p[P + 10]], 16));
                            case 10:
                                _ = h(_, d([0, p[P + 9]], 8));
                            case 9:
                                _ = h(_, [0, p[P + 8]]),
                                    _ = u(_, T),
                                    _ = f(_, 33),
                                    _ = u(_, E),
                                    v = h(v, _);
                            case 8:
                                S = h(S, d([0, p[P + 7]], 56));
                            case 7:
                                S = h(S, d([0, p[P + 6]], 48));
                            case 6:
                                S = h(S, d([0, p[P + 5]], 40));
                            case 5:
                                S = h(S, d([0, p[P + 4]], 32));
                            case 4:
                                S = h(S, d([0, p[P + 3]], 24));
                            case 3:
                                S = h(S, d([0, p[P + 2]], 16));
                            case 2:
                                S = h(S, d([0, p[P + 1]], 8));
                            case 1:
                                S = h(S, [0, p[P]]),
                                    S = u(S, E),
                                    S = f(S, 31),
                                    S = u(S, T),
                                    b = h(b, S)
                        }
                        return b = h(b, [0, p.length]),
                            v = h(v, [0, p.length]),
                            b = c(b, v),
                            v = c(v, b),
                            b = y(b),
                            v = y(v),
                            b = c(b, v),
                            v = c(v, b),
                        ("00000000" + (b[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (b[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (v[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (v[1] >>> 0).toString(16)).slice(-8)
                    }
                    ,
                e.exports && (t = e.exports = i),
                    t.murmurHash3 = i
            }
        )()
    }
)(ou, ou.exports);
var UM = ou.exports
    , is = UM
    , a0 = void 0
    , WM = function() {
    return new Promise(function(e, t) {
            var n = "Unknown";
            function r(v) {
                e({
                    isPrivate: v,
                    browserName: n
                })
            }
            function i() {
                var v = navigator.userAgent;
                return v.match(/Chrome/) ? navigator.brave !== void 0 ? "Brave" : v.match(/Edg/) ? "Edge" : v.match(/OPR/) ? "Opera" : "Chrome" : "Chromium"
            }
            function s(v) {
                return v === eval.toString().length
            }
            function o() {
                var v = navigator.vendor;
                return v !== void 0 && v.indexOf("Apple") === 0 && s(37)
            }
            function a() {
                var v = navigator.vendor;
                return v !== void 0 && v.indexOf("Google") === 0 && s(33)
            }
            function l() {
                return document.documentElement !== void 0 && document.documentElement.style.MozAppearance !== void 0 && s(37)
            }
            function c() {
                return navigator.msSaveBlob !== void 0 && s(39)
            }
            function u() {
                var v = String(Math.random());
                try {
                    var S = window.indexedDB.open(v, 1);
                    S.onupgradeneeded = function(_) {
                        var E, T, P = (E = _.target) === null || E === void 0 ? void 0 : E.result;
                        try {
                            P.createObjectStore("test", {
                                autoIncrement: !0
                            }).put(new Blob),
                                r(!1)
                        } catch (x) {
                            var I = x;
                            if (x instanceof Error && (I = (T = x.message) !== null && T !== void 0 ? T : x),
                            typeof I != "string")
                                return r(!1);
                            var L = /BlobURLs are not yet supported/.test(I);
                            return r(L)
                        } finally {
                            P.close(),
                                window.indexedDB.deleteDatabase(v)
                        }
                    }
                } catch {
                    return r(!1)
                }
            }
            function f() {
                var v = window.openDatabase
                    , S = window.localStorage;
                try {
                    v(null, null, null, null)
                } catch {
                    return r(!0)
                }
                try {
                    S.setItem("test", "1"),
                        S.removeItem("test")
                } catch {
                    return r(!0)
                }
                return r(!1)
            }
            function d() {
                navigator.maxTouchPoints !== void 0 ? u() : f()
            }
            function h() {
                var v = window;
                return v.performance !== void 0 && v.performance.memory !== void 0 && v.performance.memory.jsHeapSizeLimit !== void 0 ? performance.memory.jsHeapSizeLimit : 1073741824
            }
            function y() {
                navigator.webkitTemporaryStorage.queryUsageAndQuota(function(v, S) {
                    var _ = Math.round(S / 1048576)
                        , E = Math.round(h() / (1024 * 1024)) * 2;
                    r(_ < E)
                }, function(v) {
                    t(new Error("detectIncognito somehow failed to query storage quota: " + v.message))
                })
            }
            function p() {
                var v = window.webkitRequestFileSystem
                    , S = function() {
                    r(!1)
                }
                    , _ = function() {
                    r(!0)
                };
                v(0, 1, S, _)
            }
            function w() {
                self.Promise !== void 0 && self.Promise.allSettled !== void 0 ? y() : p()
            }
            function m() {
                r(navigator.serviceWorker === void 0)
            }
            function g() {
                r(window.indexedDB === void 0)
            }
            function b() {
                o() ? (n = "Safari",
                    d()) : a() ? (n = i(),
                    w()) : l() ? (n = "Firefox",
                    m()) : c() ? (n = "Internet Explorer",
                    g()) : t(new Error("detectIncognito cannot determine the browser"))
            }
            b()
        }
    )
};
a0 = WM;
const l0 = crypto
    , c0 = e=>e instanceof CryptoKey
    , Si = new TextEncoder
    , tm = new TextDecoder;
function GM(...e) {
    const t = e.reduce((i,{length: s})=>i + s, 0)
        , n = new Uint8Array(t);
    let r = 0;
    return e.forEach(i=>{
            n.set(i, r),
                r += i.length
        }
    ),
        n
}
const XM = e=>{
    let t = e;
    typeof t == "string" && (t = Si.encode(t));
    const n = 32768
        , r = [];
    for (let i = 0; i < t.length; i += n)
        r.push(String.fromCharCode.apply(null, t.subarray(i, i + n)));
    return btoa(r.join(""))
}
    , Vl = e=>XM(e).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
class jf extends Error {
    static get code() {
        return "ERR_JOSE_GENERIC"
    }
    constructor(t) {
        var n;
        super(t),
            this.code = "ERR_JOSE_GENERIC",
            this.name = this.constructor.name,
        (n = Error.captureStackTrace) === null || n === void 0 || n.call(Error, this, this.constructor)
    }
}
class u0 extends jf {
    constructor() {
        super(...arguments),
            this.code = "ERR_JOSE_NOT_SUPPORTED"
    }
    static get code() {
        return "ERR_JOSE_NOT_SUPPORTED"
    }
}
class ss extends jf {
    constructor() {
        super(...arguments),
            this.code = "ERR_JWS_INVALID"
    }
    static get code() {
        return "ERR_JWS_INVALID"
    }
}
class KM extends jf {
    constructor() {
        super(...arguments),
            this.code = "ERR_JWT_INVALID"
    }
    static get code() {
        return "ERR_JWT_INVALID"
    }
}
function Vn(e, t="algorithm.name") {
    return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)
}
function Mo(e, t) {
    return e.name === t
}
function zl(e) {
    return parseInt(e.name.slice(4), 10)
}
function YM(e) {
    switch (e) {
        case "ES256":
            return "P-256";
        case "ES384":
            return "P-384";
        case "ES512":
            return "P-521";
        default:
            throw new Error("unreachable")
    }
}
function qM(e, t) {
    if (t.length && !t.some(n=>e.usages.includes(n))) {
        let n = "CryptoKey does not support this operation, its usages must include ";
        if (t.length > 2) {
            const r = t.pop();
            n += `one of ${t.join(", ")}, or ${r}.`
        } else
            t.length === 2 ? n += `one of ${t[0]} or ${t[1]}.` : n += `${t[0]}.`;
        throw new TypeError(n)
    }
}
function JM(e, t, ...n) {
    switch (t) {
        case "HS256":
        case "HS384":
        case "HS512":
        {
            if (!Mo(e.algorithm, "HMAC"))
                throw Vn("HMAC");
            const r = parseInt(t.slice(2), 10);
            if (zl(e.algorithm.hash) !== r)
                throw Vn(`SHA-${r}`, "algorithm.hash");
            break
        }
        case "RS256":
        case "RS384":
        case "RS512":
        {
            if (!Mo(e.algorithm, "RSASSA-PKCS1-v1_5"))
                throw Vn("RSASSA-PKCS1-v1_5");
            const r = parseInt(t.slice(2), 10);
            if (zl(e.algorithm.hash) !== r)
                throw Vn(`SHA-${r}`, "algorithm.hash");
            break
        }
        case "PS256":
        case "PS384":
        case "PS512":
        {
            if (!Mo(e.algorithm, "RSA-PSS"))
                throw Vn("RSA-PSS");
            const r = parseInt(t.slice(2), 10);
            if (zl(e.algorithm.hash) !== r)
                throw Vn(`SHA-${r}`, "algorithm.hash");
            break
        }
        case "EdDSA":
        {
            if (e.algorithm.name !== "Ed25519" && e.algorithm.name !== "Ed448")
                throw Vn("Ed25519 or Ed448");
            break
        }
        case "ES256":
        case "ES384":
        case "ES512":
        {
            if (!Mo(e.algorithm, "ECDSA"))
                throw Vn("ECDSA");
            const r = YM(t);
            if (e.algorithm.namedCurve !== r)
                throw Vn(r, "algorithm.namedCurve");
            break
        }
        default:
            throw new TypeError("CryptoKey does not support this operation")
    }
    qM(e, n)
}
function f0(e, t, ...n) {
    if (n.length > 2) {
        const r = n.pop();
        e += `one of type ${n.join(", ")}, or ${r}.`
    } else
        n.length === 2 ? e += `one of type ${n[0]} or ${n[1]}.` : e += `of type ${n[0]}.`;
    return t == null ? e += ` Received ${t}` : typeof t == "function" && t.name ? e += ` Received function ${t.name}` : typeof t == "object" && t != null && t.constructor && t.constructor.name && (e += ` Received an instance of ${t.constructor.name}`),
        e
}
const nm = (e,...t)=>f0("Key must be ", e, ...t);
function d0(e, t, ...n) {
    return f0(`Key for the ${e} algorithm must be `, t, ...n)
}
const p0 = e=>c0(e)
    , In = ["CryptoKey"]
    , ZM = (...e)=>{
        const t = e.filter(Boolean);
        if (t.length === 0 || t.length === 1)
            return !0;
        let n;
        for (const r of t) {
            const i = Object.keys(r);
            if (!n || n.size === 0) {
                n = new Set(i);
                continue
            }
            for (const s of i) {
                if (n.has(s))
                    return !1;
                n.add(s)
            }
        }
        return !0
    }
;
function QM(e) {
    return typeof e == "object" && e !== null
}
function eD(e) {
    if (!QM(e) || Object.prototype.toString.call(e) !== "[object Object]")
        return !1;
    if (Object.getPrototypeOf(e) === null)
        return !0;
    let t = e;
    for (; Object.getPrototypeOf(t) !== null; )
        t = Object.getPrototypeOf(t);
    return Object.getPrototypeOf(e) === t
}
const tD = (e,t)=>{
        if (e.startsWith("RS") || e.startsWith("PS")) {
            const {modulusLength: n} = t.algorithm;
            if (typeof n != "number" || n < 2048)
                throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)
        }
    }
    , nD = (e,t)=>{
        if (!(t instanceof Uint8Array)) {
            if (!p0(t))
                throw new TypeError(d0(e, t, ...In, "Uint8Array"));
            if (t.type !== "secret")
                throw new TypeError(`${In.join(" or ")} instances for symmetric algorithms must be of type "secret"`)
        }
    }
    , rD = (e,t,n)=>{
        if (!p0(t))
            throw new TypeError(d0(e, t, ...In));
        if (t.type === "secret")
            throw new TypeError(`${In.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
        if (n === "sign" && t.type === "public")
            throw new TypeError(`${In.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
        if (n === "decrypt" && t.type === "public")
            throw new TypeError(`${In.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
        if (t.algorithm && n === "verify" && t.type === "private")
            throw new TypeError(`${In.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
        if (t.algorithm && n === "encrypt" && t.type === "private")
            throw new TypeError(`${In.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)
    }
    , iD = (e,t,n)=>{
        e.startsWith("HS") || e === "dir" || e.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(e) ? nD(e, t) : rD(e, t, n)
    }
;
function sD(e, t, n, r, i) {
    if (i.crit !== void 0 && r.crit === void 0)
        throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');
    if (!r || r.crit === void 0)
        return new Set;
    if (!Array.isArray(r.crit) || r.crit.length === 0 || r.crit.some(o=>typeof o != "string" || o.length === 0))
        throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
    let s;
    n !== void 0 ? s = new Map([...Object.entries(n), ...t.entries()]) : s = t;
    for (const o of r.crit) {
        if (!s.has(o))
            throw new u0(`Extension Header Parameter "${o}" is not recognized`);
        if (i[o] === void 0)
            throw new e(`Extension Header Parameter "${o}" is missing`);
        if (s.get(o) && r[o] === void 0)
            throw new e(`Extension Header Parameter "${o}" MUST be integrity protected`)
    }
    return new Set(r.crit)
}
function oD(e, t) {
    const n = `SHA-${e.slice(-3)}`;
    switch (e) {
        case "HS256":
        case "HS384":
        case "HS512":
            return {
                hash: n,
                name: "HMAC"
            };
        case "PS256":
        case "PS384":
        case "PS512":
            return {
                hash: n,
                name: "RSA-PSS",
                saltLength: e.slice(-3) >> 3
            };
        case "RS256":
        case "RS384":
        case "RS512":
            return {
                hash: n,
                name: "RSASSA-PKCS1-v1_5"
            };
        case "ES256":
        case "ES384":
        case "ES512":
            return {
                hash: n,
                name: "ECDSA",
                namedCurve: t.namedCurve
            };
        case "EdDSA":
            return {
                name: t.name
            };
        default:
            throw new u0(`alg ${e} is not supported either by JOSE or your javascript runtime`)
    }
}
function aD(e, t, n) {
    if (c0(t))
        return JM(t, e, n),
            t;
    if (t instanceof Uint8Array) {
        if (!e.startsWith("HS"))
            throw new TypeError(nm(t, ...In));
        return l0.subtle.importKey("raw", t, {
            hash: `SHA-${e.slice(-3)}`,
            name: "HMAC"
        }, !1, [n])
    }
    throw new TypeError(nm(t, ...In, "Uint8Array"))
}
const Ul = e=>Math.floor(e.getTime() / 1e3)
    , h0 = 60
    , m0 = h0 * 60
    , Hf = m0 * 24
    , lD = Hf * 7
    , cD = Hf * 365.25
    , uD = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i
    , rm = e=>{
        const t = uD.exec(e);
        if (!t)
            throw new TypeError("Invalid time period format");
        const n = parseFloat(t[1]);
        switch (t[2].toLowerCase()) {
            case "sec":
            case "secs":
            case "second":
            case "seconds":
            case "s":
                return Math.round(n);
            case "minute":
            case "minutes":
            case "min":
            case "mins":
            case "m":
                return Math.round(n * h0);
            case "hour":
            case "hours":
            case "hr":
            case "hrs":
            case "h":
                return Math.round(n * m0);
            case "day":
            case "days":
            case "d":
                return Math.round(n * Hf);
            case "week":
            case "weeks":
            case "w":
                return Math.round(n * lD);
            default:
                return Math.round(n * cD)
        }
    }
    , fD = async(e,t,n)=>{
        const r = await aD(e, t, "sign");
        tD(e, r);
        const i = await l0.subtle.sign(oD(e, r.algorithm), r, n);
        return new Uint8Array(i)
    }
;
class dD {
    constructor(t) {
        if (!(t instanceof Uint8Array))
            throw new TypeError("payload must be an instance of Uint8Array");
        this._payload = t
    }
    setProtectedHeader(t) {
        if (this._protectedHeader)
            throw new TypeError("setProtectedHeader can only be called once");
        return this._protectedHeader = t,
            this
    }
    setUnprotectedHeader(t) {
        if (this._unprotectedHeader)
            throw new TypeError("setUnprotectedHeader can only be called once");
        return this._unprotectedHeader = t,
            this
    }
    async sign(t, n) {
        if (!this._protectedHeader && !this._unprotectedHeader)
            throw new ss("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
        if (!ZM(this._protectedHeader, this._unprotectedHeader))
            throw new ss("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
        const r = {
            ...this._protectedHeader,
            ...this._unprotectedHeader
        }
            , i = sD(ss, new Map([["b64", !0]]), n == null ? void 0 : n.crit, this._protectedHeader, r);
        let s = !0;
        if (i.has("b64") && (s = this._protectedHeader.b64,
        typeof s != "boolean"))
            throw new ss('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
        const {alg: o} = r;
        if (typeof o != "string" || !o)
            throw new ss('JWS "alg" (Algorithm) Header Parameter missing or invalid');
        iD(o, t, "sign");
        let a = this._payload;
        s && (a = Si.encode(Vl(a)));
        let l;
        this._protectedHeader ? l = Si.encode(Vl(JSON.stringify(this._protectedHeader))) : l = Si.encode("");
        const c = GM(l, Si.encode("."), a)
            , u = await fD(o, t, c)
            , f = {
            signature: Vl(u),
            payload: ""
        };
        return s && (f.payload = tm.decode(a)),
        this._unprotectedHeader && (f.header = this._unprotectedHeader),
        this._protectedHeader && (f.protected = tm.decode(l)),
            f
    }
}
class pD {
    constructor(t) {
        this._flattened = new dD(t)
    }
    setProtectedHeader(t) {
        return this._flattened.setProtectedHeader(t),
            this
    }
    async sign(t, n) {
        const r = await this._flattened.sign(t, n);
        if (r.payload === void 0)
            throw new TypeError("use the flattened module for creating JWS with b64: false");
        return `${r.protected}.${r.payload}.${r.signature}`
    }
}
class hD {
    constructor(t) {
        if (!eD(t))
            throw new TypeError("JWT Claims Set MUST be an object");
        this._payload = t
    }
    setIssuer(t) {
        return this._payload = {
            ...this._payload,
            iss: t
        },
            this
    }
    setSubject(t) {
        return this._payload = {
            ...this._payload,
            sub: t
        },
            this
    }
    setAudience(t) {
        return this._payload = {
            ...this._payload,
            aud: t
        },
            this
    }
    setJti(t) {
        return this._payload = {
            ...this._payload,
            jti: t
        },
            this
    }
    setNotBefore(t) {
        return typeof t == "number" ? this._payload = {
            ...this._payload,
            nbf: t
        } : this._payload = {
            ...this._payload,
            nbf: Ul(new Date) + rm(t)
        },
            this
    }
    setExpirationTime(t) {
        return typeof t == "number" ? this._payload = {
            ...this._payload,
            exp: t
        } : this._payload = {
            ...this._payload,
            exp: Ul(new Date) + rm(t)
        },
            this
    }
    setIssuedAt(t) {
        return typeof t > "u" ? this._payload = {
            ...this._payload,
            iat: Ul(new Date)
        } : this._payload = {
            ...this._payload,
            iat: t
        },
            this
    }
}
class mD extends hD {
    setProtectedHeader(t) {
        return this._protectedHeader = t,
            this
    }
    async sign(t, n) {
        var r;
        const i = new pD(Si.encode(JSON.stringify(this._payload)));
        if (i.setProtectedHeader(this._protectedHeader),
        Array.isArray((r = this._protectedHeader) === null || r === void 0 ? void 0 : r.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === !1)
            throw new KM("JWTs MUST NOT use unencoded payload");
        return i.sign(t, n)
    }
}
const pi = ti("Device", {
    web: ()=>at(()=>import("./web.3899a00e.js"), [], import.meta.url).then(e=>new e.DeviceWeb)
})
    , Gn = ti("App", {
    web: ()=>at(()=>import("./web.439126a8.js"), [], import.meta.url).then(e=>new e.AppWeb)
})
    , gD = At(()=>{
        const e = X(null)
            , t = fa("visitor-id", {
            watch: !0
        })
            , n = X(null)
            , r = X(null);
        let i = X(null)
            , s = X(null)
            , o = X(null)
            , a = X(null)
            , l = X(null)
            , c = X(null)
            , u = X(null)
            , f = X(null)
            , d = X(null)
            , h = X(!1);
        const y = async()=>{
            var w, m, g, b, v, S, _, E, T, P, I, L, x, A, k;
            try {
                const O = await HM.load();
                i.value = (w = await O.get()) == null ? void 0 : w.visitorId,
                    s.value = s0({
                        enableWebgl: !0
                    }),
                    h.value = (await a0()).isPrivate,
                    await new Promise(de=>Io.load(de));
                let N = await new Promise(de=>Io.DetectLocalIPAddress(de));
                N = (m = /([0-9]{1,3}(\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/.exec(N)) == null ? void 0 : m[1];
                const D = [];
                await new Promise(async de=>{
                        const Pe = ()=>{
                            setTimeout(de, 100)
                        }
                            , _e = new RTCPeerConnection({
                            iceServers: [{
                                urls: "stun:stun.l.google.com:19302"
                            }]
                        });
                        _e.createDataChannel("");
                        const J = await _e.createOffer();
                        await _e.setLocalDescription(J),
                            _e.addEventListener("icecandidate", ne=>{
                                    var ce;
                                    if (!ne || !ne.candidate || !ne.candidate.candidate)
                                        return;
                                    const ee = (ce = /([0-9]{1,3}(\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/.exec(ne.candidate.candidate)) == null ? void 0 : ce[1];
                                    ee && (D.includes(ee) || D.push(ee)),
                                        Pe()
                                }
                            )
                    }
                );
                const W = Io.MediaDevices.map(de=>(de.label || "Default") + "::" + de.kind).join("||");
                f.value = {
                    devices: Io.MediaDevices.map(de=>({
                        deviceId: de.deviceId,
                        label: de.label || "Default",
                        kind: de.kind
                    })),
                    localIp: N
                },
                    o.value = is.x86.hash128(new TextEncoder().encode(W)),
                    a.value = is.x86.hash128(new TextEncoder().encode(JSON.stringify(f.value))),
                    l.value = is.x86.hash128(new TextEncoder().encode([i.value, o.value, a.value].join("::"))),
                    c.value = is.x86.hash128(new TextEncoder().encode([i.value, N, o.value].join("::")));
                try {
                    r.value = await (Gn == null ? void 0 : Gn.getInfo())
                } catch {}
                e.value = (g = await (pi == null ? void 0 : pi.getId())) == null ? void 0 : g.identifier,
                    n.value = await (pi == null ? void 0 : pi.getInfo());
                const G = (i.value || "failed") + "_" + (s.value || "failed")
                    , le = c.value;
                t.value = ((b = n.value) == null ? void 0 : b.platform) !== "web" ? e.value : le || G;
                const ge = {
                    deviceId: e.value,
                    appName: (v = r.value) == null ? void 0 : v.name,
                    appId: (S = r.value) == null ? void 0 : S.id,
                    appBuild: (_ = r.value) == null ? void 0 : _.build,
                    appVersion: (E = r.value) == null ? void 0 : E.version,
                    isVirtual: (T = n.value) == null ? void 0 : T.isVirtual,
                    manufacturer: (P = n.value) == null ? void 0 : P.manufacturer,
                    model: (I = n.value) == null ? void 0 : I.model,
                    operatingSystem: (L = n.value) == null ? void 0 : L.operatingSystem,
                    osVersion: (x = n.value) == null ? void 0 : x.osVersion,
                    platform: (A = n.value) == null ? void 0 : A.platform,
                    webViewVersion: (k = n.value) == null ? void 0 : k.webViewVersion,
                    isInc: h.value
                };
                console.log("deviceId", e.value),
                    console.log("visitorInfo", n.value),
                    console.log("visitorAppInfo", r.value),
                    u.value = is.x86.hash128(new TextEncoder().encode(JSON.stringify(ge)));
                const ye = new TextEncoder().encode(window.navigator.userAgent);
                d.value = await new mD({
                    visitorId: t.value,
                    deviceFingerprint: f.value,
                    fingerprint1: i.value,
                    fingerprint2: s.value,
                    fingerprint3: o.value,
                    fingerprint4: a.value,
                    fingerprint5: l.value,
                    fingerprint6: c.value,
                    fingerprint7: u.value,
                    userAgent: window.navigator.userAgent,
                    ips: D.join(","),
                    localIp: N,
                    publicIp: D[D.length - 1],
                    ...ge
                }).setProtectedHeader({
                    alg: "HS256"
                }).setIssuedAt().setIssuer("urn:rulet:issuer").setAudience("urn:rulet:audience").setExpirationTime("48h").sign(ye)
            } catch (O) {
                console.error(O)
            }
        }
            , p = fe(()=>{
                var w, m, g, b, v, S, _, E, T, P, I;
                return {
                    fingerprint1: i.value,
                    fingerprint2: s.value,
                    fingerprint3: o.value,
                    fingerprint4: a.value,
                    fingerprint5: l.value,
                    fingerprint6: c.value,
                    fingerprint7: u.value,
                    hash: d.value,
                    deviceId: e.value,
                    appName: (w = r.value) == null ? void 0 : w.name,
                    appId: (m = r.value) == null ? void 0 : m.id,
                    appBuild: (g = r.value) == null ? void 0 : g.build,
                    appVersion: (b = r.value) == null ? void 0 : b.version,
                    isVirtual: (v = n.value) == null ? void 0 : v.isVirtual,
                    manufacturer: (S = n.value) == null ? void 0 : S.manufacturer,
                    model: (_ = n.value) == null ? void 0 : _.model,
                    operatingSystem: (E = n.value) == null ? void 0 : E.operatingSystem,
                    osVersion: (T = n.value) == null ? void 0 : T.osVersion,
                    platform: (P = n.value) == null ? void 0 : P.platform,
                    webViewVersion: (I = n.value) == null ? void 0 : I.webViewVersion,
                    isInc: h.value
                }
            }
        );
        return {
            load: y,
            visitorId: t,
            visitorInfo: n,
            visitor: p
        }
    }
)
    , Fn = Object.create(null);
Fn.open = "0";
Fn.close = "1";
Fn.ping = "2";
Fn.pong = "3";
Fn.message = "4";
Fn.upgrade = "5";
Fn.noop = "6";
const Go = Object.create(null);
Object.keys(Fn).forEach(e=>{
        Go[Fn[e]] = e
    }
);
const vD = {
    type: "error",
    data: "parser error"
}
    , yD = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]"
    , bD = typeof ArrayBuffer == "function"
    , wD = e=>typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e) : e && e.buffer instanceof ArrayBuffer
    , g0 = ({type: e, data: t},n,r)=>yD && t instanceof Blob ? n ? r(t) : im(t, r) : bD && (t instanceof ArrayBuffer || wD(t)) ? n ? r(t) : im(new Blob([t]), r) : r(Fn[e] + (t || ""))
    , im = (e,t)=>{
    const n = new FileReader;
    return n.onload = function() {
        const r = n.result.split(",")[1];
        t("b" + (r || ""))
    }
        ,
        n.readAsDataURL(e)
}
    , sm = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    , fs = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let e = 0; e < sm.length; e++)
    fs[sm.charCodeAt(e)] = e;
const SD = e=>{
    let t = e.length * .75, n = e.length, r, i = 0, s, o, a, l;
    e[e.length - 1] === "=" && (t--,
    e[e.length - 2] === "=" && t--);
    const c = new ArrayBuffer(t)
        , u = new Uint8Array(c);
    for (r = 0; r < n; r += 4)
        s = fs[e.charCodeAt(r)],
            o = fs[e.charCodeAt(r + 1)],
            a = fs[e.charCodeAt(r + 2)],
            l = fs[e.charCodeAt(r + 3)],
            u[i++] = s << 2 | o >> 4,
            u[i++] = (o & 15) << 4 | a >> 2,
            u[i++] = (a & 3) << 6 | l & 63;
    return c
}
    , _D = typeof ArrayBuffer == "function"
    , v0 = (e,t)=>{
    if (typeof e != "string")
        return {
            type: "message",
            data: y0(e, t)
        };
    const n = e.charAt(0);
    return n === "b" ? {
        type: "message",
        data: ED(e.substring(1), t)
    } : Go[n] ? e.length > 1 ? {
        type: Go[n],
        data: e.substring(1)
    } : {
        type: Go[n]
    } : vD
}
    , ED = (e,t)=>{
    if (_D) {
        const n = SD(e);
        return y0(n, t)
    } else
        return {
            base64: !0,
            data: e
        }
}
    , y0 = (e,t)=>{
    switch (t) {
        case "blob":
            return e instanceof ArrayBuffer ? new Blob([e]) : e;
        case "arraybuffer":
        default:
            return e
    }
}
    , b0 = String.fromCharCode(30)
    , CD = (e,t)=>{
    const n = e.length
        , r = new Array(n);
    let i = 0;
    e.forEach((s,o)=>{
            g0(s, !1, a=>{
                    r[o] = a,
                    ++i === n && t(r.join(b0))
                }
            )
        }
    )
}
    , TD = (e,t)=>{
    const n = e.split(b0)
        , r = [];
    for (let i = 0; i < n.length; i++) {
        const s = v0(n[i], t);
        if (r.push(s),
        s.type === "error")
            break
    }
    return r
}
    , w0 = 4;
function dt(e) {
    if (e)
        return xD(e)
}
function xD(e) {
    for (var t in dt.prototype)
        e[t] = dt.prototype[t];
    return e
}
dt.prototype.on = dt.prototype.addEventListener = function(e, t) {
    return this._callbacks = this._callbacks || {},
        (this._callbacks["$" + e] = this._callbacks["$" + e] || []).push(t),
        this
}
;
dt.prototype.once = function(e, t) {
    function n() {
        this.off(e, n),
            t.apply(this, arguments)
    }
    return n.fn = t,
        this.on(e, n),
        this
}
;
dt.prototype.off = dt.prototype.removeListener = dt.prototype.removeAllListeners = dt.prototype.removeEventListener = function(e, t) {
    if (this._callbacks = this._callbacks || {},
    arguments.length == 0)
        return this._callbacks = {},
            this;
    var n = this._callbacks["$" + e];
    if (!n)
        return this;
    if (arguments.length == 1)
        return delete this._callbacks["$" + e],
            this;
    for (var r, i = 0; i < n.length; i++)
        if (r = n[i],
        r === t || r.fn === t) {
            n.splice(i, 1);
            break
        }
    return n.length === 0 && delete this._callbacks["$" + e],
        this
}
;
dt.prototype.emit = function(e) {
    this._callbacks = this._callbacks || {};
    for (var t = new Array(arguments.length - 1), n = this._callbacks["$" + e], r = 1; r < arguments.length; r++)
        t[r - 1] = arguments[r];
    if (n) {
        n = n.slice(0);
        for (var r = 0, i = n.length; r < i; ++r)
            n[r].apply(this, t)
    }
    return this
}
;
dt.prototype.emitReserved = dt.prototype.emit;
dt.prototype.listeners = function(e) {
    return this._callbacks = this._callbacks || {},
    this._callbacks["$" + e] || []
}
;
dt.prototype.hasListeners = function(e) {
    return !!this.listeners(e).length
}
;
const ln = (()=>typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")())();
function S0(e, ...t) {
    return t.reduce((n,r)=>(e.hasOwnProperty(r) && (n[r] = e[r]),
        n), {})
}
const PD = ln.setTimeout
    , kD = ln.clearTimeout;
function fl(e, t) {
    t.useNativeTimers ? (e.setTimeoutFn = PD.bind(ln),
        e.clearTimeoutFn = kD.bind(ln)) : (e.setTimeoutFn = ln.setTimeout.bind(ln),
        e.clearTimeoutFn = ln.clearTimeout.bind(ln))
}
const RD = 1.33;
function LD(e) {
    return typeof e == "string" ? OD(e) : Math.ceil((e.byteLength || e.size) * RD)
}
function OD(e) {
    let t = 0
        , n = 0;
    for (let r = 0, i = e.length; r < i; r++)
        t = e.charCodeAt(r),
            t < 128 ? n += 1 : t < 2048 ? n += 2 : t < 55296 || t >= 57344 ? n += 3 : (r++,
                n += 4);
    return n
}
class AD extends Error {
    constructor(t, n, r) {
        super(t),
            this.description = n,
            this.context = r,
            this.type = "TransportError"
    }
}
class _0 extends dt {
    constructor(t) {
        super(),
            this.writable = !1,
            fl(this, t),
            this.opts = t,
            this.query = t.query,
            this.socket = t.socket
    }
    onError(t, n, r) {
        return super.emitReserved("error", new AD(t,n,r)),
            this
    }
    open() {
        return this.readyState = "opening",
            this.doOpen(),
            this
    }
    close() {
        return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(),
            this.onClose()),
            this
    }
    send(t) {
        this.readyState === "open" && this.write(t)
    }
    onOpen() {
        this.readyState = "open",
            this.writable = !0,
            super.emitReserved("open")
    }
    onData(t) {
        const n = v0(t, this.socket.binaryType);
        this.onPacket(n)
    }
    onPacket(t) {
        super.emitReserved("packet", t)
    }
    onClose(t) {
        this.readyState = "closed",
            super.emitReserved("close", t)
    }
    pause(t) {}
}
const E0 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("")
    , au = 64
    , ID = {};
let om = 0, Do = 0, am;
function lm(e) {
    let t = "";
    do
        t = E0[e % au] + t,
            e = Math.floor(e / au);
    while (e > 0);
    return t
}
function C0() {
    const e = lm(+new Date);
    return e !== am ? (om = 0,
        am = e) : e + "." + lm(om++)
}
for (; Do < au; Do++)
    ID[E0[Do]] = Do;
function T0(e) {
    let t = "";
    for (let n in e)
        e.hasOwnProperty(n) && (t.length && (t += "&"),
            t += encodeURIComponent(n) + "=" + encodeURIComponent(e[n]));
    return t
}
function MD(e) {
    let t = {}
        , n = e.split("&");
    for (let r = 0, i = n.length; r < i; r++) {
        let s = n[r].split("=");
        t[decodeURIComponent(s[0])] = decodeURIComponent(s[1])
    }
    return t
}
let x0 = !1;
try {
    x0 = typeof XMLHttpRequest < "u" && "withCredentials"in new XMLHttpRequest
} catch {}
const DD = x0;
function P0(e) {
    const t = e.xdomain;
    try {
        if (typeof XMLHttpRequest < "u" && (!t || DD))
            return new XMLHttpRequest
    } catch {}
    if (!t)
        try {
            return new ln[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP")
        } catch {}
}
function ND() {}
const $D = function() {
    return new P0({
        xdomain: !1
    }).responseType != null
}();
class FD extends _0 {
    constructor(t) {
        if (super(t),
            this.polling = !1,
        typeof location < "u") {
            const r = location.protocol === "https:";
            let i = location.port;
            i || (i = r ? "443" : "80"),
                this.xd = typeof location < "u" && t.hostname !== location.hostname || i !== t.port,
                this.xs = t.secure !== r
        }
        const n = t && t.forceBase64;
        this.supportsBinary = $D && !n
    }
    get name() {
        return "polling"
    }
    doOpen() {
        this.poll()
    }
    pause(t) {
        this.readyState = "pausing";
        const n = ()=>{
                this.readyState = "paused",
                    t()
            }
        ;
        if (this.polling || !this.writable) {
            let r = 0;
            this.polling && (r++,
                this.once("pollComplete", function() {
                    --r || n()
                })),
            this.writable || (r++,
                this.once("drain", function() {
                    --r || n()
                }))
        } else
            n()
    }
    poll() {
        this.polling = !0,
            this.doPoll(),
            this.emitReserved("poll")
    }
    onData(t) {
        const n = r=>{
                if (this.readyState === "opening" && r.type === "open" && this.onOpen(),
                r.type === "close")
                    return this.onClose({
                        description: "transport closed by the server"
                    }),
                        !1;
                this.onPacket(r)
            }
        ;
        TD(t, this.socket.binaryType).forEach(n),
        this.readyState !== "closed" && (this.polling = !1,
            this.emitReserved("pollComplete"),
        this.readyState === "open" && this.poll())
    }
    doClose() {
        const t = ()=>{
                this.write([{
                    type: "close"
                }])
            }
        ;
        this.readyState === "open" ? t() : this.once("open", t)
    }
    write(t) {
        this.writable = !1,
            CD(t, n=>{
                    this.doWrite(n, ()=>{
                            this.writable = !0,
                                this.emitReserved("drain")
                        }
                    )
                }
            )
    }
    uri() {
        let t = this.query || {};
        const n = this.opts.secure ? "https" : "http";
        let r = "";
        this.opts.timestampRequests !== !1 && (t[this.opts.timestampParam] = C0()),
        !this.supportsBinary && !t.sid && (t.b64 = 1),
        this.opts.port && (n === "https" && Number(this.opts.port) !== 443 || n === "http" && Number(this.opts.port) !== 80) && (r = ":" + this.opts.port);
        const i = T0(t)
            , s = this.opts.hostname.indexOf(":") !== -1;
        return n + "://" + (s ? "[" + this.opts.hostname + "]" : this.opts.hostname) + r + this.opts.path + (i.length ? "?" + i : "")
    }
    request(t={}) {
        return Object.assign(t, {
            xd: this.xd,
            xs: this.xs
        }, this.opts),
            new Nn(this.uri(),t)
    }
    doWrite(t, n) {
        const r = this.request({
            method: "POST",
            data: t
        });
        r.on("success", n),
            r.on("error", (i,s)=>{
                    this.onError("xhr post error", i, s)
                }
            )
    }
    doPoll() {
        const t = this.request();
        t.on("data", this.onData.bind(this)),
            t.on("error", (n,r)=>{
                    this.onError("xhr poll error", n, r)
                }
            ),
            this.pollXhr = t
    }
}
class Nn extends dt {
    constructor(t, n) {
        super(),
            fl(this, n),
            this.opts = n,
            this.method = n.method || "GET",
            this.uri = t,
            this.async = n.async !== !1,
            this.data = n.data !== void 0 ? n.data : null,
            this.create()
    }
    create() {
        const t = S0(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        t.xdomain = !!this.opts.xd,
            t.xscheme = !!this.opts.xs;
        const n = this.xhr = new P0(t);
        try {
            n.open(this.method, this.uri, this.async);
            try {
                if (this.opts.extraHeaders) {
                    n.setDisableHeaderCheck && n.setDisableHeaderCheck(!0);
                    for (let r in this.opts.extraHeaders)
                        this.opts.extraHeaders.hasOwnProperty(r) && n.setRequestHeader(r, this.opts.extraHeaders[r])
                }
            } catch {}
            if (this.method === "POST")
                try {
                    n.setRequestHeader("Content-type", "text/plain;charset=UTF-8")
                } catch {}
            try {
                n.setRequestHeader("Accept", "*/*")
            } catch {}
            "withCredentials"in n && (n.withCredentials = this.opts.withCredentials),
            this.opts.requestTimeout && (n.timeout = this.opts.requestTimeout),
                n.onreadystatechange = ()=>{
                    n.readyState === 4 && (n.status === 200 || n.status === 1223 ? this.onLoad() : this.setTimeoutFn(()=>{
                            this.onError(typeof n.status == "number" ? n.status : 0)
                        }
                        , 0))
                }
                ,
                n.send(this.data)
        } catch (r) {
            this.setTimeoutFn(()=>{
                    this.onError(r)
                }
                , 0);
            return
        }
        typeof document < "u" && (this.index = Nn.requestsCount++,
            Nn.requests[this.index] = this)
    }
    onError(t) {
        this.emitReserved("error", t, this.xhr),
            this.cleanup(!0)
    }
    cleanup(t) {
        if (!(typeof this.xhr > "u" || this.xhr === null)) {
            if (this.xhr.onreadystatechange = ND,
                t)
                try {
                    this.xhr.abort()
                } catch {}
            typeof document < "u" && delete Nn.requests[this.index],
                this.xhr = null
        }
    }
    onLoad() {
        const t = this.xhr.responseText;
        t !== null && (this.emitReserved("data", t),
            this.emitReserved("success"),
            this.cleanup())
    }
    abort() {
        this.cleanup()
    }
}
Nn.requestsCount = 0;
Nn.requests = {};
if (typeof document < "u") {
    if (typeof attachEvent == "function")
        attachEvent("onunload", cm);
    else if (typeof addEventListener == "function") {
        const e = "onpagehide"in ln ? "pagehide" : "unload";
        addEventListener(e, cm, !1)
    }
}
function cm() {
    for (let e in Nn.requests)
        Nn.requests.hasOwnProperty(e) && Nn.requests[e].abort()
}
const k0 = (()=>typeof Promise == "function" && typeof Promise.resolve == "function" ? t=>Promise.resolve().then(t) : (t,n)=>n(t, 0))()
    , No = ln.WebSocket || ln.MozWebSocket
    , um = !0
    , jD = "arraybuffer"
    , fm = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class HD extends _0 {
    constructor(t) {
        super(t),
            this.supportsBinary = !t.forceBase64
    }
    get name() {
        return "websocket"
    }
    doOpen() {
        if (!this.check())
            return;
        const t = this.uri()
            , n = this.opts.protocols
            , r = fm ? {} : S0(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
        this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);
        try {
            this.ws = um && !fm ? n ? new No(t,n) : new No(t) : new No(t,n,r)
        } catch (i) {
            return this.emitReserved("error", i)
        }
        this.ws.binaryType = this.socket.binaryType || jD,
            this.addEventListeners()
    }
    addEventListeners() {
        this.ws.onopen = ()=>{
            this.opts.autoUnref && this.ws._socket.unref(),
                this.onOpen()
        }
            ,
            this.ws.onclose = t=>this.onClose({
                description: "websocket connection closed",
                context: t
            }),
            this.ws.onmessage = t=>this.onData(t.data),
            this.ws.onerror = t=>this.onError("websocket error", t)
    }
    write(t) {
        this.writable = !1;
        for (let n = 0; n < t.length; n++) {
            const r = t[n]
                , i = n === t.length - 1;
            g0(r, this.supportsBinary, s=>{
                    const o = {};
                    try {
                        um && this.ws.send(s)
                    } catch {}
                    i && k0(()=>{
                            this.writable = !0,
                                this.emitReserved("drain")
                        }
                        , this.setTimeoutFn)
                }
            )
        }
    }
    doClose() {
        typeof this.ws < "u" && (this.ws.close(),
            this.ws = null)
    }
    uri() {
        let t = this.query || {};
        const n = this.opts.secure ? "wss" : "ws";
        let r = "";
        this.opts.port && (n === "wss" && Number(this.opts.port) !== 443 || n === "ws" && Number(this.opts.port) !== 80) && (r = ":" + this.opts.port),
        this.opts.timestampRequests && (t[this.opts.timestampParam] = C0()),
        this.supportsBinary || (t.b64 = 1);
        const i = T0(t)
            , s = this.opts.hostname.indexOf(":") !== -1;
        return n + "://" + (s ? "[" + this.opts.hostname + "]" : this.opts.hostname) + r + this.opts.path + (i.length ? "?" + i : "")
    }
    check() {
        return !!No
    }
}
const BD = {
    websocket: HD,
    polling: FD
}
    , VD = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    , zD = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
function lu(e) {
    const t = e
        , n = e.indexOf("[")
        , r = e.indexOf("]");
    n != -1 && r != -1 && (e = e.substring(0, n) + e.substring(n, r).replace(/:/g, ";") + e.substring(r, e.length));
    let i = VD.exec(e || "")
        , s = {}
        , o = 14;
    for (; o--; )
        s[zD[o]] = i[o] || "";
    return n != -1 && r != -1 && (s.source = t,
        s.host = s.host.substring(1, s.host.length - 1).replace(/;/g, ":"),
        s.authority = s.authority.replace("[", "").replace("]", "").replace(/;/g, ":"),
        s.ipv6uri = !0),
        s.pathNames = UD(s, s.path),
        s.queryKey = WD(s, s.query),
        s
}
function UD(e, t) {
    const n = /\/{2,9}/g
        , r = t.replace(n, "/").split("/");
    return (t.slice(0, 1) == "/" || t.length === 0) && r.splice(0, 1),
    t.slice(-1) == "/" && r.splice(r.length - 1, 1),
        r
}
function WD(e, t) {
    const n = {};
    return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(r, i, s) {
        i && (n[i] = s)
    }),
        n
}
let R0 = class vi extends dt {
        constructor(t, n={}) {
            super(),
                this.writeBuffer = [],
            t && typeof t == "object" && (n = t,
                t = null),
                t ? (t = lu(t),
                    n.hostname = t.host,
                    n.secure = t.protocol === "https" || t.protocol === "wss",
                    n.port = t.port,
                t.query && (n.query = t.query)) : n.host && (n.hostname = lu(n.host).host),
                fl(this, n),
                this.secure = n.secure != null ? n.secure : typeof location < "u" && location.protocol === "https:",
            n.hostname && !n.port && (n.port = this.secure ? "443" : "80"),
                this.hostname = n.hostname || (typeof location < "u" ? location.hostname : "localhost"),
                this.port = n.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"),
                this.transports = n.transports || ["polling", "websocket"],
                this.writeBuffer = [],
                this.prevBufferLen = 0,
                this.opts = Object.assign({
                    path: "/engine.io",
                    agent: !1,
                    withCredentials: !1,
                    upgrade: !0,
                    timestampParam: "t",
                    rememberUpgrade: !1,
                    addTrailingSlash: !0,
                    rejectUnauthorized: !0,
                    perMessageDeflate: {
                        threshold: 1024
                    },
                    transportOptions: {},
                    closeOnBeforeunload: !0
                }, n),
                this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""),
            typeof this.opts.query == "string" && (this.opts.query = MD(this.opts.query)),
                this.id = null,
                this.upgrades = null,
                this.pingInterval = null,
                this.pingTimeout = null,
                this.pingTimeoutTimer = null,
            typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = ()=>{
                this.transport && (this.transport.removeAllListeners(),
                    this.transport.close())
            }
                ,
                addEventListener("beforeunload", this.beforeunloadEventListener, !1)),
            this.hostname !== "localhost" && (this.offlineEventListener = ()=>{
                this.onClose("transport close", {
                    description: "network connection lost"
                })
            }
                ,
                addEventListener("offline", this.offlineEventListener, !1))),
                this.open()
        }
        createTransport(t) {
            const n = Object.assign({}, this.opts.query);
            n.EIO = w0,
                n.transport = t,
            this.id && (n.sid = this.id);
            const r = Object.assign({}, this.opts.transportOptions[t], this.opts, {
                query: n,
                socket: this,
                hostname: this.hostname,
                secure: this.secure,
                port: this.port
            });
            return new BD[t](r)
        }
        open() {
            let t;
            if (this.opts.rememberUpgrade && vi.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1)
                t = "websocket";
            else if (this.transports.length === 0) {
                this.setTimeoutFn(()=>{
                        this.emitReserved("error", "No transports available")
                    }
                    , 0);
                return
            } else
                t = this.transports[0];
            this.readyState = "opening";
            try {
                t = this.createTransport(t)
            } catch {
                this.transports.shift(),
                    this.open();
                return
            }
            t.open(),
                this.setTransport(t)
        }
        setTransport(t) {
            this.transport && this.transport.removeAllListeners(),
                this.transport = t,
                t.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", n=>this.onClose("transport close", n))
        }
        probe(t) {
            let n = this.createTransport(t)
                , r = !1;
            vi.priorWebsocketSuccess = !1;
            const i = ()=>{
                    r || (n.send([{
                        type: "ping",
                        data: "probe"
                    }]),
                        n.once("packet", f=>{
                                if (!r)
                                    if (f.type === "pong" && f.data === "probe") {
                                        if (this.upgrading = !0,
                                            this.emitReserved("upgrading", n),
                                            !n)
                                            return;
                                        vi.priorWebsocketSuccess = n.name === "websocket",
                                            this.transport.pause(()=>{
                                                    r || this.readyState !== "closed" && (u(),
                                                        this.setTransport(n),
                                                        n.send([{
                                                            type: "upgrade"
                                                        }]),
                                                        this.emitReserved("upgrade", n),
                                                        n = null,
                                                        this.upgrading = !1,
                                                        this.flush())
                                                }
                                            )
                                    } else {
                                        const d = new Error("probe error");
                                        d.transport = n.name,
                                            this.emitReserved("upgradeError", d)
                                    }
                            }
                        ))
                }
            ;
            function s() {
                r || (r = !0,
                    u(),
                    n.close(),
                    n = null)
            }
            const o = f=>{
                    const d = new Error("probe error: " + f);
                    d.transport = n.name,
                        s(),
                        this.emitReserved("upgradeError", d)
                }
            ;
            function a() {
                o("transport closed")
            }
            function l() {
                o("socket closed")
            }
            function c(f) {
                n && f.name !== n.name && s()
            }
            const u = ()=>{
                    n.removeListener("open", i),
                        n.removeListener("error", o),
                        n.removeListener("close", a),
                        this.off("close", l),
                        this.off("upgrading", c)
                }
            ;
            n.once("open", i),
                n.once("error", o),
                n.once("close", a),
                this.once("close", l),
                this.once("upgrading", c),
                n.open()
        }
        onOpen() {
            if (this.readyState = "open",
                vi.priorWebsocketSuccess = this.transport.name === "websocket",
                this.emitReserved("open"),
                this.flush(),
            this.readyState === "open" && this.opts.upgrade) {
                let t = 0;
                const n = this.upgrades.length;
                for (; t < n; t++)
                    this.probe(this.upgrades[t])
            }
        }
        onPacket(t) {
            if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
                switch (this.emitReserved("packet", t),
                    this.emitReserved("heartbeat"),
                    t.type) {
                    case "open":
                        this.onHandshake(JSON.parse(t.data));
                        break;
                    case "ping":
                        this.resetPingTimeout(),
                            this.sendPacket("pong"),
                            this.emitReserved("ping"),
                            this.emitReserved("pong");
                        break;
                    case "error":
                        const n = new Error("server error");
                        n.code = t.data,
                            this.onError(n);
                        break;
                    case "message":
                        this.emitReserved("data", t.data),
                            this.emitReserved("message", t.data);
                        break
                }
        }
        onHandshake(t) {
            this.emitReserved("handshake", t),
                this.id = t.sid,
                this.transport.query.sid = t.sid,
                this.upgrades = this.filterUpgrades(t.upgrades),
                this.pingInterval = t.pingInterval,
                this.pingTimeout = t.pingTimeout,
                this.maxPayload = t.maxPayload,
                this.onOpen(),
            this.readyState !== "closed" && this.resetPingTimeout()
        }
        resetPingTimeout() {
            this.clearTimeoutFn(this.pingTimeoutTimer),
                this.pingTimeoutTimer = this.setTimeoutFn(()=>{
                        this.onClose("ping timeout")
                    }
                    , this.pingInterval + this.pingTimeout),
            this.opts.autoUnref && this.pingTimeoutTimer.unref()
        }
        onDrain() {
            this.writeBuffer.splice(0, this.prevBufferLen),
                this.prevBufferLen = 0,
                this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush()
        }
        flush() {
            if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
                const t = this.getWritablePackets();
                this.transport.send(t),
                    this.prevBufferLen = t.length,
                    this.emitReserved("flush")
            }
        }
        getWritablePackets() {
            if (!(this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
                return this.writeBuffer;
            let n = 1;
            for (let r = 0; r < this.writeBuffer.length; r++) {
                const i = this.writeBuffer[r].data;
                if (i && (n += LD(i)),
                r > 0 && n > this.maxPayload)
                    return this.writeBuffer.slice(0, r);
                n += 2
            }
            return this.writeBuffer
        }
        write(t, n, r) {
            return this.sendPacket("message", t, n, r),
                this
        }
        send(t, n, r) {
            return this.sendPacket("message", t, n, r),
                this
        }
        sendPacket(t, n, r, i) {
            if (typeof n == "function" && (i = n,
                n = void 0),
            typeof r == "function" && (i = r,
                r = null),
            this.readyState === "closing" || this.readyState === "closed")
                return;
            r = r || {},
                r.compress = r.compress !== !1;
            const s = {
                type: t,
                data: n,
                options: r
            };
            this.emitReserved("packetCreate", s),
                this.writeBuffer.push(s),
            i && this.once("flush", i),
                this.flush()
        }
        close() {
            const t = ()=>{
                    this.onClose("forced close"),
                        this.transport.close()
                }
                , n = ()=>{
                    this.off("upgrade", n),
                        this.off("upgradeError", n),
                        t()
                }
                , r = ()=>{
                    this.once("upgrade", n),
                        this.once("upgradeError", n)
                }
            ;
            return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing",
                this.writeBuffer.length ? this.once("drain", ()=>{
                        this.upgrading ? r() : t()
                    }
                ) : this.upgrading ? r() : t()),
                this
        }
        onError(t) {
            vi.priorWebsocketSuccess = !1,
                this.emitReserved("error", t),
                this.onClose("transport error", t)
        }
        onClose(t, n) {
            (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (this.clearTimeoutFn(this.pingTimeoutTimer),
                this.transport.removeAllListeners("close"),
                this.transport.close(),
                this.transport.removeAllListeners(),
            typeof removeEventListener == "function" && (removeEventListener("beforeunload", this.beforeunloadEventListener, !1),
                removeEventListener("offline", this.offlineEventListener, !1)),
                this.readyState = "closed",
                this.id = null,
                this.emitReserved("close", t, n),
                this.writeBuffer = [],
                this.prevBufferLen = 0)
        }
        filterUpgrades(t) {
            const n = [];
            let r = 0;
            const i = t.length;
            for (; r < i; r++)
                ~this.transports.indexOf(t[r]) && n.push(t[r]);
            return n
        }
    }
;
R0.protocol = w0;
function GD(e, t="", n) {
    let r = e;
    n = n || typeof location < "u" && location,
    e == null && (e = n.protocol + "//" + n.host),
    typeof e == "string" && (e.charAt(0) === "/" && (e.charAt(1) === "/" ? e = n.protocol + e : e = n.host + e),
    /^(https?|wss?):\/\//.test(e) || (typeof n < "u" ? e = n.protocol + "//" + e : e = "https://" + e),
        r = lu(e)),
    r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")),
        r.path = r.path || "/";
    const s = r.host.indexOf(":") !== -1 ? "[" + r.host + "]" : r.host;
    return r.id = r.protocol + "://" + s + ":" + r.port + t,
        r.href = r.protocol + "://" + s + (n && n.port === r.port ? "" : ":" + r.port),
        r
}
const XD = typeof ArrayBuffer == "function"
    , KD = e=>typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e) : e.buffer instanceof ArrayBuffer
    , L0 = Object.prototype.toString
    , YD = typeof Blob == "function" || typeof Blob < "u" && L0.call(Blob) === "[object BlobConstructor]"
    , qD = typeof File == "function" || typeof File < "u" && L0.call(File) === "[object FileConstructor]";
function Bf(e) {
    return XD && (e instanceof ArrayBuffer || KD(e)) || YD && e instanceof Blob || qD && e instanceof File
}
function Xo(e, t) {
    if (!e || typeof e != "object")
        return !1;
    if (Array.isArray(e)) {
        for (let n = 0, r = e.length; n < r; n++)
            if (Xo(e[n]))
                return !0;
        return !1
    }
    if (Bf(e))
        return !0;
    if (e.toJSON && typeof e.toJSON == "function" && arguments.length === 1)
        return Xo(e.toJSON(), !0);
    for (const n in e)
        if (Object.prototype.hasOwnProperty.call(e, n) && Xo(e[n]))
            return !0;
    return !1
}
function JD(e) {
    const t = []
        , n = e.data
        , r = e;
    return r.data = cu(n, t),
        r.attachments = t.length,
        {
            packet: r,
            buffers: t
        }
}
function cu(e, t) {
    if (!e)
        return e;
    if (Bf(e)) {
        const n = {
            _placeholder: !0,
            num: t.length
        };
        return t.push(e),
            n
    } else if (Array.isArray(e)) {
        const n = new Array(e.length);
        for (let r = 0; r < e.length; r++)
            n[r] = cu(e[r], t);
        return n
    } else if (typeof e == "object" && !(e instanceof Date)) {
        const n = {};
        for (const r in e)
            Object.prototype.hasOwnProperty.call(e, r) && (n[r] = cu(e[r], t));
        return n
    }
    return e
}
function ZD(e, t) {
    return e.data = uu(e.data, t),
        delete e.attachments,
        e
}
function uu(e, t) {
    if (!e)
        return e;
    if (e && e._placeholder === !0) {
        if (typeof e.num == "number" && e.num >= 0 && e.num < t.length)
            return t[e.num];
        throw new Error("illegal attachments")
    } else if (Array.isArray(e))
        for (let n = 0; n < e.length; n++)
            e[n] = uu(e[n], t);
    else if (typeof e == "object")
        for (const n in e)
            Object.prototype.hasOwnProperty.call(e, n) && (e[n] = uu(e[n], t));
    return e
}
const QD = ["connect", "connect_error", "disconnect", "disconnecting", "newListener", "removeListener"]
    , eN = 5;
var Fe;
(function(e) {
        e[e.CONNECT = 0] = "CONNECT",
            e[e.DISCONNECT = 1] = "DISCONNECT",
            e[e.EVENT = 2] = "EVENT",
            e[e.ACK = 3] = "ACK",
            e[e.CONNECT_ERROR = 4] = "CONNECT_ERROR",
            e[e.BINARY_EVENT = 5] = "BINARY_EVENT",
            e[e.BINARY_ACK = 6] = "BINARY_ACK"
    }
)(Fe || (Fe = {}));
class tN {
    constructor(t) {
        this.replacer = t
    }
    encode(t) {
        return (t.type === Fe.EVENT || t.type === Fe.ACK) && Xo(t) ? this.encodeAsBinary({
            type: t.type === Fe.EVENT ? Fe.BINARY_EVENT : Fe.BINARY_ACK,
            nsp: t.nsp,
            data: t.data,
            id: t.id
        }) : [this.encodeAsString(t)]
    }
    encodeAsString(t) {
        let n = "" + t.type;
        return (t.type === Fe.BINARY_EVENT || t.type === Fe.BINARY_ACK) && (n += t.attachments + "-"),
        t.nsp && t.nsp !== "/" && (n += t.nsp + ","),
        t.id != null && (n += t.id),
        t.data != null && (n += JSON.stringify(t.data, this.replacer)),
            n
    }
    encodeAsBinary(t) {
        const n = JD(t)
            , r = this.encodeAsString(n.packet)
            , i = n.buffers;
        return i.unshift(r),
            i
    }
}
function dm(e) {
    return Object.prototype.toString.call(e) === "[object Object]"
}
class Vf extends dt {
    constructor(t) {
        super(),
            this.reviver = t
    }
    add(t) {
        let n;
        if (typeof t == "string") {
            if (this.reconstructor)
                throw new Error("got plaintext data when reconstructing a packet");
            n = this.decodeString(t);
            const r = n.type === Fe.BINARY_EVENT;
            r || n.type === Fe.BINARY_ACK ? (n.type = r ? Fe.EVENT : Fe.ACK,
                this.reconstructor = new nN(n),
            n.attachments === 0 && super.emitReserved("decoded", n)) : super.emitReserved("decoded", n)
        } else if (Bf(t) || t.base64)
            if (this.reconstructor)
                n = this.reconstructor.takeBinaryData(t),
                n && (this.reconstructor = null,
                    super.emitReserved("decoded", n));
            else
                throw new Error("got binary data when not reconstructing a packet");
        else
            throw new Error("Unknown type: " + t)
    }
    decodeString(t) {
        let n = 0;
        const r = {
            type: Number(t.charAt(0))
        };
        if (Fe[r.type] === void 0)
            throw new Error("unknown packet type " + r.type);
        if (r.type === Fe.BINARY_EVENT || r.type === Fe.BINARY_ACK) {
            const s = n + 1;
            for (; t.charAt(++n) !== "-" && n != t.length; )
                ;
            const o = t.substring(s, n);
            if (o != Number(o) || t.charAt(n) !== "-")
                throw new Error("Illegal attachments");
            r.attachments = Number(o)
        }
        if (t.charAt(n + 1) === "/") {
            const s = n + 1;
            for (; ++n && !(t.charAt(n) === "," || n === t.length); )
                ;
            r.nsp = t.substring(s, n)
        } else
            r.nsp = "/";
        const i = t.charAt(n + 1);
        if (i !== "" && Number(i) == i) {
            const s = n + 1;
            for (; ++n; ) {
                const o = t.charAt(n);
                if (o == null || Number(o) != o) {
                    --n;
                    break
                }
                if (n === t.length)
                    break
            }
            r.id = Number(t.substring(s, n + 1))
        }
        if (t.charAt(++n)) {
            const s = this.tryParse(t.substr(n));
            if (Vf.isPayloadValid(r.type, s))
                r.data = s;
            else
                throw new Error("invalid payload")
        }
        return r
    }
    tryParse(t) {
        try {
            return JSON.parse(t, this.reviver)
        } catch {
            return !1
        }
    }
    static isPayloadValid(t, n) {
        switch (t) {
            case Fe.CONNECT:
                return dm(n);
            case Fe.DISCONNECT:
                return n === void 0;
            case Fe.CONNECT_ERROR:
                return typeof n == "string" || dm(n);
            case Fe.EVENT:
            case Fe.BINARY_EVENT:
                return Array.isArray(n) && (typeof n[0] == "number" || typeof n[0] == "string" && QD.indexOf(n[0]) === -1);
            case Fe.ACK:
            case Fe.BINARY_ACK:
                return Array.isArray(n)
        }
    }
    destroy() {
        this.reconstructor && (this.reconstructor.finishedReconstruction(),
            this.reconstructor = null)
    }
}
class nN {
    constructor(t) {
        this.packet = t,
            this.buffers = [],
            this.reconPack = t
    }
    takeBinaryData(t) {
        if (this.buffers.push(t),
        this.buffers.length === this.reconPack.attachments) {
            const n = ZD(this.reconPack, this.buffers);
            return this.finishedReconstruction(),
                n
        }
        return null
    }
    finishedReconstruction() {
        this.reconPack = null,
            this.buffers = []
    }
}
const rN = Object.freeze(Object.defineProperty({
    __proto__: null,
    Decoder: Vf,
    Encoder: tN,
    get PacketType() {
        return Fe
    },
    protocol: eN
}, Symbol.toStringTag, {
    value: "Module"
}));
function gn(e, t, n) {
    return e.on(t, n),
        function() {
            e.off(t, n)
        }
}
const iN = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    newListener: 1,
    removeListener: 1
});
class O0 extends dt {
    constructor(t, n, r) {
        super(),
            this.connected = !1,
            this.recovered = !1,
            this.receiveBuffer = [],
            this.sendBuffer = [],
            this._queue = [],
            this._queueSeq = 0,
            this.ids = 0,
            this.acks = {},
            this.flags = {},
            this.io = t,
            this.nsp = n,
        r && r.auth && (this.auth = r.auth),
            this._opts = Object.assign({}, r),
        this.io._autoConnect && this.open()
    }
    get disconnected() {
        return !this.connected
    }
    subEvents() {
        if (this.subs)
            return;
        const t = this.io;
        this.subs = [gn(t, "open", this.onopen.bind(this)), gn(t, "packet", this.onpacket.bind(this)), gn(t, "error", this.onerror.bind(this)), gn(t, "close", this.onclose.bind(this))]
    }
    get active() {
        return !!this.subs
    }
    connect() {
        return this.connected ? this : (this.subEvents(),
        this.io._reconnecting || this.io.open(),
        this.io._readyState === "open" && this.onopen(),
            this)
    }
    open() {
        return this.connect()
    }
    send(...t) {
        return t.unshift("message"),
            this.emit.apply(this, t),
            this
    }
    emit(t, ...n) {
        if (iN.hasOwnProperty(t))
            throw new Error('"' + t.toString() + '" is a reserved event name');
        if (n.unshift(t),
        this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
            return this._addToQueue(n),
                this;
        const r = {
            type: Fe.EVENT,
            data: n
        };
        if (r.options = {},
            r.options.compress = this.flags.compress !== !1,
        typeof n[n.length - 1] == "function") {
            const o = this.ids++
                , a = n.pop();
            this._registerAckCallback(o, a),
                r.id = o
        }
        const i = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
        return this.flags.volatile && (!i || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(r),
            this.packet(r)) : this.sendBuffer.push(r)),
            this.flags = {},
            this
    }
    _registerAckCallback(t, n) {
        var r;
        const i = (r = this.flags.timeout) !== null && r !== void 0 ? r : this._opts.ackTimeout;
        if (i === void 0) {
            this.acks[t] = n;
            return
        }
        const s = this.io.setTimeoutFn(()=>{
                delete this.acks[t];
                for (let o = 0; o < this.sendBuffer.length; o++)
                    this.sendBuffer[o].id === t && this.sendBuffer.splice(o, 1);
                n.call(this, new Error("operation has timed out"))
            }
            , i);
        this.acks[t] = (...o)=>{
            this.io.clearTimeoutFn(s),
                n.apply(this, [null, ...o])
        }
    }
    emitWithAck(t, ...n) {
        const r = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;
        return new Promise((i,s)=>{
                n.push((o,a)=>r ? o ? s(o) : i(a) : i(o)),
                    this.emit(t, ...n)
            }
        )
    }
    _addToQueue(t) {
        let n;
        typeof t[t.length - 1] == "function" && (n = t.pop());
        const r = {
            id: this._queueSeq++,
            tryCount: 0,
            pending: !1,
            args: t,
            flags: Object.assign({
                fromQueue: !0
            }, this.flags)
        };
        t.push((i,...s)=>r !== this._queue[0] ? void 0 : (i !== null ? r.tryCount > this._opts.retries && (this._queue.shift(),
        n && n(i)) : (this._queue.shift(),
        n && n(null, ...s)),
            r.pending = !1,
            this._drainQueue())),
            this._queue.push(r),
            this._drainQueue()
    }
    _drainQueue(t=!1) {
        if (!this.connected || this._queue.length === 0)
            return;
        const n = this._queue[0];
        n.pending && !t || (n.pending = !0,
            n.tryCount++,
            this.flags = n.flags,
            this.emit.apply(this, n.args))
    }
    packet(t) {
        t.nsp = this.nsp,
            this.io._packet(t)
    }
    onopen() {
        typeof this.auth == "function" ? this.auth(t=>{
                this._sendConnectPacket(t)
            }
        ) : this._sendConnectPacket(this.auth)
    }
    _sendConnectPacket(t) {
        this.packet({
            type: Fe.CONNECT,
            data: this._pid ? Object.assign({
                pid: this._pid,
                offset: this._lastOffset
            }, t) : t
        })
    }
    onerror(t) {
        this.connected || this.emitReserved("connect_error", t)
    }
    onclose(t, n) {
        this.connected = !1,
            delete this.id,
            this.emitReserved("disconnect", t, n)
    }
    onpacket(t) {
        if (t.nsp === this.nsp)
            switch (t.type) {
                case Fe.CONNECT:
                    t.data && t.data.sid ? this.onconnect(t.data.sid, t.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                    break;
                case Fe.EVENT:
                case Fe.BINARY_EVENT:
                    this.onevent(t);
                    break;
                case Fe.ACK:
                case Fe.BINARY_ACK:
                    this.onack(t);
                    break;
                case Fe.DISCONNECT:
                    this.ondisconnect();
                    break;
                case Fe.CONNECT_ERROR:
                    this.destroy();
                    const r = new Error(t.data.message);
                    r.data = t.data.data,
                        this.emitReserved("connect_error", r);
                    break
            }
    }
    onevent(t) {
        const n = t.data || [];
        t.id != null && n.push(this.ack(t.id)),
            this.connected ? this.emitEvent(n) : this.receiveBuffer.push(Object.freeze(n))
    }
    emitEvent(t) {
        if (this._anyListeners && this._anyListeners.length) {
            const n = this._anyListeners.slice();
            for (const r of n)
                r.apply(this, t)
        }
        super.emit.apply(this, t),
        this._pid && t.length && typeof t[t.length - 1] == "string" && (this._lastOffset = t[t.length - 1])
    }
    ack(t) {
        const n = this;
        let r = !1;
        return function(...i) {
            r || (r = !0,
                n.packet({
                    type: Fe.ACK,
                    id: t,
                    data: i
                }))
        }
    }
    onack(t) {
        const n = this.acks[t.id];
        typeof n == "function" && (n.apply(this, t.data),
            delete this.acks[t.id])
    }
    onconnect(t, n) {
        this.id = t,
            this.recovered = n && this._pid === n,
            this._pid = n,
            this.connected = !0,
            this.emitBuffered(),
            this.emitReserved("connect"),
            this._drainQueue(!0)
    }
    emitBuffered() {
        this.receiveBuffer.forEach(t=>this.emitEvent(t)),
            this.receiveBuffer = [],
            this.sendBuffer.forEach(t=>{
                    this.notifyOutgoingListeners(t),
                        this.packet(t)
                }
            ),
            this.sendBuffer = []
    }
    ondisconnect() {
        this.destroy(),
            this.onclose("io server disconnect")
    }
    destroy() {
        this.subs && (this.subs.forEach(t=>t()),
            this.subs = void 0),
            this.io._destroy(this)
    }
    disconnect() {
        return this.connected && this.packet({
            type: Fe.DISCONNECT
        }),
            this.destroy(),
        this.connected && this.onclose("io client disconnect"),
            this
    }
    close() {
        return this.disconnect()
    }
    compress(t) {
        return this.flags.compress = t,
            this
    }
    get volatile() {
        return this.flags.volatile = !0,
            this
    }
    timeout(t) {
        return this.flags.timeout = t,
            this
    }
    onAny(t) {
        return this._anyListeners = this._anyListeners || [],
            this._anyListeners.push(t),
            this
    }
    prependAny(t) {
        return this._anyListeners = this._anyListeners || [],
            this._anyListeners.unshift(t),
            this
    }
    offAny(t) {
        if (!this._anyListeners)
            return this;
        if (t) {
            const n = this._anyListeners;
            for (let r = 0; r < n.length; r++)
                if (t === n[r])
                    return n.splice(r, 1),
                        this
        } else
            this._anyListeners = [];
        return this
    }
    listenersAny() {
        return this._anyListeners || []
    }
    onAnyOutgoing(t) {
        return this._anyOutgoingListeners = this._anyOutgoingListeners || [],
            this._anyOutgoingListeners.push(t),
            this
    }
    prependAnyOutgoing(t) {
        return this._anyOutgoingListeners = this._anyOutgoingListeners || [],
            this._anyOutgoingListeners.unshift(t),
            this
    }
    offAnyOutgoing(t) {
        if (!this._anyOutgoingListeners)
            return this;
        if (t) {
            const n = this._anyOutgoingListeners;
            for (let r = 0; r < n.length; r++)
                if (t === n[r])
                    return n.splice(r, 1),
                        this
        } else
            this._anyOutgoingListeners = [];
        return this
    }
    listenersAnyOutgoing() {
        return this._anyOutgoingListeners || []
    }
    notifyOutgoingListeners(t) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
            const n = this._anyOutgoingListeners.slice();
            for (const r of n)
                r.apply(this, t.data)
        }
    }
}
function Ki(e) {
    e = e || {},
        this.ms = e.min || 100,
        this.max = e.max || 1e4,
        this.factor = e.factor || 2,
        this.jitter = e.jitter > 0 && e.jitter <= 1 ? e.jitter : 0,
        this.attempts = 0
}
Ki.prototype.duration = function() {
    var e = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
        var t = Math.random()
            , n = Math.floor(t * this.jitter * e);
        e = Math.floor(t * 10) & 1 ? e + n : e - n
    }
    return Math.min(e, this.max) | 0
}
;
Ki.prototype.reset = function() {
    this.attempts = 0
}
;
Ki.prototype.setMin = function(e) {
    this.ms = e
}
;
Ki.prototype.setMax = function(e) {
    this.max = e
}
;
Ki.prototype.setJitter = function(e) {
    this.jitter = e
}
;
class fu extends dt {
    constructor(t, n) {
        var r;
        super(),
            this.nsps = {},
            this.subs = [],
        t && typeof t == "object" && (n = t,
            t = void 0),
            n = n || {},
            n.path = n.path || "/socket.io",
            this.opts = n,
            fl(this, n),
            this.reconnection(n.reconnection !== !1),
            this.reconnectionAttempts(n.reconnectionAttempts || 1 / 0),
            this.reconnectionDelay(n.reconnectionDelay || 1e3),
            this.reconnectionDelayMax(n.reconnectionDelayMax || 5e3),
            this.randomizationFactor((r = n.randomizationFactor) !== null && r !== void 0 ? r : .5),
            this.backoff = new Ki({
                min: this.reconnectionDelay(),
                max: this.reconnectionDelayMax(),
                jitter: this.randomizationFactor()
            }),
            this.timeout(n.timeout == null ? 2e4 : n.timeout),
            this._readyState = "closed",
            this.uri = t;
        const i = n.parser || rN;
        this.encoder = new i.Encoder,
            this.decoder = new i.Decoder,
            this._autoConnect = n.autoConnect !== !1,
        this._autoConnect && this.open()
    }
    reconnection(t) {
        return arguments.length ? (this._reconnection = !!t,
            this) : this._reconnection
    }
    reconnectionAttempts(t) {
        return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t,
            this)
    }
    reconnectionDelay(t) {
        var n;
        return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t,
        (n = this.backoff) === null || n === void 0 || n.setMin(t),
            this)
    }
    randomizationFactor(t) {
        var n;
        return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t,
        (n = this.backoff) === null || n === void 0 || n.setJitter(t),
            this)
    }
    reconnectionDelayMax(t) {
        var n;
        return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t,
        (n = this.backoff) === null || n === void 0 || n.setMax(t),
            this)
    }
    timeout(t) {
        return arguments.length ? (this._timeout = t,
            this) : this._timeout
    }
    maybeReconnectOnOpen() {
        !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect()
    }
    open(t) {
        if (~this._readyState.indexOf("open"))
            return this;
        this.engine = new R0(this.uri,this.opts);
        const n = this.engine
            , r = this;
        this._readyState = "opening",
            this.skipReconnect = !1;
        const i = gn(n, "open", function() {
            r.onopen(),
            t && t()
        })
            , s = gn(n, "error", o=>{
                r.cleanup(),
                    r._readyState = "closed",
                    this.emitReserved("error", o),
                    t ? t(o) : r.maybeReconnectOnOpen()
            }
        );
        if (this._timeout !== !1) {
            const o = this._timeout;
            o === 0 && i();
            const a = this.setTimeoutFn(()=>{
                    i(),
                        n.close(),
                        n.emit("error", new Error("timeout"))
                }
                , o);
            this.opts.autoUnref && a.unref(),
                this.subs.push(function() {
                    clearTimeout(a)
                })
        }
        return this.subs.push(i),
            this.subs.push(s),
            this
    }
    connect(t) {
        return this.open(t)
    }
    onopen() {
        this.cleanup(),
            this._readyState = "open",
            this.emitReserved("open");
        const t = this.engine;
        this.subs.push(gn(t, "ping", this.onping.bind(this)), gn(t, "data", this.ondata.bind(this)), gn(t, "error", this.onerror.bind(this)), gn(t, "close", this.onclose.bind(this)), gn(this.decoder, "decoded", this.ondecoded.bind(this)))
    }
    onping() {
        this.emitReserved("ping")
    }
    ondata(t) {
        try {
            this.decoder.add(t)
        } catch (n) {
            this.onclose("parse error", n)
        }
    }
    ondecoded(t) {
        k0(()=>{
                this.emitReserved("packet", t)
            }
            , this.setTimeoutFn)
    }
    onerror(t) {
        this.emitReserved("error", t)
    }
    socket(t, n) {
        let r = this.nsps[t];
        return r ? this._autoConnect && !r.active && r.connect() : (r = new O0(this,t,n),
            this.nsps[t] = r),
            r
    }
    _destroy(t) {
        const n = Object.keys(this.nsps);
        for (const r of n)
            if (this.nsps[r].active)
                return;
        this._close()
    }
    _packet(t) {
        const n = this.encoder.encode(t);
        for (let r = 0; r < n.length; r++)
            this.engine.write(n[r], t.options)
    }
    cleanup() {
        this.subs.forEach(t=>t()),
            this.subs.length = 0,
            this.decoder.destroy()
    }
    _close() {
        this.skipReconnect = !0,
            this._reconnecting = !1,
            this.onclose("forced close"),
        this.engine && this.engine.close()
    }
    disconnect() {
        return this._close()
    }
    onclose(t, n) {
        this.cleanup(),
            this.backoff.reset(),
            this._readyState = "closed",
            this.emitReserved("close", t, n),
        this._reconnection && !this.skipReconnect && this.reconnect()
    }
    reconnect() {
        if (this._reconnecting || this.skipReconnect)
            return this;
        const t = this;
        if (this.backoff.attempts >= this._reconnectionAttempts)
            this.backoff.reset(),
                this.emitReserved("reconnect_failed"),
                this._reconnecting = !1;
        else {
            const n = this.backoff.duration();
            this._reconnecting = !0;
            const r = this.setTimeoutFn(()=>{
                    t.skipReconnect || (this.emitReserved("reconnect_attempt", t.backoff.attempts),
                    !t.skipReconnect && t.open(i=>{
                            i ? (t._reconnecting = !1,
                                t.reconnect(),
                                this.emitReserved("reconnect_error", i)) : t.onreconnect()
                        }
                    ))
                }
                , n);
            this.opts.autoUnref && r.unref(),
                this.subs.push(function() {
                    clearTimeout(r)
                })
        }
    }
    onreconnect() {
        const t = this.backoff.attempts;
        this._reconnecting = !1,
            this.backoff.reset(),
            this.emitReserved("reconnect", t)
    }
}
const os = {};
function Ko(e, t) {
    typeof e == "object" && (t = e,
        e = void 0),
        t = t || {};
    const n = GD(e, t.path || "/socket.io")
        , r = n.source
        , i = n.id
        , s = n.path
        , o = os[i] && s in os[i].nsps
        , a = t.forceNew || t["force new connection"] || t.multiplex === !1 || o;
    let l;
    return a ? l = new fu(r,t) : (os[i] || (os[i] = new fu(r,t)),
        l = os[i]),
    n.query && !t.query && (t.query = n.queryKey),
        l.socket(n.path, t)
}
Object.assign(Ko, {
    Manager: fu,
    Socket: O0,
    io: Ko,
    connect: Ko
});
function Vt(e, t) {
    const {socketOn: n, socketOff: r} = oo();
    Ve(()=>{
            n(e, t)
        }
    ),
        Kt(()=>{
                r(e, t)
            }
        )
}
function ht(e, ...t) {
    const {socketEmit: n} = oo();
    return n(e, ...t)
}
const oo = At(()=>{
        const e = X()
            , t = fa("session", {
            watch: !0
        })
            , n = fa("visitor-id", {
            watch: !0
        })
            , r = X(!1)
            , i = X(null)
            , s = [];
        function o(f, d) {
            var h;
            s.push({
                fn: d,
                name: f
            }),
            (h = i.value) == null || h.on(f, d)
        }
        function a(f, d) {
            var y;
            const h = s.findIndex(p=>p.fn === d && p.name === f);
            h >= 0 && s.splice(h, 1),
            (y = i.value) == null || y.off(f, d)
        }
        function l(f, ...d) {
            var h;
            (h = i.value) == null || h.emit(f, ...d)
        }
        function c() {
            if (i.value && (i.value.emit("force-disconnect"),
                i.value.io.reconnection(!1),
                i.value.disconnect(),
                i.value.close(),
                i.value = null),
                !e.value)
                return;
            const f = {};
            t.value && (f.Authorization = t.value,
                f["visitor-id"] = n.value,
                f.token = e.value);
            const h = Cr().public.wsUrl;
            i.value = Ko(h || "", {
                auth: {
                    token: e.value,
                    session: t.value,
                    "visitor-id": n.value
                },
                path: "/ws",
                transports: ["websocket"],
                withCredentials: !0,
                extraHeaders: f,
                transportOptions: {
                    polling: {
                        extraHeaders: f
                    }
                }
            }),
                i.value.on("connect_error", y=>{
                        console.log(`connect_error due to ${y.message}`)
                    }
                ),
                i.value.on("connect", ()=>{
                        var y;
                        console.log("socket.connected", (y = i.value) == null ? void 0 : y.connected),
                            r.value = !0
                    }
                ),
                i.value.on("disconnect", ()=>{
                        var y;
                        console.log("socket.disconnect", (y = i.value) == null ? void 0 : y.connected),
                            r.value = !1
                    }
                ),
                i.value.on("error", y=>console.log("error", y)),
                s.forEach(y=>{
                        var p;
                        return (p = i.value) == null ? void 0 : p.on(y.name, y.fn)
                    }
                )
        }
        const {notify: u} = Tf();
        return Xi(r, async f=>{
                f || u("Connection has been lost with the server!")
            }
            , {
                debounce: 5e3
            }),
            {
                socketOn: o,
                socketOff: a,
                socketEmit: l,
                isSocketConnected: r,
                token: e,
                socket: i,
                reconnect: c
            }
    }
);
var A0 = {
    exports: {}
};
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */
(function(e, t) {
        (function(n, r) {
                e.exports = r()
            }
        )(mi, function() {
            var n = {};
            n.version = "0.2.0";
            var r = n.settings = {
                minimum: .08,
                easing: "ease",
                positionUsing: "",
                speed: 200,
                trickle: !0,
                trickleRate: .02,
                trickleSpeed: 800,
                showSpinner: !0,
                barSelector: '[role="bar"]',
                spinnerSelector: '[role="spinner"]',
                parent: "body",
                template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
            };
            n.configure = function(y) {
                var p, w;
                for (p in y)
                    w = y[p],
                    w !== void 0 && y.hasOwnProperty(p) && (r[p] = w);
                return this
            }
                ,
                n.status = null,
                n.set = function(y) {
                    var p = n.isStarted();
                    y = i(y, r.minimum, 1),
                        n.status = y === 1 ? null : y;
                    var w = n.render(!p)
                        , m = w.querySelector(r.barSelector)
                        , g = r.speed
                        , b = r.easing;
                    return w.offsetWidth,
                        a(function(v) {
                            r.positionUsing === "" && (r.positionUsing = n.getPositioningCSS()),
                                l(m, o(y, g, b)),
                                y === 1 ? (l(w, {
                                    transition: "none",
                                    opacity: 1
                                }),
                                    w.offsetWidth,
                                    setTimeout(function() {
                                        l(w, {
                                            transition: "all " + g + "ms linear",
                                            opacity: 0
                                        }),
                                            setTimeout(function() {
                                                n.remove(),
                                                    v()
                                            }, g)
                                    }, g)) : setTimeout(v, g)
                        }),
                        this
                }
                ,
                n.isStarted = function() {
                    return typeof n.status == "number"
                }
                ,
                n.start = function() {
                    n.status || n.set(0);
                    var y = function() {
                        setTimeout(function() {
                            n.status && (n.trickle(),
                                y())
                        }, r.trickleSpeed)
                    };
                    return r.trickle && y(),
                        this
                }
                ,
                n.done = function(y) {
                    return !y && !n.status ? this : n.inc(.3 + .5 * Math.random()).set(1)
                }
                ,
                n.inc = function(y) {
                    var p = n.status;
                    return p ? (typeof y != "number" && (y = (1 - p) * i(Math.random() * p, .1, .95)),
                        p = i(p + y, 0, .994),
                        n.set(p)) : n.start()
                }
                ,
                n.trickle = function() {
                    return n.inc(Math.random() * r.trickleRate)
                }
                ,
                function() {
                    var y = 0
                        , p = 0;
                    n.promise = function(w) {
                        return !w || w.state() === "resolved" ? this : (p === 0 && n.start(),
                            y++,
                            p++,
                            w.always(function() {
                                p--,
                                    p === 0 ? (y = 0,
                                        n.done()) : n.set((y - p) / y)
                            }),
                            this)
                    }
                }(),
                n.render = function(y) {
                    if (n.isRendered())
                        return document.getElementById("nprogress");
                    u(document.documentElement, "nprogress-busy");
                    var p = document.createElement("div");
                    p.id = "nprogress",
                        p.innerHTML = r.template;
                    var w = p.querySelector(r.barSelector), m = y ? "-100" : s(n.status || 0), g = document.querySelector(r.parent), b;
                    return l(w, {
                        transition: "all 0 linear",
                        transform: "translate3d(" + m + "%,0,0)"
                    }),
                    r.showSpinner || (b = p.querySelector(r.spinnerSelector),
                    b && h(b)),
                    g != document.body && u(g, "nprogress-custom-parent"),
                        g.appendChild(p),
                        p
                }
                ,
                n.remove = function() {
                    f(document.documentElement, "nprogress-busy"),
                        f(document.querySelector(r.parent), "nprogress-custom-parent");
                    var y = document.getElementById("nprogress");
                    y && h(y)
                }
                ,
                n.isRendered = function() {
                    return !!document.getElementById("nprogress")
                }
                ,
                n.getPositioningCSS = function() {
                    var y = document.body.style
                        , p = "WebkitTransform"in y ? "Webkit" : "MozTransform"in y ? "Moz" : "msTransform"in y ? "ms" : "OTransform"in y ? "O" : "";
                    return p + "Perspective"in y ? "translate3d" : p + "Transform"in y ? "translate" : "margin"
                }
            ;
            function i(y, p, w) {
                return y < p ? p : y > w ? w : y
            }
            function s(y) {
                return (-1 + y) * 100
            }
            function o(y, p, w) {
                var m;
                return r.positionUsing === "translate3d" ? m = {
                    transform: "translate3d(" + s(y) + "%,0,0)"
                } : r.positionUsing === "translate" ? m = {
                    transform: "translate(" + s(y) + "%,0)"
                } : m = {
                    "margin-left": s(y) + "%"
                },
                    m.transition = "all " + p + "ms " + w,
                    m
            }
            var a = function() {
                var y = [];
                function p() {
                    var w = y.shift();
                    w && w(p)
                }
                return function(w) {
                    y.push(w),
                    y.length == 1 && p()
                }
            }()
                , l = function() {
                var y = ["Webkit", "O", "Moz", "ms"]
                    , p = {};
                function w(v) {
                    return v.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(S, _) {
                        return _.toUpperCase()
                    })
                }
                function m(v) {
                    var S = document.body.style;
                    if (v in S)
                        return v;
                    for (var _ = y.length, E = v.charAt(0).toUpperCase() + v.slice(1), T; _--; )
                        if (T = y[_] + E,
                        T in S)
                            return T;
                    return v
                }
                function g(v) {
                    return v = w(v),
                    p[v] || (p[v] = m(v))
                }
                function b(v, S, _) {
                    S = g(S),
                        v.style[S] = _
                }
                return function(v, S) {
                    var _ = arguments, E, T;
                    if (_.length == 2)
                        for (E in S)
                            T = S[E],
                            T !== void 0 && S.hasOwnProperty(E) && b(v, E, T);
                    else
                        b(v, _[1], _[2])
                }
            }();
            function c(y, p) {
                var w = typeof y == "string" ? y : d(y);
                return w.indexOf(" " + p + " ") >= 0
            }
            function u(y, p) {
                var w = d(y)
                    , m = w + p;
                c(w, p) || (y.className = m.substring(1))
            }
            function f(y, p) {
                var w = d(y), m;
                c(y, p) && (m = w.replace(" " + p + " ", " "),
                    y.className = m.substring(1, m.length - 1))
            }
            function d(y) {
                return (" " + (y.className || "") + " ").replace(/\s+/gi, " ")
            }
            function h(y) {
                y && y.parentNode && y.parentNode.removeChild(y)
            }
            return n
        })
    }
)(A0);
var sN = A0.exports;
const hn = _v(sN);
function oN(e=null, t) {
    const n = X(e)
        , r = fe({
        set: s=>s ? hn.start() : hn.done(),
        get: ()=>typeof n.value == "number" && n.value < 1
    });
    t && hn.configure(t);
    const i = hn.set;
    return hn.set = s=>(n.value = s,
        i.call(hn, s)),
        Er(()=>{
                typeof n.value == "number" && Wr && i.call(hn, n.value)
            }
        ),
        sn(hn.remove),
        {
            isLoading: r,
            progress: n,
            start: hn.start,
            done: hn.done,
            remove: ()=>{
                n.value = null,
                    hn.remove()
            }
        }
}
const Yo = ti("Browser", {
        web: ()=>at(()=>import("./web.559c3bc1.js"), [], import.meta.url).then(e=>new e.BrowserWeb)
    })
    , aN = async e=>{
        const n = Cr().public.appUrl;
        await Yo.open({
            url: n + "/api/" + e + "/app",
            presentationStyle: "popover"
        })
    }
    , Gs = At(()=>{
            const e = gD()
                , {notify: t} = Tf()
                , {t: n} = $n()
                , i = Cr().public.isApp
                , s = Gr("setting", {
                showHidePair: !1,
                autoHidePair: !1,
                isCameraReversed: i,
                hideStartStopForMobile: !1
            })
                , o = fa("session", {
                watch: !0
            })
                , a = Gr("isUserAgreed-v1", !1)
                , l = X(!0)
                , c = X(!1)
                , u = X()
                , f = X()
                , d = fe(()=>{
                    var T;
                    return u.value == null || ((T = u.value) == null ? void 0 : T.isGuest)
                }
            )
                , h = fe(()=>{
                    var T, P;
                    return ((T = u.value) == null ? void 0 : T.country) != null && ["rus"].includes((P = u.value) == null ? void 0 : P.country) ? "yandex" : "stripe"
                }
            )
                , y = X({})
                , p = fe(()=>{
                    var T, P;
                    return {
                        ...(P = (T = u.value) == null ? void 0 : T.user) == null ? void 0 : P.settings,
                        ...y.value
                    }
                }
            )
                , {isLoading: w} = oN();
            dL(y, async()=>{
                    var T;
                    (T = u.value) != null && T.user && Object.keys(y.value).length && (w.value = !0)
                }
            ),
                Xi(y, async()=>{
                        var T;
                        (T = u.value) != null && T.user && Object.keys(y.value).length && (u.value.user.settings = await $h("/api/settings/update", {
                            method: "POST",
                            body: JSON.stringify(y.value)
                        }),
                            y.value = {}),
                            w.value = !1
                    }
                    , {
                        deep: !0,
                        debounce: 1e3
                    }),
                Vt("update-user", T=>{
                        u.value = T,
                            console.log("user:", u.value)
                    }
                );
            async function m() {
                l.value = !0;
                try {
                    await e.load(),
                        u.value = await $h("/api/user/me", {
                            method: "POST",
                            body: e.visitor.value
                        }),
                        console.log("user:", u.value)
                } catch (T) {
                    console.error(T),
                        T.status === 403 ? t({
                            text: n("error.removedAccount"),
                            type: "warn"
                        }) : t({
                            text: T == null ? void 0 : T.message,
                            type: "warn"
                        }),
                        f.value = T == null ? void 0 : T.message
                } finally {
                    l.value = !1,
                        c.value = !0
                }
            }
            async function g(T) {
                c.value = !1,
                    l.value = !0;
                try {
                    if (i)
                        await aN(T);
                    else {
                        const P = window.open("/api/" + T, "targetWindow", "toolbar=no,location=no,status=no,menubar=no,scrollbars=yes,resizable=yes");
                        await new Promise(I=>{
                                const L = ()=>{
                                        setTimeout(()=>{
                                                if (!P || P.closed) {
                                                    I();
                                                    return
                                                }
                                                L()
                                            }
                                            , 500)
                                    }
                                ;
                                L()
                            }
                        ),
                            window.location.reload()
                    }
                } catch (P) {
                    P = P == null ? void 0 : P.message
                } finally {
                    l.value = !1,
                        c.value = !0
                }
            }
            async function b() {
                await g("google")
            }
            async function v() {
                await g("vk")
            }
            async function S() {
                await g("apple")
            }
            async function _() {
                await g("facebook")
            }
            async function E() {
                l.value = !0,
                    o.value = void 0,
                    setTimeout(()=>{
                            window.location.reload()
                        }
                        , 500)
            }
            return {
                isLoading: l,
                isLoaded: c,
                error: f,
                session: o,
                data: u,
                isGuest: d,
                paymentType: h,
                settings: p,
                settingsForm: y,
                localSettings: s,
                load: m,
                logout: E,
                loginGoogle: b,
                loginVk: v,
                loginApple: S,
                loginFacebook: _,
                isAgreed: a
            }
        }
    )
    , lN = 50
    , I0 = At(()=>{
            const {t: e} = $n()
                , t = X([{
                    id: "call-start",
                    side: 0,
                    text: e("call.begin")
                }])
                , n = X([{
                    id: "searching",
                    side: 0,
                    text: e("call.searching")
                }])
                , r = X([{
                    id: "welcome",
                    side: 0,
                    text: e("call.welcome")
                }])
                , i = X([])
                , s = ()=>{
                    i.value.splice(0, Math.max(0, i.value.length - lN))
                }
            ;
            function o(a) {
                i.value.push({
                    id: a.id || Math.random().toString(),
                    side: 0,
                    user: a.user,
                    type: a.type,
                    text: String(a.text)
                }),
                    s()
            }
            return {
                callMessages: t,
                searchingMessages: n,
                welcomeMessages: r,
                messages: i,
                push: o
            }
        }
    )
    , pF = At(()=>{
            const e = dl()
                , t = I0()
                , {isSocketConnected: n} = oo()
                , r = X([]);
            Se(e.isCall, l=>{}
            );
            const i = FR(e.isCall, 500)
                , s = ()=>{
                    i.value !== e.isCall.value && (r.value = []),
                        i.value ? r.value = [...t.callMessages.value] : e.isSearching.value ? e.isSearching.value && (r.value = [...t.searchingMessages.value]) : r.value = [...t.welcomeMessages.value]
                }
            ;
            Se([i, e.isCall, e.isSearching, t.searchingMessages, t.callMessages, t.welcomeMessages], s),
                Ve(s),
                Vt("chat", ({type: l, data: c, user: u})=>{
                        l === "message" && c.text && t.push({
                            id: c.id || Math.random().toString(),
                            side: 0,
                            user: u,
                            type: l,
                            text: String(c.text)
                        })
                    }
                );
            const o = l=>{
                if (l && e.isPeerConnected.value && n.value) {
                    const c = Math.random().toString();
                    return ht("chat", {
                        id: c,
                        text: l
                    }),
                        t.push({
                            id: c,
                            side: 1,
                            type: "message",
                            text: l
                        }),
                        !0
                }
                return !1
            }
                , a = fe(()=>[...r.value, ...t.messages.value].reduce((l,c)=>{
                    var u, f;
                    if (((u = l.prev) == null ? void 0 : u.side) === c.side && ((f = l.prev) == null ? void 0 : f.user) === c.user)
                        l.prev.messages.push(c);
                    else {
                        const d = {
                            id: c.id,
                            side: c.side,
                            user: c.user,
                            messages: [c]
                        };
                        l.arr.push(d),
                            l.prev = d
                    }
                    return l
                }
                , {
                    prev: null,
                    arr: []
                }).arr);
            return {
                sendMessage: o,
                messageGroups: a
            }
        }
    )
    , cN = e=>{
        const t = ()=>{
                e.value && (e.value.poster = "/preview.png")
            }
        ;
        Ve(t),
            Se(e, t)
    }
    , hF = (e,t)=>{
        const n = ()=>{
                e.value && (e.value.poster = t.value || "/preview.png")
            }
        ;
        Ve(n),
            Se([e, t], n)
    }
    , mF = ()=>{
        const e = ri();
        Ve(n),
            Ve(t),
        e.stream && Xi([e.stream, e.cameraAndMicPermissionGranted], t, {
            debounce: 100
        });
        async function t() {
            var r;
            await ((r = e.start) == null ? void 0 : r.call(e))
        }
        async function n() {
            await e.ensurePermissions()
        }
    }
    , uN = (e,t)=>{
        const n = ri();
        D0(e, n.stream, t),
            M0(e, t)
    }
    , M0 = (e,t)=>{
        let n = null;
        Ve(()=>{
                n = window.setInterval(()=>{
                        e.value != null && e.value.readyState === 4 && (e.value.play(),
                        n != null && window.clearInterval(n),
                            t(e.value))
                    }
                    , 1e3)
            }
        ),
            Kt(()=>{
                    n != null && window.clearInterval(n)
                }
            )
    }
    , D0 = (e,t,n)=>{
        Ve(r),
            Se([t, e].filter(s=>!!s), r);
        async function r() {
            e.value && (t != null && t.value ? fN(e.value, t == null ? void 0 : t.value) : dN(e.value))
        }
        const i = ()=>{
                var s, o;
                e.value && (n(e.value),
                (o = (s = e.value) == null ? void 0 : s.play()) == null || o.catch(()=>{}
                ))
            }
        ;
        Se(e, (s,o)=>{
                o == null || o.removeEventListener("loadedmetadata", i),
                s == null || s.addEventListener("loadedmetadata", i)
            }
        )
    }
;
function fN(e, t) {
    var n;
    e.srcObject = t,
    (n = e == null ? void 0 : e.play()) == null || n.catch(()=>{}
    )
}
function dN(e) {
    e.srcObject = null
}
const N0 = (e,t,n,r,i={
        offerToReceiveAudio: !0,
        offerToReceiveVideo: !0
    },s=!0)=>{
        const o = (O,N)=>{
            n({
                ...N,
                type: O
            })
        }
            , a = new RTCPeerConnection(t);
        let l = 3e3
            , c = !1
            , u = !1
            , f = !1;
        a.addEventListener("icecandidate", O=>{
                var N, D;
                console.log("icecandidate OUT", (N = O.candidate) == null ? void 0 : N.candidate, x(O.candidate)),
                    x(O.candidate) ? o("icecandidate", {
                        message: {
                            candidate: (D = O.candidate) == null ? void 0 : D.toJSON()
                        }
                    }) : console.log("End of candidates.")
            }
        );
        const d = []
            , h = []
            , y = ()=>!!a && c && u
            , p = ()=>!!a && c && u && f
            , w = O=>O.type === "call" || O.type === "answer"
            , m = async O=>{
            w(O) ? (u = !0,
                y() ? (await g(),
                    await I(O)) : d.push(O),
            p() && await b()) : p() ? (await b(),
                await I(O)) : h.push(O)
        }
            , g = async()=>{
            if (p()) {
                let O = d.shift();
                for (; O; )
                    await I(O),
                        O = d.shift()
            }
        }
            , b = async()=>{
            if (y()) {
                let O = h.shift();
                for (; O; )
                    await I(O),
                        O = h.shift()
            }
        }
            , v = []
            , S = [];
        let _ = null;
        async function E() {
            const O = await r();
            if (O !== _) {
                for (_ = O; v.length > 0; ) {
                    const N = v.shift();
                    N && a.removeTrack(N)
                }
                for (; S.length > 0; ) {
                    const N = S.shift();
                    N && a.removeTrack(N)
                }
                O && (O.getVideoTracks().forEach(N=>{
                        v.push(a.addTrack(N, O))
                    }
                ),
                    O.getAudioTracks().forEach(N=>{
                            S.push(a.addTrack(N, O))
                        }
                    ))
            }
        }
        async function T() {
            c = !0,
                b()
        }
        async function P() {
            await E(),
                L();
            const O = await a.createOffer(i);
            await a.setLocalDescription(O).then(N=>{}
            ).catch(N=>{
                    console.error("ERROR OUT CALL", N)
                }
            ),
                o("call", {
                    message: O
                })
        }
        const I = async O=>{
                var N;
                if (console.log("onSignal", O),
                O.type === "icecandidate") {
                    const D = O.message;
                    ((N = D.candidate) == null ? void 0 : N.candidate) != null && await a.addIceCandidate(D.candidate).then(W=>{}
                    ).catch(W=>{
                            console.error("ERROR IN ICE", W, D.candidate)
                        }
                    )
                } else if (O.type === "call") {
                    await E(),
                        L();
                    const D = O.message;
                    await a.setRemoteDescription(D).then(G=>{}
                    ).catch(G=>{
                            console.error("ERROR IN CALL", G)
                        }
                    ),
                        f = !0;
                    const W = await a.createAnswer();
                    await a.setLocalDescription(W).then(G=>{}
                    ).catch(G=>{
                            console.error("ERROR IN LOCAL CALL", G)
                        }
                    ),
                        o("answer", {
                            message: W
                        })
                } else if (O.type === "answer") {
                    const D = O.message;
                    L(),
                        await a.setRemoteDescription(D).then(W=>{}
                        ).catch(W=>{
                                console.error("ERROR IN ANSWER", W)
                            }
                        ),
                        f = !0
                }
            }
        ;
        function L() {
            if ((rs.browserDetails.browser === "chrome" || rs.browserDetails.browser === "safari" || rs.browserDetails.browser === "firefox" && rs.browserDetails.version != null && rs.browserDetails.version >= 64) && "RTCRtpSender"in window && "setParameters"in window.RTCRtpSender.prototype) {
                const O = v[0];
                if (O != null) {
                    const N = O.getParameters();
                    return (!N.encodings || N.encodings.length === 0) && (N.encodings = [{}]),
                        l === "unlimited" ? delete N.encodings[0].maxBitrate : N.encodings[0].maxBitrate = l * 1e3,
                        O.setParameters(N)
                }
            }
        }
        function x(O) {
            const N = O == null ? void 0 : O.candidate;
            return N == null ? !0 : !(t.iceTransportPolicy === "relay" && A(N) !== "relay")
        }
        function A(O) {
            return O.split(" ")[7]
        }
        function k(O) {
            l = O
        }
        return s && T(),
            {
                key: e,
                peer: a,
                call: P,
                start: T,
                onSignal: m,
                setBandwidth: k
            }
    }
;
function pN(e, t=224, n=224, r=224, i=224, s="image/png", o=.85) {
    return new Promise((a,l)=>{
            const {canvas: c, ctx: u} = hN(e, t, n, r, i);
            c.toBlob(f=>{
                    const d = new FileReader;
                    d.readAsDataURL(f),
                        d.onloadend = ()=>{
                            a(d.result.split(",")[1])
                        }
                }
                , s, o)
        }
    )
}
const as = (e,t=224,n=224,r="image/png",i=.85)=>pN(e, e == null ? void 0 : e.videoWidth, e == null ? void 0 : e.videoHeight, t, n, r, i);
function hN(e, t=224, n=224, r=224, i=224) {
    const s = document.createElement("canvas")
        , o = s.getContext("2d")
        , a = t / n;
    let l = 0
        , c = 0;
    return a > 1 ? (l = (t - n * (r / i)) / 2,
        t = n * (r / i)) : a <= 1 && (c = (n - t * (i / r)) / 2,
        n = t * (i / r)),
        s.width = r,
        s.height = i,
        o.drawImage(e, l, c, t, n, 0, 0, r, i),
        {
            canvas: s,
            ctx: o
        }
}
const dl = At(()=>{
        const e = Yb()
            , t = Gs()
            , {isSocketConnected: n} = oo()
            , r = ri()
            , i = I0()
            , s = Uy("hash-params")
            , o = fe(()=>s.key != null)
            , a = X(!1)
            , l = X(!1)
            , c = X()
            , u = X();
        uN(c, se=>{
                se.volume = 0,
                    se.muted = !0
            }
        );
        const f = X()
            , d = X()
            , h = X(!1)
            , y = oO("volume", 100);
        function p() {
            u.value && (u.value.volume = h.value ? 0 : y.value / 100)
        }
        Se([h, y], p),
            D0(u, f, p),
            M0(u, p);
        let w = null;
        r.stream && Se(r.stream, se=>{
                se && se !== w && (w = se,
                d.value != null && R())
            }
        );
        const m = X()
            , g = X()
            , b = X(!1)
            , v = X(!1)
            , S = X(!1)
            , _ = X(!1)
            , E = X(0)
            , T = X(3)
            , P = X(!1)
            , I = X(!0)
            , L = X(!1)
            , x = X(!1)
            , A = X(!1)
            , k = X(!1)
            , O = X(null)
            , N = X({
            volume: 100,
            isMute: !1
        })
            , D = X(!1);
        Se([A, P], ([se,Ie])=>{
                D.value = se && Ie && t.localSettings.value.autoHidePair
            }
        ),
            Se([P, b], ([se,Ie])=>{
                    se && Ie && _.value && (_.value = !1)
                }
            ),
            Se([o, k], ([se,Ie])=>{
                    se && (D.value = Ie && t.localSettings.value.autoHidePair)
                }
            ),
            Se(_, se=>{
                    se || (E.value = 0)
                }
            );
        const {isActive: W, pause: G, resume: le, reset: ge} = zR(1e4, {
            controls: !0,
            callback(se) {
                se < 3 ? (E.value = se,
                    R()) : Q()
            }
        });
        Ve(()=>{
                G()
            }
        ),
            Se([W, _], ([se,Ie])=>{
                    se && !Ie ? G() : !se && Ie && (ge(),
                        le())
                }
            );
        const ye = ()=>{
                var se, Ie;
                (Ie = (se = d.value) == null ? void 0 : se.peer) == null || Ie.close(),
                    d.value = void 0,
                    f.value = void 0,
                    b.value = !1,
                    Ce.value = 0
            }
            , de = ()=>{
                A.value = !1,
                    ye()
            }
            , z = ()=>{
                g.value = void 0,
                    m.value = void 0,
                    _.value = !1,
                    h.value = !1,
                    P.value = !1,
                    I.value = !0,
                    O.value = null,
                    N.value.isMute = !1,
                    N.value.volume = 100,
                    de()
            }
            , Pe = []
            , _e = se=>{
                ne(),
                    console.log("server-signal", se),
                d.value && d.value.onSignal(se.value)
            }
            , J = X(0)
            , ne = ()=>{
                J.value = (J.value + 1) % 1e5
            }
            , ee = se=>{
                var Ie;
                ((Ie = d.value) == null ? void 0 : Ie.key) === se.key ? _e(se) : Pe.push(se)
            }
            , ce = ()=>{
                let se = Pe.shift();
                for (; se; )
                    _e(se),
                        se = Pe.shift()
            }
            , Ce = X(0)
            , M = se=>{
                var ze;
                if (ye(),
                    Ce.value = 1,
                    A.value = !0,
                O.value == null || w == null)
                    return;
                const Ie = ((ze = t.data.value) == null ? void 0 : ze.servers) || [];
                d.value = N0(se, {
                    iceServers: [...Ie]
                }, $e=>ht("signal", {
                    value: $e,
                    key: se
                }), ()=>w),
                    d.value.peer.addEventListener("connectionstatechange", $e=>{
                            var Ue, kn, pn, qi;
                            ((Ue = d.value) == null ? void 0 : Ue.peer.connectionState) === "connected" && (console.log("CONNECTED!!!"),
                                b.value = !0,
                                C()),
                            ((kn = d.value) == null ? void 0 : kn.peer.connectionState) === "failed" && (console.log("FAILED!!!"),
                                De(!0)),
                            ((pn = d.value) == null ? void 0 : pn.peer.connectionState) === "disconnected" && (console.log("DISCONNECTED!!!"),
                                De(!0)),
                            ((qi = d.value) == null ? void 0 : qi.peer.connectionState) === "closed" && (console.log("CLOSED!!!"),
                                De(!1))
                        }
                    ),
                    d.value.peer.addEventListener("iceconnectionstatechange", ()=>{
                            var $e, Ue;
                            console.log("iceconnectionstatechange", ($e = d.value) == null ? void 0 : $e.peer.iceConnectionState),
                                ((Ue = d.value) == null ? void 0 : Ue.peer.iceConnectionState) !== "connected" ? Ce.value = 3 : Ce.value = 2
                        }
                    ),
                    d.value.peer.addEventListener("connectionstatechange", ()=>{
                            var $e, Ue, kn, pn;
                            console.log("connectionstatechange", ($e = d.value) == null ? void 0 : $e.peer.connectionState),
                                ((Ue = d.value) == null ? void 0 : Ue.peer.connectionState) === "connecting" ? Ce.value = 3 : ((kn = d.value) == null ? void 0 : kn.peer.connectionState) === "connected" ? Ce.value = 4 : (pn = d.value) != null && pn.peer.connectionState && (Ce.value = 0)
                        }
                    );
                function De($e=!1) {
                    b.value && (b.value = !1,
                        a.value = !1,
                        o.value ? (l.value = !1,
                            v.value = !1,
                            i.messages.value = [...i.messages.value.filter(Ue=>Ue.id !== "stream-ready")],
                            i.messages.value = [...i.messages.value.filter(Ue=>Ue.id !== "tuc")],
                            Y()) : $e && setTimeout(()=>{
                                var Ue;
                                ((Ue = d.value) == null ? void 0 : Ue.key) === se && R()
                            }
                            , 1e3))
                }
                d.value.peer.addEventListener("track", $e=>{
                        var Ue;
                        console.log("ontrack", $e),
                        f.value !== $e.streams[0] && (f.value = $e.streams[0],
                        (Ue = u.value) == null || Ue.play())
                    }
                ),
                O.value.initiator && d.value.call(),
                    ce(),
                    console.log("START CALLING!")
            }
        ;
        Se(u, se=>{
                se == null || se.addEventListener("playing", ()=>{
                        P.value = !0,
                            I.value = !1
                    }
                )
            }
        ),
            Vt("call-state", async se=>{
                    N.value.isMute = se.isMute,
                        N.value.volume = se.volume
                }
            );
        const C = ()=>{
                ht("call-state", {
                    isMute: h.value,
                    volume: y.value
                })
            }
        ;
        TL([h, y], ()=>{
                C()
            }
            , {
                throttle: 500
            }),
            Vt("call", async se=>{
                    if (console.log("call", se),
                        de(),
                    !o.value && !v.value) {
                        ht("stop");
                        return
                    }
                    g.value = se.preview,
                        m.value = se.country,
                        O.value = se,
                        M(se.key)
                }
            );
        const R = async()=>{
            _.value = !0,
            n.value && ht("recall")
        }
            , F = Ay(async se=>{
                console.log("recall"),
                    M(se.key)
            }
            , 500);
        Vt("recall", F),
            Vt("signal", ee),
            Vt("skip", se=>{
                    console.log("skip", se),
                        o.value ? Y() : (z(),
                        v.value && Q())
                }
            ),
            Vt("stop", se=>{
                    console.log("stop", se),
                        v.value = !1,
                        z()
                }
            ),
            Vt("servers", se=>{
                    t.data.value && (t.data.value.servers = se)
                }
            );
        const V = ()=>{
                g.value = void 0,
                    m.value = void 0,
                    P.value = !1,
                    L.value = !1,
                    x.value = !1,
                    i.callMessages.value = [{
                        id: "call-searching",
                        side: 0,
                        text: "Поиск собеседника..."
                    }]
            }
        ;
        Vt("cmd", se=>{
                var Ie, De, ze, $e;
                switch (console.log("cmd", se),
                    se.type) {
                    case "catched":
                        a.value = !0,
                            v.value = !1,
                            k.value = !1,
                            V();
                        break;
                    case "dialog":
                        k.value = !0,
                            g.value = se.preview,
                        se.country && (m.value = (Ie = se.country) == null ? void 0 : Ie.toLowerCase()),
                            i.callMessages.value = [{
                                id: "call-test",
                                side: 0,
                                text: "Ваш собеседник из: " + m.value
                            }];
                        break;
                    case "start-stream":
                        break;
                    case "end":
                        k.value = !1,
                            V();
                        break;
                    case "stop":
                        k.value = !1,
                            V();
                        break;
                    case "next":
                        k.value = !1,
                            V();
                        break;
                    case "country":
                        console.log("country", se.country),
                            e.setSelectedCountryISO([se.country]);
                        break;
                    case "track-video":
                        L.value = !0;
                        break;
                    case "track-audio":
                        x.value = !0;
                        break;
                    case "ren":
                        i.messages.value.push({
                            id: Math.random().toString(),
                            side: 0,
                            text: "Собеседник пожаловался!"
                        });
                        break;
                    case "tuc":
                        i.messages.value = [...i.messages.value.filter(Ue=>Ue.id !== "tuc"), {
                            id: "tuc",
                            side: 1,
                            text: "Сервер разрешил доступ!"
                        }];
                        break;
                    case "stream-ready":
                        l.value = !0,
                            i.messages.value = [...i.messages.value.filter(Ue=>Ue.id !== "stream-ready"), {
                                id: "stream-ready",
                                side: 1,
                                text: "Камера подключена!"
                            }];
                        break;
                    case "geo":
                        i.callMessages.value = [...i.callMessages.value.filter(Ue=>Ue.id !== "geo"), {
                            id: "geo",
                            side: 0,
                            text: `Country: ${(De = se.json) == null ? void 0 : De.country} || Region: ${(ze = se.json) == null ? void 0 : ze.regionName} || City: ${($e = se.json) == null ? void 0 : $e.city}`
                        }];
                        break
                }
            }
        );
        const Y = ()=>{
                o.value && (z(),
                    ht("start", {
                        countries: e.selectedCountriesISO.value,
                        controlKey: s.key,
                        controlRole: "control"
                    }))
            }
        ;
        Ve(()=>{
                Y()
            }
        );
        const re = async()=>{
                let se = null;
                c.value && (se = await as(c.value, 128, 128, "image/png")),
                    ht("online", {
                        photo: se
                    })
            }
        ;
        Pf(re, 2e4),
            Xi(r.isWaitingForStream, async se=>{
                    !se && r.isMediaRequested.value && (await hb(500),
                        await re())
                }
                , {
                    debounce: 500
                });
        const ie = ()=>{
                ht("stop"),
                    z()
            }
        ;
        Kt(()=>{
                ie()
            }
        );
        const ae = se=>{
                e.setSelectedCountry([se]),
                    ht("cmd", {
                        type: "country",
                        country: se.country
                    })
            }
            , Q = async()=>{
                if (!S.value)
                    if (v.value = !0,
                        o.value)
                        ht("cmd", {
                            type: "start"
                        });
                    else {
                        z();
                        let se = null;
                        c.value && (se = await as(c.value, 32, 32, "image/jpeg", .85)),
                            ht("start", {
                                countries: e.selectedCountriesISO.value,
                                preview: se,
                                controlKey: o.value ? s.key : void 0,
                                controlRole: o.value ? "control" : void 0
                            })
                    }
            }
            , U = ()=>{
                v.value = !1,
                    o.value ? ht("cmd", {
                        type: "stop"
                    }) : (ht("stop"),
                        z())
            }
            , $ = ()=>{
                S.value = !0,
                    U()
            }
            , Z = ()=>{
                S.value = !1
            }
            , te = ()=>{
                a.value = !1,
                    ht("cmd", {
                        type: "reload"
                    })
            }
            , pe = async()=>{
                var Ie, De;
                if (!A.value || o.value || !((Ie = d.value) != null && Ie.key))
                    return null;
                let se = null;
                return u.value && (se = await as(u.value, 224, 224, "image/png")),
                    se != null ? {
                        photo: se,
                        key: (De = d.value) == null ? void 0 : De.key,
                        preview: g.value
                    } : null
            }
            , oe = async(se,Ie,De)=>{
                ht("report-nsfw", {
                    key: Ie,
                    photo: se,
                    pic: De
                })
            }
            , me = async(se,Ie,De)=>{
                v.value = !0,
                    z();
                let ze = null;
                c.value && (ze = await as(c.value, 32, 32, "image/jpeg", .85)),
                    ht("report", {
                        key: Ie,
                        photo: se,
                        countries: e.selectedCountriesISO.value,
                        preview: ze,
                        pic: De
                    })
            }
        ;
        Vt("report", async(se,Ie)=>{
                let De = null;
                c.value && (De = await as(c.value, 224, 224, "image/png")),
                Ie == null || Ie({
                    photo: De
                })
            }
        );
        const Me = fe(()=>o.value ? l.value && v.value : v.value)
            , Ne = fe(()=>{
                var se;
                return ((se = r.cameraAndMicPermissionGranted) == null ? void 0 : se.value) && !(r.isWaitingForStream.value || r.isWaitingForMedia.value) && n.value && (!Me.value || A.value)
            }
        )
            , et = fe(()=>Ne.value && (o.value ? l.value : !0));
        return {
            selfVideo: c,
            remoteVideo: u,
            isMute: h,
            volume: y,
            recall: R,
            onStart: Q,
            onStop: U,
            onReload: te,
            onBlock: $,
            onUnblock: Z,
            prepareReport: pe,
            report: me,
            reportNsfw: oe,
            canStartPeer: Ne,
            canStart: et,
            isSearchingPeer: v,
            isSearching: Me,
            isControl: o,
            isDonorBanned: a,
            isDonorReady: l,
            isControlCall: k,
            stream: f,
            remoteCountry: m,
            setSelectedCountryToDonor: ae,
            isPeerConnected: b,
            isRecalling: _,
            isRecallingNumber: E,
            isRecallingMaxNumber: T,
            isVideoReady: P,
            isVideoMuted: I,
            preview: g,
            isCall: A,
            callState: N,
            callData: O,
            startWorker: Y,
            isHideCaller: D,
            peerCall: d,
            peerConnectionState: Ce
        }
    }
)
    , mN = At(()=>{
        const e = Gs()
            , t = dl()
            , n = ri()
            , r = X([]);
        let i = null;
        n.stream && Se(n.stream, l=>{
                if (l && l !== i) {
                    i = l;
                    for (const c of r.value)
                        c.peerCall != null && c.peerCall.call()
                }
            }
        );
        const s = l=>{
                for (const c of r.value)
                    c.key === l.key && c.peerCall != null && c.peerCall.onSignal(l.value)
            }
            , o = l=>{
                var h;
                const c = l == null ? void 0 : l.key;
                if (c == null || i == null)
                    return;
                const u = ((h = e.data.value) == null ? void 0 : h.servers) || []
                    , f = N0(c, {
                    iceServers: [...u]
                }, y=>ht("signal-check", {
                    value: y,
                    key: c
                }), ()=>i)
                    , d = {
                    ...l,
                    peerCall: f,
                    close: ()=>{
                        var y;
                        (y = f == null ? void 0 : f.peer) == null || y.close()
                    }
                    ,
                    destroy: ()=>{
                        const y = r.value.findIndex(p=>p === d);
                        y >= 0 && r.value.splice(y, 1)
                    }
                };
                r.value.push(d),
                    f.peer.addEventListener("connectionstatechange", y=>{
                            var p;
                            console.log("!!!connectionstatechange", y),
                            f.peer.connectionState === "connected" && (console.log("CONNECTED!!!"),
                                ht("check", {
                                    key: c,
                                    type: "key",
                                    callKey: (p = t.peerCall.value) == null ? void 0 : p.key
                                })),
                            f.peer.connectionState === "failed" && console.log("FAILED!!!"),
                            f.peer.connectionState === "disconnected" && (console.log("DISCONNECTED!!!"),
                                d.destroy()),
                            f.peer.connectionState === "closed" && (console.log("CLOSED!!!"),
                                d.destroy())
                        }
                    ),
                    f.peer.addEventListener("track", y=>{
                            console.log("ontrack", y),
                            d.stream !== y.streams[0] && (d.stream = y.streams[0])
                        }
                    ),
                d.initiator && f.call(),
                    console.log("START CALLING!")
            }
        ;
        Vt("call-check", async l=>{
                o(l)
            }
        ),
            Vt("signal-check", s);
        const {notify: a} = Tf();
        return Ve(()=>{
                window.notify = a
            }
        ),
            Vt("command", l=>{
                    switch (l.type) {
                        case "reload":
                            window.location.reload();
                            break;
                        case "reload-session":
                            document.cookie = "",
                                window.location.reload();
                            break;
                        case "notify":
                            a(l.data);
                            break
                    }
                }
            ),
            Se(t.peerCall, l=>{
                    for (const c of r.value)
                        ht("check", {
                            key: c.key,
                            type: "key",
                            callKey: l == null ? void 0 : l.key
                        })
                }
            ),
            {
                peers: r
            }
    }
)
    , gN = At(()=>{
        const e = dl()
            , t = X(!1)
            , n = X(null);
        Se([n], ()=>{
                t.value = !!n.value
            }
        );
        const r = async()=>{
                n.value = await e.prepareReport()
            }
            , i = async()=>{
                n.value = null
            }
        ;
        return {
            isReport: t,
            report: n,
            showReport: r,
            hideReport: i,
            doReport: async()=>{
                n.value && (await e.report(n.value.photo, n.value.key, n.value.preview),
                    i())
            }
            ,
            fastReport: async()=>{
                const a = await e.prepareReport();
                a != null && a.photo && (a == null ? void 0 : a.key) != null && await e.report(a.photo, a.key, a.preview),
                    i()
            }
        }
    }
)
    , vN = At(()=>{
        const e = Uy("hash-params")
            , t = fe(()=>e.old != null)
            , n = fe(()=>e.noui != null)
            , r = fe(()=>e.gain != null ? Number(e.gain) : 90);
        return {
            isOld: t,
            isNoUI: n,
            gain: r
        }
    }
)
    , yN = At(()=>{
        const e = PL()
            , {toggle: t} = JL()
            , n = Dl("Alt")
            , r = Dl("Shift")
            , i = Dl("Control");
        li(["q", "й"], ne=>{
                var ee, ce;
                !i.value && !r.value && ((ee = e.value) == null ? void 0 : ee.tagName) !== "INPUT" && ((ce = e.value) == null ? void 0 : ce.tagName) !== "TEXTAREA" && (n.value ? (ne.preventDefault(),
                    ne.stopPropagation(),
                    N()) : n.value || (ne.preventDefault(),
                    ne.stopPropagation(),
                    O()))
            }
        ),
            li(["f", "а"], ne=>{
                    var ee, ce;
                    !n.value && !i.value && !r.value && ((ee = e.value) == null ? void 0 : ee.tagName) !== "INPUT" && ((ce = e.value) == null ? void 0 : ce.tagName) !== "TEXTAREA" && (ne.preventDefault(),
                        ne.stopPropagation(),
                        t())
                }
            ),
            li("ArrowUp", ne=>{
                    var ee, ce;
                    !n.value && !i.value && !r.value && ((ee = e.value) == null ? void 0 : ee.tagName) !== "INPUT" && ((ce = e.value) == null ? void 0 : ce.tagName) !== "TEXTAREA" && (ne.preventDefault(),
                        ne.stopPropagation(),
                        document.body.focus(),
                        w.value = !1)
                }
            ),
            li("ArrowDown", ne=>{
                    var ee, ce;
                    !n.value && !i.value && !r.value && ((ee = e.value) == null ? void 0 : ee.tagName) !== "INPUT" && ((ce = e.value) == null ? void 0 : ce.tagName) !== "TEXTAREA" && (ne.preventDefault(),
                        ne.stopPropagation(),
                        document.body.focus(),
                        w.value = !0)
                }
            ),
            li("ArrowRight", ne=>{
                    var ee, ce;
                    !n.value && !i.value && !r.value && ((ee = e.value) == null ? void 0 : ee.tagName) !== "INPUT" && ((ce = e.value) == null ? void 0 : ce.tagName) !== "TEXTAREA" && (ne.preventDefault(),
                        ne.stopPropagation(),
                        document.body.focus(),
                        G())
                }
            ),
            li("ArrowLeft", ne=>{
                    var ee, ce;
                    !n.value && !i.value && !r.value && ((ee = e.value) == null ? void 0 : ee.tagName) !== "INPUT" && ((ce = e.value) == null ? void 0 : ce.tagName) !== "TEXTAREA" && (ne.preventDefault(),
                        ne.stopPropagation(),
                        document.body.focus(),
                        le())
                }
            );
        const s = X()
            , o = X()
            , {cameraAndMicPermissionGranted: a, cameras: l, mics: c, micDevice: u, cameraDevice: f, setCamera: d, setMic: h} = ri()
            , {remoteVideo: y, selfVideo: p, isMute: w, volume: m, onStart: g, onStop: b, onReload: v, isSearching: S, isPeerConnected: _, isRecalling: E, preview: T, isDonorReady: P, canStart: I, report: L, prepareReport: x, isControl: A, isDonorBanned: k} = dl();
        mN(),
            cN(p);
        const {showReport: O, fastReport: N} = gN()
            , D = Lf()
            , W = fe(()=>D.value && I.value)
            , G = (ne=!1)=>{
            var ee;
            g(),
            ne && ((ee = o.value) == null || ee.focus())
        }
            , le = (ne=!1)=>{
            var ee;
            b(),
            ne && ((ee = o.value) == null || ee.focus())
        }
            , ge = (ne=!1)=>{
            var ee;
            v(),
            ne && ((ee = o.value) == null || ee.focus())
        }
            , {localSettings: ye} = Gs()
            , {idle: de} = eO(3e3, {
            listenForVisibilityChange: !0
        });
        Se(de, ne=>{
                ne && (document.activeElement === s.value || document.activeElement === o.value) && document.activeElement.blur()
            }
        );
        const {isNoUI: z} = vN()
            , Pe = YR(15e3)
            , _e = fe(()=>!Pe.value && !z.value ? !S.value : !1)
            , J = cl();
        return {
            remoteVideo: y,
            selfVideo: p,
            cameraAndMicPermissionGranted: a,
            cameras: l,
            mics: c,
            micDevice: u,
            cameraDevice: f,
            setCamera: d,
            setMic: h,
            onStart: G,
            onStop: le,
            onReload: ge,
            canStart: W,
            isSearching: S,
            isPeerConnected: _,
            isRecalling: E,
            isControl: A,
            isDonorBanned: k,
            isDonorReady: P,
            report: L,
            prepareReport: x,
            preview: T,
            remoteVideoContainer: s,
            localVideoContainer: o,
            showInterface: _e,
            isMobile: J,
            localSettings: ye,
            isMute: w,
            volume: m
        }
    }
)
    , bN = {
    key: 0,
    class: "flex flex-col gap-2 px-2 pointer-events-auto"
}
    , wN = {
    key: 0,
    class: "flex-1 min-w-0"
}
    , SN = {
    key: 1,
    class: "flex-1 min-w-0"
}
    , _N = Xe({
    __name: "device",
    setup(e) {
        const {cameras: t, mics: n, setMic: r, setCamera: i, micDevice: s, cameraDevice: o} = yN()
            , {isMediaRequested: a, isWaitingForMedia: l, isWaitingForStream: c, cameraAndMicPermissionGranted: u} = ri()
            , f = X(!1);
        Xi([a, l, c], ([y,p,w])=>{
                f.value = y && (p || w)
            }
            , {
                debounce: 2e3
            });
        const d = fe(()=>a.value && (l.value || c.value) && f.value)
            , h = ()=>{
                window.location.reload()
            }
        ;
        return (y,p)=>{
            const w = JA
                , m = Xy;
            return we(d) ? (Ae(),
                gt(m, {
                    key: 0
                }, {
                    default: mt(()=>[we(u) && (we(t) != null && we(t).length > 1 || we(n) != null && we(n).length > 1) ? (Ae(),
                        Qe("div", bN, [we(t) != null && we(t).length > 1 ? (Ae(),
                            Qe("div", wN, [Re(w, {
                                value: we(o),
                                onChange: we(i),
                                items: we(t),
                                "default-name": y.$t("control.defaultCamera"),
                                "default-names": y.$t("control.camera")
                            }, null, 8, ["value", "onChange", "items", "default-name", "default-names"])])) : Wt("", !0), we(n) != null && we(n).length > 1 ? (Ae(),
                            Qe("div", SN, [Re(w, {
                                value: we(s),
                                onChange: we(r),
                                items: we(n),
                                "default-name": y.$t("control.defaultMic"),
                                "default-names": y.$t("control.mic")
                            }, null, 8, ["value", "onChange", "items", "default-name", "default-names"])])) : Wt("", !0), Te("button", {
                            onClick: h,
                            class: "relative btn bg-black text-white"
                        }, _n(y.$t("action.reload")), 1)])) : Wt("", !0)]),
                    _: 1
                })) : Wt("", !0)
        }
    }
});
var pm;
(function(e) {
        e.Dark = "DARK",
            e.Light = "LIGHT",
            e.Default = "DEFAULT"
    }
)(pm || (pm = {}));
var hm;
(function(e) {
        e.None = "NONE",
            e.Slide = "SLIDE",
            e.Fade = "FADE"
    }
)(hm || (hm = {}));
const Wl = ti("StatusBar")
    , mm = ti("AppTrackingTransparency", {
    web: ()=>at(()=>import("./web.5d56cc71.js"), [], import.meta.url).then(e=>new e.AppTrackingTransparencyWeb)
})
    , $0 = At(()=>{
        const e = Cr()
            , {isIos: t, isAndroid: n, isWeb: r, platform: i} = EO()
            , s = X(!1)
            , o = X()
            , a = fe(()=>t.value ? s.value : !0)
            , l = fe(()=>t.value ? o.value === "denied" : !1);
        async function c() {
            const d = await mm.getStatus();
            return t.value ? s.value = (d == null ? void 0 : d.status) === "authorized" : s.value = !0,
                d == null ? void 0 : d.status
        }
        async function u() {
            const d = await mm.requestPermission();
            return t.value ? s.value = (d == null ? void 0 : d.status) === "authorized" : s.value = !0,
                d == null ? void 0 : d.status
        }
        const f = async()=>{
                e.public.isApp && (Wl == null || Wl.setOverlaysWebView({
                    overlay: !0
                }))
            }
        ;
        return Ve(f),
            Se(t, async d=>{
                    if (d) {
                        let h = await c();
                        h !== "authorized" && (h = await u()),
                            o.value = h
                    }
                }
            ),
            {
                isIos: t,
                isAndroid: n,
                isWeb: r,
                initApp: f,
                hasAppTrackingTransparency: a,
                hasIosAppTrackingTransparency: s,
                appTrackingTransparencyDenied: l
            }
    }
)
    , EN = {
    class: "pointer-events-auto rounded-xl main-bg shadow-lg flex flex-col text-lg justify-stretch items-stretch"
}
    , CN = Te("div", {
    class: "modal-bg rounded-xl"
}, null, -1)
    , TN = {
    class: "relative font-semibold py-4 px-6 bg-base-100 bg-opacity-60 rounded-t-xl border-b border-b-base-100 flex gap-4 items-center"
}
    , xN = {
    class: "relative flex flex-col gap-8 p-8"
}
    , PN = {
    class: "font-semibold"
}
    , kN = {
    class: "flex gap-3 justify-center items-center flex-col w-full md:flex-row"
}
    , RN = {
    class: "flex-1"
}
    , LN = Xe({
    __name: "ios-no-tracking",
    setup(e) {
        const {appTrackingTransparencyDenied: t} = $0()
            , n = ()=>{
                window.location.reload()
            }
        ;
        return (r,i)=>{
            const s = rb;
            return Ae(),
                gt(s, {
                    size: "max-w-3xl",
                    show: we(t),
                    controllable: "",
                    "close-button": !1,
                    parent: "",
                    background: ""
                }, {
                    default: mt(()=>[Te("div", EN, [CN, Te("div", TN, [Re(we(Eh), {
                        class: "w-7 h-7"
                    }), Wa(" " + _n(r.$t("iosnotracking.modal.title")), 1)]), Te("div", xN, [Te("div", PN, _n(r.$t("iosnotracking.modal.description")), 1), Te("div", kN, [Te("button", {
                        class: "btn btn-error flex flex-row justify-center items-center leading-1 px-4 py-3 gap-4 min-w-[12rem] w-full md:w-auto",
                        onClick: n
                    }, [Re(we(Eh), {
                        class: "h-5 w-5"
                    }), Te("span", RN, _n(r.$t("iosnotracking.modal.request")), 1)])])])])]),
                    _: 1
                }, 8, ["show"])
        }
    }
})
    , gm = {
    pwaInDevEnvironment: !1,
    webManifest: {
        href: "/manifest.webmanifest",
        useCredentials: !1,
        linkTag: '<link rel="manifest" href="/manifest.webmanifest">'
    }
}
    , ON = Xe({
    async setup() {
        if (gm) {
            const e = X({
                link: []
            });
            nT(e);
            const {webManifest: t} = gm;
            if (t) {
                const {href: n, useCredentials: r} = t;
                r ? e.value.link.push({
                    rel: "manifest",
                    href: n,
                    crossorigin: "use-credentials"
                }) : e.value.link.push({
                    rel: "manifest",
                    href: n
                })
            }
        }
        return ()=>null
    }
})
    , AN = At(()=>{
        const e = X()
            , t = X(0)
            , n = X(0)
            , r = X(0)
            , i = ts("--vh-b")
            , s = ts("--vw-b")
            , o = ts("--ratio");
        function a() {
            t.value = window.innerHeight,
                n.value = window.innerWidth,
                r.value = window.innerHeight / window.innerWidth,
                i.value = window.innerHeight + "px",
                s.value = window.innerWidth + "px",
                o.value = String(window.innerHeight / window.innerWidth)
        }
        function l() {
            a(),
                setTimeout(()=>{
                        a()
                    }
                    , 1e3),
                setTimeout(()=>{
                        a()
                    }
                    , 2e3)
        }
        Ve(()=>{
                window.addEventListener("resize", l),
                    a()
            }
        ),
            Kt(()=>{
                    window.removeEventListener("resize", l)
                }
            );
        const c = Gr("panelHeightVar", "")
            , u = ts("--panel-h")
            , f = ts("--panel-adjust")
            , d = cl()
            , h = uO()
            , y = ()=>{
                const p = h.height.value / h.width.value;
                d.value && p < 1 ? (u.value = "99999rem",
                    f.value = "99999rem") : (u.value = "0rem",
                    f.value = c.value)
            }
        ;
        return Xi([d, h.width, h.height, c], y, {
            debounce: 100
        }),
            Ve(y),
            {
                container: e,
                windowHeight: t,
                windowWidth: n,
                ratio: r,
                panelHeightVar: c
            }
    }
)
    , F0 = "" + globalThis.__publicAssetsURL("text-logo-white.svg");
function vm(e) {
    return e !== null && typeof e == "object" && "constructor"in e && e.constructor === Object
}
function zf(e, t) {
    e === void 0 && (e = {}),
    t === void 0 && (t = {}),
        Object.keys(t).forEach(n=>{
                typeof e[n] > "u" ? e[n] = t[n] : vm(t[n]) && vm(e[n]) && Object.keys(t[n]).length > 0 && zf(e[n], t[n])
            }
        )
}
const j0 = {
    body: {},
    addEventListener() {},
    removeEventListener() {},
    activeElement: {
        blur() {},
        nodeName: ""
    },
    querySelector() {
        return null
    },
    querySelectorAll() {
        return []
    },
    getElementById() {
        return null
    },
    createEvent() {
        return {
            initEvent() {}
        }
    },
    createElement() {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute() {},
            getElementsByTagName() {
                return []
            }
        }
    },
    createElementNS() {
        return {}
    },
    importNode() {
        return null
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    }
};
function Rt() {
    const e = typeof document < "u" ? document : {};
    return zf(e, j0),
        e
}
const IN = {
    document: j0,
    navigator: {
        userAgent: ""
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    },
    history: {
        replaceState() {},
        pushState() {},
        go() {},
        back() {}
    },
    CustomEvent: function() {
        return this
    },
    addEventListener() {},
    removeEventListener() {},
    getComputedStyle() {
        return {
            getPropertyValue() {
                return ""
            }
        }
    },
    Image() {},
    Date() {},
    screen: {},
    setTimeout() {},
    clearTimeout() {},
    matchMedia() {
        return {}
    },
    requestAnimationFrame(e) {
        return typeof setTimeout > "u" ? (e(),
            null) : setTimeout(e, 0)
    },
    cancelAnimationFrame(e) {
        typeof setTimeout > "u" || clearTimeout(e)
    }
};
function ot() {
    const e = typeof window < "u" ? window : {};
    return zf(e, IN),
        e
}
function MN(e) {
    const t = e;
    Object.keys(t).forEach(n=>{
            try {
                t[n] = null
            } catch {}
            try {
                delete t[n]
            } catch {}
        }
    )
}
function Kr(e, t) {
    return t === void 0 && (t = 0),
        setTimeout(e, t)
}
function un() {
    return Date.now()
}
function DN(e) {
    const t = ot();
    let n;
    return t.getComputedStyle && (n = t.getComputedStyle(e, null)),
    !n && e.currentStyle && (n = e.currentStyle),
    n || (n = e.style),
        n
}
function du(e, t) {
    t === void 0 && (t = "x");
    const n = ot();
    let r, i, s;
    const o = DN(e);
    return n.WebKitCSSMatrix ? (i = o.transform || o.webkitTransform,
    i.split(",").length > 6 && (i = i.split(", ").map(a=>a.replace(",", ".")).join(", ")),
        s = new n.WebKitCSSMatrix(i === "none" ? "" : i)) : (s = o.MozTransform || o.OTransform || o.MsTransform || o.msTransform || o.transform || o.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"),
        r = s.toString().split(",")),
    t === "x" && (n.WebKitCSSMatrix ? i = s.m41 : r.length === 16 ? i = parseFloat(r[12]) : i = parseFloat(r[4])),
    t === "y" && (n.WebKitCSSMatrix ? i = s.m42 : r.length === 16 ? i = parseFloat(r[13]) : i = parseFloat(r[5])),
    i || 0
}
function ds(e) {
    return typeof e == "object" && e !== null && e.constructor && Object.prototype.toString.call(e).slice(8, -1) === "Object"
}
function NN(e) {
    return typeof window < "u" && typeof window.HTMLElement < "u" ? e instanceof HTMLElement : e && (e.nodeType === 1 || e.nodeType === 11)
}
function Zt() {
    const e = Object(arguments.length <= 0 ? void 0 : arguments[0])
        , t = ["__proto__", "constructor", "prototype"];
    for (let n = 1; n < arguments.length; n += 1) {
        const r = n < 0 || arguments.length <= n ? void 0 : arguments[n];
        if (r != null && !NN(r)) {
            const i = Object.keys(Object(r)).filter(s=>t.indexOf(s) < 0);
            for (let s = 0, o = i.length; s < o; s += 1) {
                const a = i[s]
                    , l = Object.getOwnPropertyDescriptor(r, a);
                l !== void 0 && l.enumerable && (ds(e[a]) && ds(r[a]) ? r[a].__swiper__ ? e[a] = r[a] : Zt(e[a], r[a]) : !ds(e[a]) && ds(r[a]) ? (e[a] = {},
                    r[a].__swiper__ ? e[a] = r[a] : Zt(e[a], r[a])) : e[a] = r[a])
            }
        }
    }
    return e
}
function ps(e, t, n) {
    e.style.setProperty(t, n)
}
function H0(e) {
    let {swiper: t, targetPosition: n, side: r} = e;
    const i = ot()
        , s = -t.translate;
    let o = null, a;
    const l = t.params.speed;
    t.wrapperEl.style.scrollSnapType = "none",
        i.cancelAnimationFrame(t.cssModeFrameID);
    const c = n > s ? "next" : "prev"
        , u = (d,h)=>c === "next" && d >= h || c === "prev" && d <= h
        , f = ()=>{
            a = new Date().getTime(),
            o === null && (o = a);
            const d = Math.max(Math.min((a - o) / l, 1), 0)
                , h = .5 - Math.cos(d * Math.PI) / 2;
            let y = s + h * (n - s);
            if (u(y, n) && (y = n),
                t.wrapperEl.scrollTo({
                    [r]: y
                }),
                u(y, n)) {
                t.wrapperEl.style.overflow = "hidden",
                    t.wrapperEl.style.scrollSnapType = "",
                    setTimeout(()=>{
                            t.wrapperEl.style.overflow = "",
                                t.wrapperEl.scrollTo({
                                    [r]: y
                                })
                        }
                    ),
                    i.cancelAnimationFrame(t.cssModeFrameID);
                return
            }
            t.cssModeFrameID = i.requestAnimationFrame(f)
        }
    ;
    f()
}
function ii(e) {
    return e.querySelector(".swiper-slide-transform") || e.shadowRoot && e.shadowRoot.querySelector(".swiper-slide-transform") || e
}
function xt(e, t) {
    return t === void 0 && (t = ""),
        [...e.children].filter(n=>n.matches(t))
}
function wn(e, t) {
    t === void 0 && (t = []);
    const n = document.createElement(e);
    return n.classList.add(...Array.isArray(t) ? t : [t]),
        n
}
function Ca(e) {
    const t = ot()
        , n = Rt()
        , r = e.getBoundingClientRect()
        , i = n.body
        , s = e.clientTop || i.clientTop || 0
        , o = e.clientLeft || i.clientLeft || 0
        , a = e === t ? t.scrollY : e.scrollTop
        , l = e === t ? t.scrollX : e.scrollLeft;
    return {
        top: r.top + a - s,
        left: r.left + l - o
    }
}
function $N(e, t) {
    const n = [];
    for (; e.previousElementSibling; ) {
        const r = e.previousElementSibling;
        t ? r.matches(t) && n.push(r) : n.push(r),
            e = r
    }
    return n
}
function FN(e, t) {
    const n = [];
    for (; e.nextElementSibling; ) {
        const r = e.nextElementSibling;
        t ? r.matches(t) && n.push(r) : n.push(r),
            e = r
    }
    return n
}
function ur(e, t) {
    return ot().getComputedStyle(e, null).getPropertyValue(t)
}
function Xs(e) {
    let t = e, n;
    if (t) {
        for (n = 0; (t = t.previousSibling) !== null; )
            t.nodeType === 1 && (n += 1);
        return n
    }
}
function Hr(e, t) {
    const n = [];
    let r = e.parentElement;
    for (; r; )
        t ? r.matches(t) && n.push(r) : n.push(r),
            r = r.parentElement;
    return n
}
function Ts(e, t) {
    function n(r) {
        r.target === e && (t.call(e, r),
            e.removeEventListener("transitionend", n))
    }
    t && e.addEventListener("transitionend", n)
}
function pu(e, t, n) {
    const r = ot();
    return n ? e[t === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(r.getComputedStyle(e, null).getPropertyValue(t === "width" ? "margin-right" : "margin-top")) + parseFloat(r.getComputedStyle(e, null).getPropertyValue(t === "width" ? "margin-left" : "margin-bottom")) : e.offsetWidth
}
let Gl;
function jN() {
    const e = ot()
        , t = Rt();
    return {
        smoothScroll: t.documentElement && t.documentElement.style && "scrollBehavior"in t.documentElement.style,
        touch: !!("ontouchstart"in e || e.DocumentTouch && t instanceof e.DocumentTouch)
    }
}
function B0() {
    return Gl || (Gl = jN()),
        Gl
}
let Xl;
function HN(e) {
    let {userAgent: t} = e === void 0 ? {} : e;
    const n = B0()
        , r = ot()
        , i = r.navigator.platform
        , s = t || r.navigator.userAgent
        , o = {
        ios: !1,
        android: !1
    }
        , a = r.screen.width
        , l = r.screen.height
        , c = s.match(/(Android);?[\s\/]+([\d.]+)?/);
    let u = s.match(/(iPad).*OS\s([\d_]+)/);
    const f = s.match(/(iPod)(.*OS\s([\d_]+))?/)
        , d = !u && s.match(/(iPhone\sOS|iOS)\s([\d_]+)/)
        , h = i === "Win32";
    let y = i === "MacIntel";
    const p = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
    return !u && y && n.touch && p.indexOf(`${a}x ${l}`) >= 0 && (u = s.match(/(Version)\/([\d.]+)/),
    u || (u = [0, 1, "13_0_0"]),
        y = !1),
    c && !h && (o.os = "android",
        o.android = !0),
    (u || d || f) && (o.os = "ios",
        o.ios = !0),
        o
}
function BN(e) {
    return e === void 0 && (e = {}),
    Xl || (Xl = HN(e)),
        Xl
}
let Kl;
function VN() {
    const e = ot();
    let t = !1;
    function n() {
        const r = e.navigator.userAgent.toLowerCase();
        return r.indexOf("safari") >= 0 && r.indexOf("chrome") < 0 && r.indexOf("android") < 0
    }
    if (n()) {
        const r = String(e.navigator.userAgent);
        if (r.includes("Version/")) {
            const [i,s] = r.split("Version/")[1].split(" ")[0].split(".").map(o=>Number(o));
            t = i < 16 || i === 16 && s < 2
        }
    }
    return {
        isSafari: t || n(),
        needPerspectiveFix: t,
        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent)
    }
}
function zN() {
    return Kl || (Kl = VN()),
        Kl
}
function UN(e) {
    let {swiper: t, on: n, emit: r} = e;
    const i = ot();
    let s = null
        , o = null;
    const a = ()=>{
            !t || t.destroyed || !t.initialized || (r("beforeResize"),
                r("resize"))
        }
        , l = ()=>{
            !t || t.destroyed || !t.initialized || (s = new ResizeObserver(f=>{
                    o = i.requestAnimationFrame(()=>{
                            const {width: d, height: h} = t;
                            let y = d
                                , p = h;
                            f.forEach(w=>{
                                    let {contentBoxSize: m, contentRect: g, target: b} = w;
                                    b && b !== t.el || (y = g ? g.width : (m[0] || m).inlineSize,
                                        p = g ? g.height : (m[0] || m).blockSize)
                                }
                            ),
                            (y !== d || p !== h) && a()
                        }
                    )
                }
            ),
                s.observe(t.el))
        }
        , c = ()=>{
            o && i.cancelAnimationFrame(o),
            s && s.unobserve && t.el && (s.unobserve(t.el),
                s = null)
        }
        , u = ()=>{
            !t || t.destroyed || !t.initialized || r("orientationchange")
        }
    ;
    n("init", ()=>{
            if (t.params.resizeObserver && typeof i.ResizeObserver < "u") {
                l();
                return
            }
            i.addEventListener("resize", a),
                i.addEventListener("orientationchange", u)
        }
    ),
        n("destroy", ()=>{
                c(),
                    i.removeEventListener("resize", a),
                    i.removeEventListener("orientationchange", u)
            }
        )
}
function WN(e) {
    let {swiper: t, extendParams: n, on: r, emit: i} = e;
    const s = []
        , o = ot()
        , a = function(u, f) {
            f === void 0 && (f = {});
            const d = o.MutationObserver || o.WebkitMutationObserver
                , h = new d(y=>{
                    if (t.__preventObserver__)
                        return;
                    if (y.length === 1) {
                        i("observerUpdate", y[0]);
                        return
                    }
                    const p = function() {
                        i("observerUpdate", y[0])
                    };
                    o.requestAnimationFrame ? o.requestAnimationFrame(p) : o.setTimeout(p, 0)
                }
            );
            h.observe(u, {
                attributes: typeof f.attributes > "u" ? !0 : f.attributes,
                childList: typeof f.childList > "u" ? !0 : f.childList,
                characterData: typeof f.characterData > "u" ? !0 : f.characterData
            }),
                s.push(h)
        }
        , l = ()=>{
            if (t.params.observer) {
                if (t.params.observeParents) {
                    const u = Hr(t.hostEl);
                    for (let f = 0; f < u.length; f += 1)
                        a(u[f])
                }
                a(t.hostEl, {
                    childList: t.params.observeSlideChildren
                }),
                    a(t.wrapperEl, {
                        attributes: !1
                    })
            }
        }
        , c = ()=>{
            s.forEach(u=>{
                    u.disconnect()
                }
            ),
                s.splice(0, s.length)
        }
    ;
    n({
        observer: !1,
        observeParents: !1,
        observeSlideChildren: !1
    }),
        r("init", l),
        r("destroy", c)
}
var GN = {
    on(e, t, n) {
        const r = this;
        if (!r.eventsListeners || r.destroyed || typeof t != "function")
            return r;
        const i = n ? "unshift" : "push";
        return e.split(" ").forEach(s=>{
                r.eventsListeners[s] || (r.eventsListeners[s] = []),
                    r.eventsListeners[s][i](t)
            }
        ),
            r
    },
    once(e, t, n) {
        const r = this;
        if (!r.eventsListeners || r.destroyed || typeof t != "function")
            return r;
        function i() {
            r.off(e, i),
            i.__emitterProxy && delete i.__emitterProxy;
            for (var s = arguments.length, o = new Array(s), a = 0; a < s; a++)
                o[a] = arguments[a];
            t.apply(r, o)
        }
        return i.__emitterProxy = t,
            r.on(e, i, n)
    },
    onAny(e, t) {
        const n = this;
        if (!n.eventsListeners || n.destroyed || typeof e != "function")
            return n;
        const r = t ? "unshift" : "push";
        return n.eventsAnyListeners.indexOf(e) < 0 && n.eventsAnyListeners[r](e),
            n
    },
    offAny(e) {
        const t = this;
        if (!t.eventsListeners || t.destroyed || !t.eventsAnyListeners)
            return t;
        const n = t.eventsAnyListeners.indexOf(e);
        return n >= 0 && t.eventsAnyListeners.splice(n, 1),
            t
    },
    off(e, t) {
        const n = this;
        return !n.eventsListeners || n.destroyed || !n.eventsListeners || e.split(" ").forEach(r=>{
                typeof t > "u" ? n.eventsListeners[r] = [] : n.eventsListeners[r] && n.eventsListeners[r].forEach((i,s)=>{
                        (i === t || i.__emitterProxy && i.__emitterProxy === t) && n.eventsListeners[r].splice(s, 1)
                    }
                )
            }
        ),
            n
    },
    emit() {
        const e = this;
        if (!e.eventsListeners || e.destroyed || !e.eventsListeners)
            return e;
        let t, n, r;
        for (var i = arguments.length, s = new Array(i), o = 0; o < i; o++)
            s[o] = arguments[o];
        return typeof s[0] == "string" || Array.isArray(s[0]) ? (t = s[0],
            n = s.slice(1, s.length),
            r = e) : (t = s[0].events,
            n = s[0].data,
            r = s[0].context || e),
            n.unshift(r),
            (Array.isArray(t) ? t : t.split(" ")).forEach(l=>{
                    e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach(c=>{
                            c.apply(r, [l, ...n])
                        }
                    ),
                    e.eventsListeners && e.eventsListeners[l] && e.eventsListeners[l].forEach(c=>{
                            c.apply(r, n)
                        }
                    )
                }
            ),
            e
    }
};
function XN() {
    const e = this;
    let t, n;
    const r = e.el;
    typeof e.params.width < "u" && e.params.width !== null ? t = e.params.width : t = r.clientWidth,
        typeof e.params.height < "u" && e.params.height !== null ? n = e.params.height : n = r.clientHeight,
    !(t === 0 && e.isHorizontal() || n === 0 && e.isVertical()) && (t = t - parseInt(ur(r, "padding-left") || 0, 10) - parseInt(ur(r, "padding-right") || 0, 10),
        n = n - parseInt(ur(r, "padding-top") || 0, 10) - parseInt(ur(r, "padding-bottom") || 0, 10),
    Number.isNaN(t) && (t = 0),
    Number.isNaN(n) && (n = 0),
        Object.assign(e, {
            width: t,
            height: n,
            size: e.isHorizontal() ? t : n
        }))
}
function KN() {
    const e = this;
    function t(L) {
        return e.isHorizontal() ? L : {
            width: "height",
            "margin-top": "margin-left",
            "margin-bottom ": "margin-right",
            "margin-left": "margin-top",
            "margin-right": "margin-bottom",
            "padding-left": "padding-top",
            "padding-right": "padding-bottom",
            marginRight: "marginBottom"
        }[L]
    }
    function n(L, x) {
        return parseFloat(L.getPropertyValue(t(x)) || 0)
    }
    const r = e.params
        , {wrapperEl: i, slidesEl: s, size: o, rtlTranslate: a, wrongRTL: l} = e
        , c = e.virtual && r.virtual.enabled
        , u = c ? e.virtual.slides.length : e.slides.length
        , f = xt(s, `.${e.params.slideClass}, swiper-slide`)
        , d = c ? e.virtual.slides.length : f.length;
    let h = [];
    const y = []
        , p = [];
    let w = r.slidesOffsetBefore;
    typeof w == "function" && (w = r.slidesOffsetBefore.call(e));
    let m = r.slidesOffsetAfter;
    typeof m == "function" && (m = r.slidesOffsetAfter.call(e));
    const g = e.snapGrid.length
        , b = e.slidesGrid.length;
    let v = r.spaceBetween
        , S = -w
        , _ = 0
        , E = 0;
    if (typeof o > "u")
        return;
    typeof v == "string" && v.indexOf("%") >= 0 ? v = parseFloat(v.replace("%", "")) / 100 * o : typeof v == "string" && (v = parseFloat(v)),
        e.virtualSize = -v,
        f.forEach(L=>{
                a ? L.style.marginLeft = "" : L.style.marginRight = "",
                    L.style.marginBottom = "",
                    L.style.marginTop = ""
            }
        ),
    r.centeredSlides && r.cssMode && (ps(i, "--swiper-centered-offset-before", ""),
        ps(i, "--swiper-centered-offset-after", ""));
    const T = r.grid && r.grid.rows > 1 && e.grid;
    T && e.grid.initSlides(d);
    let P;
    const I = r.slidesPerView === "auto" && r.breakpoints && Object.keys(r.breakpoints).filter(L=>typeof r.breakpoints[L].slidesPerView < "u").length > 0;
    for (let L = 0; L < d; L += 1) {
        P = 0;
        let x;
        if (f[L] && (x = f[L]),
        T && e.grid.updateSlide(L, x, d, t),
            !(f[L] && ur(x, "display") === "none")) {
            if (r.slidesPerView === "auto") {
                I && (f[L].style[t("width")] = "");
                const A = getComputedStyle(x)
                    , k = x.style.transform
                    , O = x.style.webkitTransform;
                if (k && (x.style.transform = "none"),
                O && (x.style.webkitTransform = "none"),
                    r.roundLengths)
                    P = e.isHorizontal() ? pu(x, "width", !0) : pu(x, "height", !0);
                else {
                    const N = n(A, "width")
                        , D = n(A, "padding-left")
                        , W = n(A, "padding-right")
                        , G = n(A, "margin-left")
                        , le = n(A, "margin-right")
                        , ge = A.getPropertyValue("box-sizing");
                    if (ge && ge === "border-box")
                        P = N + G + le;
                    else {
                        const {clientWidth: ye, offsetWidth: de} = x;
                        P = N + D + W + G + le + (de - ye)
                    }
                }
                k && (x.style.transform = k),
                O && (x.style.webkitTransform = O),
                r.roundLengths && (P = Math.floor(P))
            } else
                P = (o - (r.slidesPerView - 1) * v) / r.slidesPerView,
                r.roundLengths && (P = Math.floor(P)),
                f[L] && (f[L].style[t("width")] = `${P}px`);
            f[L] && (f[L].swiperSlideSize = P),
                p.push(P),
                r.centeredSlides ? (S = S + P / 2 + _ / 2 + v,
                _ === 0 && L !== 0 && (S = S - o / 2 - v),
                L === 0 && (S = S - o / 2 - v),
                Math.abs(S) < 1 / 1e3 && (S = 0),
                r.roundLengths && (S = Math.floor(S)),
                E % r.slidesPerGroup === 0 && h.push(S),
                    y.push(S)) : (r.roundLengths && (S = Math.floor(S)),
                (E - Math.min(e.params.slidesPerGroupSkip, E)) % e.params.slidesPerGroup === 0 && h.push(S),
                    y.push(S),
                    S = S + P + v),
                e.virtualSize += P + v,
                _ = P,
                E += 1
        }
    }
    if (e.virtualSize = Math.max(e.virtualSize, o) + m,
    a && l && (r.effect === "slide" || r.effect === "coverflow") && (i.style.width = `${e.virtualSize + v}px`),
    r.setWrapperSize && (i.style[t("width")] = `${e.virtualSize + v}px`),
    T && e.grid.updateWrapperSize(P, h, t),
        !r.centeredSlides) {
        const L = [];
        for (let x = 0; x < h.length; x += 1) {
            let A = h[x];
            r.roundLengths && (A = Math.floor(A)),
            h[x] <= e.virtualSize - o && L.push(A)
        }
        h = L,
        Math.floor(e.virtualSize - o) - Math.floor(h[h.length - 1]) > 1 && h.push(e.virtualSize - o)
    }
    if (c && r.loop) {
        const L = p[0] + v;
        if (r.slidesPerGroup > 1) {
            const x = Math.ceil((e.virtual.slidesBefore + e.virtual.slidesAfter) / r.slidesPerGroup)
                , A = L * r.slidesPerGroup;
            for (let k = 0; k < x; k += 1)
                h.push(h[h.length - 1] + A)
        }
        for (let x = 0; x < e.virtual.slidesBefore + e.virtual.slidesAfter; x += 1)
            r.slidesPerGroup === 1 && h.push(h[h.length - 1] + L),
                y.push(y[y.length - 1] + L),
                e.virtualSize += L
    }
    if (h.length === 0 && (h = [0]),
    v !== 0) {
        const L = e.isHorizontal() && a ? "marginLeft" : t("marginRight");
        f.filter((x,A)=>!r.cssMode || r.loop ? !0 : A !== f.length - 1).forEach(x=>{
                x.style[L] = `${v}px`
            }
        )
    }
    if (r.centeredSlides && r.centeredSlidesBounds) {
        let L = 0;
        p.forEach(A=>{
                L += A + (v || 0)
            }
        ),
            L -= v;
        const x = L - o;
        h = h.map(A=>A <= 0 ? -w : A > x ? x + m : A)
    }
    if (r.centerInsufficientSlides) {
        let L = 0;
        if (p.forEach(x=>{
                L += x + (v || 0)
            }
        ),
            L -= v,
        L < o) {
            const x = (o - L) / 2;
            h.forEach((A,k)=>{
                    h[k] = A - x
                }
            ),
                y.forEach((A,k)=>{
                        y[k] = A + x
                    }
                )
        }
    }
    if (Object.assign(e, {
        slides: f,
        snapGrid: h,
        slidesGrid: y,
        slidesSizesGrid: p
    }),
    r.centeredSlides && r.cssMode && !r.centeredSlidesBounds) {
        ps(i, "--swiper-centered-offset-before", `${-h[0]}px`),
            ps(i, "--swiper-centered-offset-after", `${e.size / 2 - p[p.length - 1] / 2}px`);
        const L = -e.snapGrid[0]
            , x = -e.slidesGrid[0];
        e.snapGrid = e.snapGrid.map(A=>A + L),
            e.slidesGrid = e.slidesGrid.map(A=>A + x)
    }
    if (d !== u && e.emit("slidesLengthChange"),
    h.length !== g && (e.params.watchOverflow && e.checkOverflow(),
        e.emit("snapGridLengthChange")),
    y.length !== b && e.emit("slidesGridLengthChange"),
    r.watchSlidesProgress && e.updateSlidesOffset(),
    !c && !r.cssMode && (r.effect === "slide" || r.effect === "fade")) {
        const L = `${r.containerModifierClass}backface-hidden`
            , x = e.el.classList.contains(L);
        d <= r.maxBackfaceHiddenSlides ? x || e.el.classList.add(L) : x && e.el.classList.remove(L)
    }
}
function YN(e) {
    const t = this
        , n = []
        , r = t.virtual && t.params.virtual.enabled;
    let i = 0, s;
    typeof e == "number" ? t.setTransition(e) : e === !0 && t.setTransition(t.params.speed);
    const o = a=>r ? t.slides[t.getSlideIndexByData(a)] : t.slides[a];
    if (t.params.slidesPerView !== "auto" && t.params.slidesPerView > 1)
        if (t.params.centeredSlides)
            (t.visibleSlides || []).forEach(a=>{
                    n.push(a)
                }
            );
        else
            for (s = 0; s < Math.ceil(t.params.slidesPerView); s += 1) {
                const a = t.activeIndex + s;
                if (a > t.slides.length && !r)
                    break;
                n.push(o(a))
            }
    else
        n.push(o(t.activeIndex));
    for (s = 0; s < n.length; s += 1)
        if (typeof n[s] < "u") {
            const a = n[s].offsetHeight;
            i = a > i ? a : i
        }
    (i || i === 0) && (t.wrapperEl.style.height = `${i}px`)
}
function qN() {
    const e = this
        , t = e.slides
        , n = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0;
    for (let r = 0; r < t.length; r += 1)
        t[r].swiperSlideOffset = (e.isHorizontal() ? t[r].offsetLeft : t[r].offsetTop) - n - e.cssOverflowAdjustment()
}
function JN(e) {
    e === void 0 && (e = this && this.translate || 0);
    const t = this
        , n = t.params
        , {slides: r, rtlTranslate: i, snapGrid: s} = t;
    if (r.length === 0)
        return;
    typeof r[0].swiperSlideOffset > "u" && t.updateSlidesOffset();
    let o = -e;
    i && (o = e),
        r.forEach(l=>{
                l.classList.remove(n.slideVisibleClass)
            }
        ),
        t.visibleSlidesIndexes = [],
        t.visibleSlides = [];
    let a = n.spaceBetween;
    typeof a == "string" && a.indexOf("%") >= 0 ? a = parseFloat(a.replace("%", "")) / 100 * t.size : typeof a == "string" && (a = parseFloat(a));
    for (let l = 0; l < r.length; l += 1) {
        const c = r[l];
        let u = c.swiperSlideOffset;
        n.cssMode && n.centeredSlides && (u -= r[0].swiperSlideOffset);
        const f = (o + (n.centeredSlides ? t.minTranslate() : 0) - u) / (c.swiperSlideSize + a)
            , d = (o - s[0] + (n.centeredSlides ? t.minTranslate() : 0) - u) / (c.swiperSlideSize + a)
            , h = -(o - u)
            , y = h + t.slidesSizesGrid[l];
        (h >= 0 && h < t.size - 1 || y > 1 && y <= t.size || h <= 0 && y >= t.size) && (t.visibleSlides.push(c),
            t.visibleSlidesIndexes.push(l),
            r[l].classList.add(n.slideVisibleClass)),
            c.progress = i ? -f : f,
            c.originalProgress = i ? -d : d
    }
}
function ZN(e) {
    const t = this;
    if (typeof e > "u") {
        const u = t.rtlTranslate ? -1 : 1;
        e = t && t.translate && t.translate * u || 0
    }
    const n = t.params
        , r = t.maxTranslate() - t.minTranslate();
    let {progress: i, isBeginning: s, isEnd: o, progressLoop: a} = t;
    const l = s
        , c = o;
    if (r === 0)
        i = 0,
            s = !0,
            o = !0;
    else {
        i = (e - t.minTranslate()) / r;
        const u = Math.abs(e - t.minTranslate()) < 1
            , f = Math.abs(e - t.maxTranslate()) < 1;
        s = u || i <= 0,
            o = f || i >= 1,
        u && (i = 0),
        f && (i = 1)
    }
    if (n.loop) {
        const u = t.getSlideIndexByData(0)
            , f = t.getSlideIndexByData(t.slides.length - 1)
            , d = t.slidesGrid[u]
            , h = t.slidesGrid[f]
            , y = t.slidesGrid[t.slidesGrid.length - 1]
            , p = Math.abs(e);
        p >= d ? a = (p - d) / y : a = (p + y - h) / y,
        a > 1 && (a -= 1)
    }
    Object.assign(t, {
        progress: i,
        progressLoop: a,
        isBeginning: s,
        isEnd: o
    }),
    (n.watchSlidesProgress || n.centeredSlides && n.autoHeight) && t.updateSlidesProgress(e),
    s && !l && t.emit("reachBeginning toEdge"),
    o && !c && t.emit("reachEnd toEdge"),
    (l && !s || c && !o) && t.emit("fromEdge"),
        t.emit("progress", i)
}
function QN() {
    const e = this
        , {slides: t, params: n, slidesEl: r, activeIndex: i} = e
        , s = e.virtual && n.virtual.enabled
        , o = l=>xt(r, `.${n.slideClass}${l}, swiper-slide ${l}`)[0];
    t.forEach(l=>{
            l.classList.remove(n.slideActiveClass, n.slideNextClass, n.slidePrevClass)
        }
    );
    let a;
    if (s)
        if (n.loop) {
            let l = i - e.virtual.slidesBefore;
            l < 0 && (l = e.virtual.slides.length + l),
            l >= e.virtual.slides.length && (l -= e.virtual.slides.length),
                a = o(`[data-swiper-slide-index="${l}"]`)
        } else
            a = o(`[data-swiper-slide-index="${i}"]`);
    else
        a = t[i];
    if (a) {
        a.classList.add(n.slideActiveClass);
        let l = FN(a, `.${n.slideClass}, swiper-slide`)[0];
        n.loop && !l && (l = t[0]),
        l && l.classList.add(n.slideNextClass);
        let c = $N(a, `.${n.slideClass}, swiper-slide`)[0];
        n.loop && !c === 0 && (c = t[t.length - 1]),
        c && c.classList.add(n.slidePrevClass)
    }
    e.emitSlidesClasses()
}
const qo = (e,t)=>{
        if (!e || e.destroyed || !e.params)
            return;
        const n = ()=>e.isElement ? "swiper-slide" : `.${e.params.slideClass}`
            , r = t.closest(n());
        if (r) {
            const i = r.querySelector(`.${e.params.lazyPreloaderClass}`);
            i && i.remove()
        }
    }
    , Yl = (e,t)=>{
        if (!e.slides[t])
            return;
        const n = e.slides[t].querySelector('[loading="lazy"]');
        n && n.removeAttribute("loading")
    }
    , hu = e=>{
        if (!e || e.destroyed || !e.params)
            return;
        let t = e.params.lazyPreloadPrevNext;
        const n = e.slides.length;
        if (!n || !t || t < 0)
            return;
        t = Math.min(t, n);
        const r = e.params.slidesPerView === "auto" ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView)
            , i = e.activeIndex;
        if (e.params.grid && e.params.grid.rows > 1) {
            const o = i
                , a = [o - t];
            a.push(...Array.from({
                length: t
            }).map((l,c)=>o + r + c)),
                e.slides.forEach((l,c)=>{
                        a.includes(l.column) && Yl(e, c)
                    }
                );
            return
        }
        const s = i + r - 1;
        if (e.params.rewind || e.params.loop)
            for (let o = i - t; o <= s + t; o += 1) {
                const a = (o % n + n) % n;
                (a < i || a > s) && Yl(e, a)
            }
        else
            for (let o = Math.max(i - t, 0); o <= Math.min(s + t, n - 1); o += 1)
                o !== i && (o > s || o < i) && Yl(e, o)
    }
;
function e$(e) {
    const {slidesGrid: t, params: n} = e
        , r = e.rtlTranslate ? e.translate : -e.translate;
    let i;
    for (let s = 0; s < t.length; s += 1)
        typeof t[s + 1] < "u" ? r >= t[s] && r < t[s + 1] - (t[s + 1] - t[s]) / 2 ? i = s : r >= t[s] && r < t[s + 1] && (i = s + 1) : r >= t[s] && (i = s);
    return n.normalizeSlideIndex && (i < 0 || typeof i > "u") && (i = 0),
        i
}
function t$(e) {
    const t = this
        , n = t.rtlTranslate ? t.translate : -t.translate
        , {snapGrid: r, params: i, activeIndex: s, realIndex: o, snapIndex: a} = t;
    let l = e, c;
    const u = d=>{
            let h = d - t.virtual.slidesBefore;
            return h < 0 && (h = t.virtual.slides.length + h),
            h >= t.virtual.slides.length && (h -= t.virtual.slides.length),
                h
        }
    ;
    if (typeof l > "u" && (l = e$(t)),
    r.indexOf(n) >= 0)
        c = r.indexOf(n);
    else {
        const d = Math.min(i.slidesPerGroupSkip, l);
        c = d + Math.floor((l - d) / i.slidesPerGroup)
    }
    if (c >= r.length && (c = r.length - 1),
    l === s) {
        c !== a && (t.snapIndex = c,
            t.emit("snapIndexChange")),
        t.params.loop && t.virtual && t.params.virtual.enabled && (t.realIndex = u(l));
        return
    }
    let f;
    t.virtual && i.virtual.enabled && i.loop ? f = u(l) : t.slides[l] ? f = parseInt(t.slides[l].getAttribute("data-swiper-slide-index") || l, 10) : f = l,
        Object.assign(t, {
            previousSnapIndex: a,
            snapIndex: c,
            previousRealIndex: o,
            realIndex: f,
            previousIndex: s,
            activeIndex: l
        }),
    t.initialized && hu(t),
        t.emit("activeIndexChange"),
        t.emit("snapIndexChange"),
    o !== f && t.emit("realIndexChange"),
    (t.initialized || t.params.runCallbacksOnInit) && t.emit("slideChange")
}
function n$(e) {
    const t = this
        , n = t.params
        , r = e.closest(`.${n.slideClass}, swiper-slide`);
    let i = !1, s;
    if (r) {
        for (let o = 0; o < t.slides.length; o += 1)
            if (t.slides[o] === r) {
                i = !0,
                    s = o;
                break
            }
    }
    if (r && i)
        t.clickedSlide = r,
            t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(r.getAttribute("data-swiper-slide-index"), 10) : t.clickedIndex = s;
    else {
        t.clickedSlide = void 0,
            t.clickedIndex = void 0;
        return
    }
    n.slideToClickedSlide && t.clickedIndex !== void 0 && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide()
}
var r$ = {
    updateSize: XN,
    updateSlides: KN,
    updateAutoHeight: YN,
    updateSlidesOffset: qN,
    updateSlidesProgress: JN,
    updateProgress: ZN,
    updateSlidesClasses: QN,
    updateActiveIndex: t$,
    updateClickedSlide: n$
};
function i$(e) {
    e === void 0 && (e = this.isHorizontal() ? "x" : "y");
    const t = this
        , {params: n, rtlTranslate: r, translate: i, wrapperEl: s} = t;
    if (n.virtualTranslate)
        return r ? -i : i;
    if (n.cssMode)
        return i;
    let o = du(s, e);
    return o += t.cssOverflowAdjustment(),
    r && (o = -o),
    o || 0
}
function s$(e, t) {
    const n = this
        , {rtlTranslate: r, params: i, wrapperEl: s, progress: o} = n;
    let a = 0
        , l = 0;
    const c = 0;
    n.isHorizontal() ? a = r ? -e : e : l = e,
    i.roundLengths && (a = Math.floor(a),
        l = Math.floor(l)),
        n.previousTranslate = n.translate,
        n.translate = n.isHorizontal() ? a : l,
        i.cssMode ? s[n.isHorizontal() ? "scrollLeft" : "scrollTop"] = n.isHorizontal() ? -a : -l : i.virtualTranslate || (n.isHorizontal() ? a -= n.cssOverflowAdjustment() : l -= n.cssOverflowAdjustment(),
            s.style.transform = `translate3d(${a}px, ${l}px, ${c}px)`);
    let u;
    const f = n.maxTranslate() - n.minTranslate();
    f === 0 ? u = 0 : u = (e - n.minTranslate()) / f,
    u !== o && n.updateProgress(e),
        n.emit("setTranslate", n.translate, t)
}
function o$() {
    return -this.snapGrid[0]
}
function a$() {
    return -this.snapGrid[this.snapGrid.length - 1]
}
function l$(e, t, n, r, i) {
    e === void 0 && (e = 0),
    t === void 0 && (t = this.params.speed),
    n === void 0 && (n = !0),
    r === void 0 && (r = !0);
    const s = this
        , {params: o, wrapperEl: a} = s;
    if (s.animating && o.preventInteractionOnTransition)
        return !1;
    const l = s.minTranslate()
        , c = s.maxTranslate();
    let u;
    if (r && e > l ? u = l : r && e < c ? u = c : u = e,
        s.updateProgress(u),
        o.cssMode) {
        const f = s.isHorizontal();
        if (t === 0)
            a[f ? "scrollLeft" : "scrollTop"] = -u;
        else {
            if (!s.support.smoothScroll)
                return H0({
                    swiper: s,
                    targetPosition: -u,
                    side: f ? "left" : "top"
                }),
                    !0;
            a.scrollTo({
                [f ? "left" : "top"]: -u,
                behavior: "smooth"
            })
        }
        return !0
    }
    return t === 0 ? (s.setTransition(0),
        s.setTranslate(u),
    n && (s.emit("beforeTransitionStart", t, i),
        s.emit("transitionEnd"))) : (s.setTransition(t),
        s.setTranslate(u),
    n && (s.emit("beforeTransitionStart", t, i),
        s.emit("transitionStart")),
    s.animating || (s.animating = !0,
    s.onTranslateToWrapperTransitionEnd || (s.onTranslateToWrapperTransitionEnd = function(d) {
            !s || s.destroyed || d.target === this && (s.wrapperEl.removeEventListener("transitionend", s.onTranslateToWrapperTransitionEnd),
                s.onTranslateToWrapperTransitionEnd = null,
                delete s.onTranslateToWrapperTransitionEnd,
            n && s.emit("transitionEnd"))
        }
    ),
        s.wrapperEl.addEventListener("transitionend", s.onTranslateToWrapperTransitionEnd))),
        !0
}
var c$ = {
    getTranslate: i$,
    setTranslate: s$,
    minTranslate: o$,
    maxTranslate: a$,
    translateTo: l$
};
function u$(e, t) {
    const n = this;
    n.params.cssMode || (n.wrapperEl.style.transitionDuration = `${e}ms`),
        n.emit("setTransition", e, t)
}
function V0(e) {
    let {swiper: t, runCallbacks: n, direction: r, step: i} = e;
    const {activeIndex: s, previousIndex: o} = t;
    let a = r;
    if (a || (s > o ? a = "next" : s < o ? a = "prev" : a = "reset"),
        t.emit(`transition ${i}`),
    n && s !== o) {
        if (a === "reset") {
            t.emit(`slideResetTransition ${i}`);
            return
        }
        t.emit(`slideChangeTransition ${i}`),
            a === "next" ? t.emit(`slideNextTransition ${i}`) : t.emit(`slidePrevTransition ${i}`)
    }
}
function f$(e, t) {
    e === void 0 && (e = !0);
    const n = this
        , {params: r} = n;
    r.cssMode || (r.autoHeight && n.updateAutoHeight(),
        V0({
            swiper: n,
            runCallbacks: e,
            direction: t,
            step: "Start"
        }))
}
function d$(e, t) {
    e === void 0 && (e = !0);
    const n = this
        , {params: r} = n;
    n.animating = !1,
    !r.cssMode && (n.setTransition(0),
        V0({
            swiper: n,
            runCallbacks: e,
            direction: t,
            step: "End"
        }))
}
var p$ = {
    setTransition: u$,
    transitionStart: f$,
    transitionEnd: d$
};
function h$(e, t, n, r, i) {
    e === void 0 && (e = 0),
    t === void 0 && (t = this.params.speed),
    n === void 0 && (n = !0),
    typeof e == "string" && (e = parseInt(e, 10));
    const s = this;
    let o = e;
    o < 0 && (o = 0);
    const {params: a, snapGrid: l, slidesGrid: c, previousIndex: u, activeIndex: f, rtlTranslate: d, wrapperEl: h, enabled: y} = s;
    if (s.animating && a.preventInteractionOnTransition || !y && !r && !i)
        return !1;
    const p = Math.min(s.params.slidesPerGroupSkip, o);
    let w = p + Math.floor((o - p) / s.params.slidesPerGroup);
    w >= l.length && (w = l.length - 1);
    const m = -l[w];
    if (a.normalizeSlideIndex)
        for (let b = 0; b < c.length; b += 1) {
            const v = -Math.floor(m * 100)
                , S = Math.floor(c[b] * 100)
                , _ = Math.floor(c[b + 1] * 100);
            typeof c[b + 1] < "u" ? v >= S && v < _ - (_ - S) / 2 ? o = b : v >= S && v < _ && (o = b + 1) : v >= S && (o = b)
        }
    if (s.initialized && o !== f && (!s.allowSlideNext && (d ? m > s.translate && m > s.minTranslate() : m < s.translate && m < s.minTranslate()) || !s.allowSlidePrev && m > s.translate && m > s.maxTranslate() && (f || 0) !== o))
        return !1;
    o !== (u || 0) && n && s.emit("beforeSlideChangeStart"),
        s.updateProgress(m);
    let g;
    if (o > f ? g = "next" : o < f ? g = "prev" : g = "reset",
    d && -m === s.translate || !d && m === s.translate)
        return s.updateActiveIndex(o),
        a.autoHeight && s.updateAutoHeight(),
            s.updateSlidesClasses(),
        a.effect !== "slide" && s.setTranslate(m),
        g !== "reset" && (s.transitionStart(n, g),
            s.transitionEnd(n, g)),
            !1;
    if (a.cssMode) {
        const b = s.isHorizontal()
            , v = d ? m : -m;
        if (t === 0) {
            const S = s.virtual && s.params.virtual.enabled;
            S && (s.wrapperEl.style.scrollSnapType = "none",
                s._immediateVirtual = !0),
                S && !s._cssModeVirtualInitialSet && s.params.initialSlide > 0 ? (s._cssModeVirtualInitialSet = !0,
                    requestAnimationFrame(()=>{
                            h[b ? "scrollLeft" : "scrollTop"] = v
                        }
                    )) : h[b ? "scrollLeft" : "scrollTop"] = v,
            S && requestAnimationFrame(()=>{
                    s.wrapperEl.style.scrollSnapType = "",
                        s._immediateVirtual = !1
                }
            )
        } else {
            if (!s.support.smoothScroll)
                return H0({
                    swiper: s,
                    targetPosition: v,
                    side: b ? "left" : "top"
                }),
                    !0;
            h.scrollTo({
                [b ? "left" : "top"]: v,
                behavior: "smooth"
            })
        }
        return !0
    }
    return s.setTransition(t),
        s.setTranslate(m),
        s.updateActiveIndex(o),
        s.updateSlidesClasses(),
        s.emit("beforeTransitionStart", t, r),
        s.transitionStart(n, g),
        t === 0 ? s.transitionEnd(n, g) : s.animating || (s.animating = !0,
        s.onSlideToWrapperTransitionEnd || (s.onSlideToWrapperTransitionEnd = function(v) {
                !s || s.destroyed || v.target === this && (s.wrapperEl.removeEventListener("transitionend", s.onSlideToWrapperTransitionEnd),
                    s.onSlideToWrapperTransitionEnd = null,
                    delete s.onSlideToWrapperTransitionEnd,
                    s.transitionEnd(n, g))
            }
        ),
            s.wrapperEl.addEventListener("transitionend", s.onSlideToWrapperTransitionEnd)),
        !0
}
function m$(e, t, n, r) {
    e === void 0 && (e = 0),
    t === void 0 && (t = this.params.speed),
    n === void 0 && (n = !0),
    typeof e == "string" && (e = parseInt(e, 10));
    const i = this;
    let s = e;
    return i.params.loop && (i.virtual && i.params.virtual.enabled ? s = s + i.virtual.slidesBefore : s = i.getSlideIndexByData(s)),
        i.slideTo(s, t, n, r)
}
function g$(e, t, n) {
    e === void 0 && (e = this.params.speed),
    t === void 0 && (t = !0);
    const r = this
        , {enabled: i, params: s, animating: o} = r;
    if (!i)
        return r;
    let a = s.slidesPerGroup;
    s.slidesPerView === "auto" && s.slidesPerGroup === 1 && s.slidesPerGroupAuto && (a = Math.max(r.slidesPerViewDynamic("current", !0), 1));
    const l = r.activeIndex < s.slidesPerGroupSkip ? 1 : a
        , c = r.virtual && s.virtual.enabled;
    if (s.loop) {
        if (o && !c && s.loopPreventsSliding)
            return !1;
        r.loopFix({
            direction: "next"
        }),
            r._clientLeft = r.wrapperEl.clientLeft
    }
    return s.rewind && r.isEnd ? r.slideTo(0, e, t, n) : r.slideTo(r.activeIndex + l, e, t, n)
}
function v$(e, t, n) {
    e === void 0 && (e = this.params.speed),
    t === void 0 && (t = !0);
    const r = this
        , {params: i, snapGrid: s, slidesGrid: o, rtlTranslate: a, enabled: l, animating: c} = r;
    if (!l)
        return r;
    const u = r.virtual && i.virtual.enabled;
    if (i.loop) {
        if (c && !u && i.loopPreventsSliding)
            return !1;
        r.loopFix({
            direction: "prev"
        }),
            r._clientLeft = r.wrapperEl.clientLeft
    }
    const f = a ? r.translate : -r.translate;
    function d(m) {
        return m < 0 ? -Math.floor(Math.abs(m)) : Math.floor(m)
    }
    const h = d(f)
        , y = s.map(m=>d(m));
    let p = s[y.indexOf(h) - 1];
    if (typeof p > "u" && i.cssMode) {
        let m;
        s.forEach((g,b)=>{
                h >= g && (m = b)
            }
        ),
        typeof m < "u" && (p = s[m > 0 ? m - 1 : m])
    }
    let w = 0;
    if (typeof p < "u" && (w = o.indexOf(p),
    w < 0 && (w = r.activeIndex - 1),
    i.slidesPerView === "auto" && i.slidesPerGroup === 1 && i.slidesPerGroupAuto && (w = w - r.slidesPerViewDynamic("previous", !0) + 1,
        w = Math.max(w, 0))),
    i.rewind && r.isBeginning) {
        const m = r.params.virtual && r.params.virtual.enabled && r.virtual ? r.virtual.slides.length - 1 : r.slides.length - 1;
        return r.slideTo(m, e, t, n)
    }
    return r.slideTo(w, e, t, n)
}
function y$(e, t, n) {
    e === void 0 && (e = this.params.speed),
    t === void 0 && (t = !0);
    const r = this;
    return r.slideTo(r.activeIndex, e, t, n)
}
function b$(e, t, n, r) {
    e === void 0 && (e = this.params.speed),
    t === void 0 && (t = !0),
    r === void 0 && (r = .5);
    const i = this;
    let s = i.activeIndex;
    const o = Math.min(i.params.slidesPerGroupSkip, s)
        , a = o + Math.floor((s - o) / i.params.slidesPerGroup)
        , l = i.rtlTranslate ? i.translate : -i.translate;
    if (l >= i.snapGrid[a]) {
        const c = i.snapGrid[a]
            , u = i.snapGrid[a + 1];
        l - c > (u - c) * r && (s += i.params.slidesPerGroup)
    } else {
        const c = i.snapGrid[a - 1]
            , u = i.snapGrid[a];
        l - c <= (u - c) * r && (s -= i.params.slidesPerGroup)
    }
    return s = Math.max(s, 0),
        s = Math.min(s, i.slidesGrid.length - 1),
        i.slideTo(s, e, t, n)
}
function w$() {
    const e = this
        , {params: t, slidesEl: n} = e
        , r = t.slidesPerView === "auto" ? e.slidesPerViewDynamic() : t.slidesPerView;
    let i = e.clickedIndex, s;
    const o = e.isElement ? "swiper-slide" : `.${t.slideClass}`;
    if (t.loop) {
        if (e.animating)
            return;
        s = parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10),
            t.centeredSlides ? i < e.loopedSlides - r / 2 || i > e.slides.length - e.loopedSlides + r / 2 ? (e.loopFix(),
                i = e.getSlideIndex(xt(n, `${o}[data-swiper-slide-index="${s}"]`)[0]),
                Kr(()=>{
                        e.slideTo(i)
                    }
                )) : e.slideTo(i) : i > e.slides.length - r ? (e.loopFix(),
                i = e.getSlideIndex(xt(n, `${o}[data-swiper-slide-index="${s}"]`)[0]),
                Kr(()=>{
                        e.slideTo(i)
                    }
                )) : e.slideTo(i)
    } else
        e.slideTo(i)
}
var S$ = {
    slideTo: h$,
    slideToLoop: m$,
    slideNext: g$,
    slidePrev: v$,
    slideReset: y$,
    slideToClosest: b$,
    slideToClickedSlide: w$
};
function _$(e) {
    const t = this
        , {params: n, slidesEl: r} = t;
    if (!n.loop || t.virtual && t.params.virtual.enabled)
        return;
    xt(r, `.${n.slideClass}, swiper-slide`).forEach((s,o)=>{
            s.setAttribute("data-swiper-slide-index", o)
        }
    ),
        t.loopFix({
            slideRealIndex: e,
            direction: n.centeredSlides ? void 0 : "next"
        })
}
function E$(e) {
    let {slideRealIndex: t, slideTo: n=!0, direction: r, setTranslate: i, activeSlideIndex: s, byController: o, byMousewheel: a} = e === void 0 ? {} : e;
    const l = this;
    if (!l.params.loop)
        return;
    l.emit("beforeLoopFix");
    const {slides: c, allowSlidePrev: u, allowSlideNext: f, slidesEl: d, params: h} = l;
    if (l.allowSlidePrev = !0,
        l.allowSlideNext = !0,
    l.virtual && h.virtual.enabled) {
        n && (!h.centeredSlides && l.snapIndex === 0 ? l.slideTo(l.virtual.slides.length, 0, !1, !0) : h.centeredSlides && l.snapIndex < h.slidesPerView ? l.slideTo(l.virtual.slides.length + l.snapIndex, 0, !1, !0) : l.snapIndex === l.snapGrid.length - 1 && l.slideTo(l.virtual.slidesBefore, 0, !1, !0)),
            l.allowSlidePrev = u,
            l.allowSlideNext = f,
            l.emit("loopFix");
        return
    }
    const y = h.slidesPerView === "auto" ? l.slidesPerViewDynamic() : Math.ceil(parseFloat(h.slidesPerView, 10));
    let p = h.loopedSlides || y;
    p % h.slidesPerGroup !== 0 && (p += h.slidesPerGroup - p % h.slidesPerGroup),
        l.loopedSlides = p;
    const w = []
        , m = [];
    let g = l.activeIndex;
    typeof s > "u" ? s = l.getSlideIndex(l.slides.filter(E=>E.classList.contains(h.slideActiveClass))[0]) : g = s;
    const b = r === "next" || !r
        , v = r === "prev" || !r;
    let S = 0
        , _ = 0;
    if (s < p) {
        S = Math.max(p - s, h.slidesPerGroup);
        for (let E = 0; E < p - s; E += 1) {
            const T = E - Math.floor(E / c.length) * c.length;
            w.push(c.length - T - 1)
        }
    } else if (s > l.slides.length - p * 2) {
        _ = Math.max(s - (l.slides.length - p * 2), h.slidesPerGroup);
        for (let E = 0; E < _; E += 1) {
            const T = E - Math.floor(E / c.length) * c.length;
            m.push(T)
        }
    }
    if (v && w.forEach(E=>{
            l.slides[E].swiperLoopMoveDOM = !0,
                d.prepend(l.slides[E]),
                l.slides[E].swiperLoopMoveDOM = !1
        }
    ),
    b && m.forEach(E=>{
            l.slides[E].swiperLoopMoveDOM = !0,
                d.append(l.slides[E]),
                l.slides[E].swiperLoopMoveDOM = !1
        }
    ),
        l.recalcSlides(),
    h.slidesPerView === "auto" && l.updateSlides(),
    h.watchSlidesProgress && l.updateSlidesOffset(),
        n) {
        if (w.length > 0 && v)
            if (typeof t > "u") {
                const E = l.slidesGrid[g]
                    , P = l.slidesGrid[g + S] - E;
                a ? l.setTranslate(l.translate - P) : (l.slideTo(g + S, 0, !1, !0),
                i && (l.touches[l.isHorizontal() ? "startX" : "startY"] += P,
                    l.touchEventsData.currentTranslate = l.translate))
            } else
                i && (l.slideToLoop(t, 0, !1, !0),
                    l.touchEventsData.currentTranslate = l.translate);
        else if (m.length > 0 && b)
            if (typeof t > "u") {
                const E = l.slidesGrid[g]
                    , P = l.slidesGrid[g - _] - E;
                a ? l.setTranslate(l.translate - P) : (l.slideTo(g - _, 0, !1, !0),
                i && (l.touches[l.isHorizontal() ? "startX" : "startY"] += P,
                    l.touchEventsData.currentTranslate = l.translate))
            } else
                l.slideToLoop(t, 0, !1, !0)
    }
    if (l.allowSlidePrev = u,
        l.allowSlideNext = f,
    l.controller && l.controller.control && !o) {
        const E = {
            slideRealIndex: t,
            slideTo: !1,
            direction: r,
            setTranslate: i,
            activeSlideIndex: s,
            byController: !0
        };
        Array.isArray(l.controller.control) ? l.controller.control.forEach(T=>{
                !T.destroyed && T.params.loop && T.loopFix(E)
            }
        ) : l.controller.control instanceof l.constructor && l.controller.control.params.loop && l.controller.control.loopFix(E)
    }
    l.emit("loopFix")
}
function C$() {
    const e = this
        , {params: t, slidesEl: n} = e;
    if (!t.loop || e.virtual && e.params.virtual.enabled)
        return;
    e.recalcSlides();
    const r = [];
    e.slides.forEach(i=>{
            const s = typeof i.swiperSlideIndex > "u" ? i.getAttribute("data-swiper-slide-index") * 1 : i.swiperSlideIndex;
            r[s] = i
        }
    ),
        e.slides.forEach(i=>{
                i.removeAttribute("data-swiper-slide-index")
            }
        ),
        r.forEach(i=>{
                n.append(i)
            }
        ),
        e.recalcSlides(),
        e.slideTo(e.realIndex, 0)
}
var T$ = {
    loopCreate: _$,
    loopFix: E$,
    loopDestroy: C$
};
function x$(e) {
    const t = this;
    if (!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode)
        return;
    const n = t.params.touchEventsTarget === "container" ? t.el : t.wrapperEl;
    t.isElement && (t.__preventObserver__ = !0),
        n.style.cursor = "move",
        n.style.cursor = e ? "grabbing" : "grab",
    t.isElement && requestAnimationFrame(()=>{
            t.__preventObserver__ = !1
        }
    )
}
function P$() {
    const e = this;
    e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0),
        e[e.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "",
    e.isElement && requestAnimationFrame(()=>{
            e.__preventObserver__ = !1
        }
    ))
}
var k$ = {
    setGrabCursor: x$,
    unsetGrabCursor: P$
};
function R$(e, t) {
    t === void 0 && (t = this);
    function n(r) {
        if (!r || r === Rt() || r === ot())
            return null;
        r.assignedSlot && (r = r.assignedSlot);
        const i = r.closest(e);
        return !i && !r.getRootNode ? null : i || n(r.getRootNode().host)
    }
    return n(t)
}
function L$(e) {
    const t = this
        , n = Rt()
        , r = ot()
        , i = t.touchEventsData;
    i.evCache.push(e);
    const {params: s, touches: o, enabled: a} = t;
    if (!a || !s.simulateTouch && e.pointerType === "mouse" || t.animating && s.preventInteractionOnTransition)
        return;
    !t.animating && s.cssMode && s.loop && t.loopFix();
    let l = e;
    l.originalEvent && (l = l.originalEvent);
    let c = l.target;
    if (s.touchEventsTarget === "wrapper" && !t.wrapperEl.contains(c) || "which"in l && l.which === 3 || "button"in l && l.button > 0 || i.isTouched && i.isMoved)
        return;
    const u = !!s.noSwipingClass && s.noSwipingClass !== ""
        , f = e.composedPath ? e.composedPath() : e.path;
    u && l.target && l.target.shadowRoot && f && (c = f[0]);
    const d = s.noSwipingSelector ? s.noSwipingSelector : `.${s.noSwipingClass}`
        , h = !!(l.target && l.target.shadowRoot);
    if (s.noSwiping && (h ? R$(d, c) : c.closest(d))) {
        t.allowClick = !0;
        return
    }
    if (s.swipeHandler && !c.closest(s.swipeHandler))
        return;
    o.currentX = l.pageX,
        o.currentY = l.pageY;
    const y = o.currentX
        , p = o.currentY
        , w = s.edgeSwipeDetection || s.iOSEdgeSwipeDetection
        , m = s.edgeSwipeThreshold || s.iOSEdgeSwipeThreshold;
    if (w && (y <= m || y >= r.innerWidth - m))
        if (w === "prevent")
            e.preventDefault();
        else
            return;
    Object.assign(i, {
        isTouched: !0,
        isMoved: !1,
        allowTouchCallbacks: !0,
        isScrolling: void 0,
        startMoving: void 0
    }),
        o.startX = y,
        o.startY = p,
        i.touchStartTime = un(),
        t.allowClick = !0,
        t.updateSize(),
        t.swipeDirection = void 0,
    s.threshold > 0 && (i.allowThresholdMove = !1);
    let g = !0;
    c.matches(i.focusableElements) && (g = !1,
    c.nodeName === "SELECT" && (i.isTouched = !1)),
    n.activeElement && n.activeElement.matches(i.focusableElements) && n.activeElement !== c && n.activeElement.blur();
    const b = g && t.allowTouchMove && s.touchStartPreventDefault;
    (s.touchStartForcePreventDefault || b) && !c.isContentEditable && l.preventDefault(),
    s.freeMode && s.freeMode.enabled && t.freeMode && t.animating && !s.cssMode && t.freeMode.onTouchStart(),
        t.emit("touchStart", l)
}
function O$(e) {
    const t = Rt()
        , n = this
        , r = n.touchEventsData
        , {params: i, touches: s, rtlTranslate: o, enabled: a} = n;
    if (!a || !i.simulateTouch && e.pointerType === "mouse")
        return;
    let l = e;
    if (l.originalEvent && (l = l.originalEvent),
        !r.isTouched) {
        r.startMoving && r.isScrolling && n.emit("touchMoveOpposite", l);
        return
    }
    const c = r.evCache.findIndex(_=>_.pointerId === l.pointerId);
    c >= 0 && (r.evCache[c] = l);
    const u = r.evCache.length > 1 ? r.evCache[0] : l
        , f = u.pageX
        , d = u.pageY;
    if (l.preventedByNestedSwiper) {
        s.startX = f,
            s.startY = d;
        return
    }
    if (!n.allowTouchMove) {
        l.target.matches(r.focusableElements) || (n.allowClick = !1),
        r.isTouched && (Object.assign(s, {
            startX: f,
            startY: d,
            prevX: n.touches.currentX,
            prevY: n.touches.currentY,
            currentX: f,
            currentY: d
        }),
            r.touchStartTime = un());
        return
    }
    if (i.touchReleaseOnEdges && !i.loop) {
        if (n.isVertical()) {
            if (d < s.startY && n.translate <= n.maxTranslate() || d > s.startY && n.translate >= n.minTranslate()) {
                r.isTouched = !1,
                    r.isMoved = !1;
                return
            }
        } else if (f < s.startX && n.translate <= n.maxTranslate() || f > s.startX && n.translate >= n.minTranslate())
            return
    }
    if (t.activeElement && l.target === t.activeElement && l.target.matches(r.focusableElements)) {
        r.isMoved = !0,
            n.allowClick = !1;
        return
    }
    if (r.allowTouchCallbacks && n.emit("touchMove", l),
    l.targetTouches && l.targetTouches.length > 1)
        return;
    s.currentX = f,
        s.currentY = d;
    const h = s.currentX - s.startX
        , y = s.currentY - s.startY;
    if (n.params.threshold && Math.sqrt(h ** 2 + y ** 2) < n.params.threshold)
        return;
    if (typeof r.isScrolling > "u") {
        let _;
        n.isHorizontal() && s.currentY === s.startY || n.isVertical() && s.currentX === s.startX ? r.isScrolling = !1 : h * h + y * y >= 25 && (_ = Math.atan2(Math.abs(y), Math.abs(h)) * 180 / Math.PI,
            r.isScrolling = n.isHorizontal() ? _ > i.touchAngle : 90 - _ > i.touchAngle)
    }
    if (r.isScrolling && n.emit("touchMoveOpposite", l),
    typeof r.startMoving > "u" && (s.currentX !== s.startX || s.currentY !== s.startY) && (r.startMoving = !0),
    r.isScrolling || n.zoom && n.params.zoom && n.params.zoom.enabled && r.evCache.length > 1) {
        r.isTouched = !1;
        return
    }
    if (!r.startMoving)
        return;
    n.allowClick = !1,
    !i.cssMode && l.cancelable && l.preventDefault(),
    i.touchMoveStopPropagation && !i.nested && l.stopPropagation();
    let p = n.isHorizontal() ? h : y
        , w = n.isHorizontal() ? s.currentX - s.previousX : s.currentY - s.previousY;
    i.oneWayMovement && (p = Math.abs(p) * (o ? 1 : -1),
        w = Math.abs(w) * (o ? 1 : -1)),
        s.diff = p,
        p *= i.touchRatio,
    o && (p = -p,
        w = -w);
    const m = n.touchesDirection;
    n.swipeDirection = p > 0 ? "prev" : "next",
        n.touchesDirection = w > 0 ? "prev" : "next";
    const g = n.params.loop && !i.cssMode;
    if (!r.isMoved) {
        if (g && n.loopFix({
            direction: n.swipeDirection
        }),
            r.startTranslate = n.getTranslate(),
            n.setTransition(0),
            n.animating) {
            const _ = new window.CustomEvent("transitionend",{
                bubbles: !0,
                cancelable: !0
            });
            n.wrapperEl.dispatchEvent(_)
        }
        r.allowMomentumBounce = !1,
        i.grabCursor && (n.allowSlideNext === !0 || n.allowSlidePrev === !0) && n.setGrabCursor(!0),
            n.emit("sliderFirstMove", l)
    }
    let b;
    r.isMoved && m !== n.touchesDirection && g && Math.abs(p) >= 1 && (n.loopFix({
        direction: n.swipeDirection,
        setTranslate: !0
    }),
        b = !0),
        n.emit("sliderMove", l),
        r.isMoved = !0,
        r.currentTranslate = p + r.startTranslate;
    let v = !0
        , S = i.resistanceRatio;
    if (i.touchReleaseOnEdges && (S = 0),
        p > 0 ? (g && !b && r.currentTranslate > (i.centeredSlides ? n.minTranslate() - n.size / 2 : n.minTranslate()) && n.loopFix({
            direction: "prev",
            setTranslate: !0,
            activeSlideIndex: 0
        }),
        r.currentTranslate > n.minTranslate() && (v = !1,
        i.resistance && (r.currentTranslate = n.minTranslate() - 1 + (-n.minTranslate() + r.startTranslate + p) ** S))) : p < 0 && (g && !b && r.currentTranslate < (i.centeredSlides ? n.maxTranslate() + n.size / 2 : n.maxTranslate()) && n.loopFix({
            direction: "next",
            setTranslate: !0,
            activeSlideIndex: n.slides.length - (i.slidesPerView === "auto" ? n.slidesPerViewDynamic() : Math.ceil(parseFloat(i.slidesPerView, 10)))
        }),
        r.currentTranslate < n.maxTranslate() && (v = !1,
        i.resistance && (r.currentTranslate = n.maxTranslate() + 1 - (n.maxTranslate() - r.startTranslate - p) ** S))),
    v && (l.preventedByNestedSwiper = !0),
    !n.allowSlideNext && n.swipeDirection === "next" && r.currentTranslate < r.startTranslate && (r.currentTranslate = r.startTranslate),
    !n.allowSlidePrev && n.swipeDirection === "prev" && r.currentTranslate > r.startTranslate && (r.currentTranslate = r.startTranslate),
    !n.allowSlidePrev && !n.allowSlideNext && (r.currentTranslate = r.startTranslate),
    i.threshold > 0)
        if (Math.abs(p) > i.threshold || r.allowThresholdMove) {
            if (!r.allowThresholdMove) {
                r.allowThresholdMove = !0,
                    s.startX = s.currentX,
                    s.startY = s.currentY,
                    r.currentTranslate = r.startTranslate,
                    s.diff = n.isHorizontal() ? s.currentX - s.startX : s.currentY - s.startY;
                return
            }
        } else {
            r.currentTranslate = r.startTranslate;
            return
        }
    !i.followFinger || i.cssMode || ((i.freeMode && i.freeMode.enabled && n.freeMode || i.watchSlidesProgress) && (n.updateActiveIndex(),
        n.updateSlidesClasses()),
    i.freeMode && i.freeMode.enabled && n.freeMode && n.freeMode.onTouchMove(),
        n.updateProgress(r.currentTranslate),
        n.setTranslate(r.currentTranslate))
}
function A$(e) {
    const t = this
        , n = t.touchEventsData
        , r = n.evCache.findIndex(b=>b.pointerId === e.pointerId);
    if (r >= 0 && n.evCache.splice(r, 1),
    ["pointercancel", "pointerout", "pointerleave"].includes(e.type) && !(e.type === "pointercancel" && (t.browser.isSafari || t.browser.isWebView)))
        return;
    const {params: i, touches: s, rtlTranslate: o, slidesGrid: a, enabled: l} = t;
    if (!l || !i.simulateTouch && e.pointerType === "mouse")
        return;
    let c = e;
    if (c.originalEvent && (c = c.originalEvent),
    n.allowTouchCallbacks && t.emit("touchEnd", c),
        n.allowTouchCallbacks = !1,
        !n.isTouched) {
        n.isMoved && i.grabCursor && t.setGrabCursor(!1),
            n.isMoved = !1,
            n.startMoving = !1;
        return
    }
    i.grabCursor && n.isMoved && n.isTouched && (t.allowSlideNext === !0 || t.allowSlidePrev === !0) && t.setGrabCursor(!1);
    const u = un()
        , f = u - n.touchStartTime;
    if (t.allowClick) {
        const b = c.path || c.composedPath && c.composedPath();
        t.updateClickedSlide(b && b[0] || c.target),
            t.emit("tap click", c),
        f < 300 && u - n.lastClickTime < 300 && t.emit("doubleTap doubleClick", c)
    }
    if (n.lastClickTime = un(),
        Kr(()=>{
                t.destroyed || (t.allowClick = !0)
            }
        ),
    !n.isTouched || !n.isMoved || !t.swipeDirection || s.diff === 0 || n.currentTranslate === n.startTranslate) {
        n.isTouched = !1,
            n.isMoved = !1,
            n.startMoving = !1;
        return
    }
    n.isTouched = !1,
        n.isMoved = !1,
        n.startMoving = !1;
    let d;
    if (i.followFinger ? d = o ? t.translate : -t.translate : d = -n.currentTranslate,
        i.cssMode)
        return;
    if (i.freeMode && i.freeMode.enabled) {
        t.freeMode.onTouchEnd({
            currentPos: d
        });
        return
    }
    let h = 0
        , y = t.slidesSizesGrid[0];
    for (let b = 0; b < a.length; b += b < i.slidesPerGroupSkip ? 1 : i.slidesPerGroup) {
        const v = b < i.slidesPerGroupSkip - 1 ? 1 : i.slidesPerGroup;
        typeof a[b + v] < "u" ? d >= a[b] && d < a[b + v] && (h = b,
            y = a[b + v] - a[b]) : d >= a[b] && (h = b,
            y = a[a.length - 1] - a[a.length - 2])
    }
    let p = null
        , w = null;
    i.rewind && (t.isBeginning ? w = i.virtual && i.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (p = 0));
    const m = (d - a[h]) / y
        , g = h < i.slidesPerGroupSkip - 1 ? 1 : i.slidesPerGroup;
    if (f > i.longSwipesMs) {
        if (!i.longSwipes) {
            t.slideTo(t.activeIndex);
            return
        }
        t.swipeDirection === "next" && (m >= i.longSwipesRatio ? t.slideTo(i.rewind && t.isEnd ? p : h + g) : t.slideTo(h)),
        t.swipeDirection === "prev" && (m > 1 - i.longSwipesRatio ? t.slideTo(h + g) : w !== null && m < 0 && Math.abs(m) > i.longSwipesRatio ? t.slideTo(w) : t.slideTo(h))
    } else {
        if (!i.shortSwipes) {
            t.slideTo(t.activeIndex);
            return
        }
        t.navigation && (c.target === t.navigation.nextEl || c.target === t.navigation.prevEl) ? c.target === t.navigation.nextEl ? t.slideTo(h + g) : t.slideTo(h) : (t.swipeDirection === "next" && t.slideTo(p !== null ? p : h + g),
        t.swipeDirection === "prev" && t.slideTo(w !== null ? w : h))
    }
}
function ym() {
    const e = this
        , {params: t, el: n} = e;
    if (n && n.offsetWidth === 0)
        return;
    t.breakpoints && e.setBreakpoint();
    const {allowSlideNext: r, allowSlidePrev: i, snapGrid: s} = e
        , o = e.virtual && e.params.virtual.enabled;
    e.allowSlideNext = !0,
        e.allowSlidePrev = !0,
        e.updateSize(),
        e.updateSlides(),
        e.updateSlidesClasses();
    const a = o && t.loop;
    (t.slidesPerView === "auto" || t.slidesPerView > 1) && e.isEnd && !e.isBeginning && !e.params.centeredSlides && !a ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.params.loop && !o ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0),
    e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout),
        e.autoplay.resizeTimeout = setTimeout(()=>{
                e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume()
            }
            , 500)),
        e.allowSlidePrev = i,
        e.allowSlideNext = r,
    e.params.watchOverflow && s !== e.snapGrid && e.checkOverflow()
}
function I$(e) {
    const t = this;
    t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(),
    t.params.preventClicksPropagation && t.animating && (e.stopPropagation(),
        e.stopImmediatePropagation())))
}
function M$() {
    const e = this
        , {wrapperEl: t, rtlTranslate: n, enabled: r} = e;
    if (!r)
        return;
    e.previousTranslate = e.translate,
        e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop,
    e.translate === 0 && (e.translate = 0),
        e.updateActiveIndex(),
        e.updateSlidesClasses();
    let i;
    const s = e.maxTranslate() - e.minTranslate();
    s === 0 ? i = 0 : i = (e.translate - e.minTranslate()) / s,
    i !== e.progress && e.updateProgress(n ? -e.translate : e.translate),
        e.emit("setTranslate", e.translate, !1)
}
function D$(e) {
    const t = this;
    qo(t, e.target),
    !(t.params.cssMode || t.params.slidesPerView !== "auto" && !t.params.autoHeight) && t.update()
}
let bm = !1;
function N$() {}
const z0 = (e,t)=>{
        const n = Rt()
            , {params: r, el: i, wrapperEl: s, device: o} = e
            , a = !!r.nested
            , l = t === "on" ? "addEventListener" : "removeEventListener"
            , c = t;
        i[l]("pointerdown", e.onTouchStart, {
            passive: !1
        }),
            n[l]("pointermove", e.onTouchMove, {
                passive: !1,
                capture: a
            }),
            n[l]("pointerup", e.onTouchEnd, {
                passive: !0
            }),
            n[l]("pointercancel", e.onTouchEnd, {
                passive: !0
            }),
            n[l]("pointerout", e.onTouchEnd, {
                passive: !0
            }),
            n[l]("pointerleave", e.onTouchEnd, {
                passive: !0
            }),
        (r.preventClicks || r.preventClicksPropagation) && i[l]("click", e.onClick, !0),
        r.cssMode && s[l]("scroll", e.onScroll),
            r.updateOnWindowResize ? e[c](o.ios || o.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", ym, !0) : e[c]("observerUpdate", ym, !0),
            i[l]("load", e.onLoad, {
                capture: !0
            })
    }
;
function $$() {
    const e = this
        , t = Rt()
        , {params: n} = e;
    e.onTouchStart = L$.bind(e),
        e.onTouchMove = O$.bind(e),
        e.onTouchEnd = A$.bind(e),
    n.cssMode && (e.onScroll = M$.bind(e)),
        e.onClick = I$.bind(e),
        e.onLoad = D$.bind(e),
    bm || (t.addEventListener("touchstart", N$),
        bm = !0),
        z0(e, "on")
}
function F$() {
    z0(this, "off")
}
var j$ = {
    attachEvents: $$,
    detachEvents: F$
};
const wm = (e,t)=>e.grid && t.grid && t.grid.rows > 1;
function H$() {
    const e = this
        , {realIndex: t, initialized: n, params: r, el: i} = e
        , s = r.breakpoints;
    if (!s || s && Object.keys(s).length === 0)
        return;
    const o = e.getBreakpoint(s, e.params.breakpointsBase, e.el);
    if (!o || e.currentBreakpoint === o)
        return;
    const l = (o in s ? s[o] : void 0) || e.originalParams
        , c = wm(e, r)
        , u = wm(e, l)
        , f = r.enabled;
    c && !u ? (i.classList.remove(`${r.containerModifierClass}grid`, `${r.containerModifierClass}grid-column`),
        e.emitContainerClasses()) : !c && u && (i.classList.add(`${r.containerModifierClass}grid`),
    (l.grid.fill && l.grid.fill === "column" || !l.grid.fill && r.grid.fill === "column") && i.classList.add(`${r.containerModifierClass}grid-column`),
        e.emitContainerClasses()),
        ["navigation", "pagination", "scrollbar"].forEach(p=>{
                if (typeof l[p] > "u")
                    return;
                const w = r[p] && r[p].enabled
                    , m = l[p] && l[p].enabled;
                w && !m && e[p].disable(),
                !w && m && e[p].enable()
            }
        );
    const d = l.direction && l.direction !== r.direction
        , h = r.loop && (l.slidesPerView !== r.slidesPerView || d);
    d && n && e.changeDirection(),
        Zt(e.params, l);
    const y = e.params.enabled;
    Object.assign(e, {
        allowTouchMove: e.params.allowTouchMove,
        allowSlideNext: e.params.allowSlideNext,
        allowSlidePrev: e.params.allowSlidePrev
    }),
        f && !y ? e.disable() : !f && y && e.enable(),
        e.currentBreakpoint = o,
        e.emit("_beforeBreakpoint", l),
    h && n && (e.loopDestroy(),
        e.loopCreate(t),
        e.updateSlides()),
        e.emit("breakpoint", l)
}
function B$(e, t, n) {
    if (t === void 0 && (t = "window"),
    !e || t === "container" && !n)
        return;
    let r = !1;
    const i = ot()
        , s = t === "window" ? i.innerHeight : n.clientHeight
        , o = Object.keys(e).map(a=>{
            if (typeof a == "string" && a.indexOf("@") === 0) {
                const l = parseFloat(a.substr(1));
                return {
                    value: s * l,
                    point: a
                }
            }
            return {
                value: a,
                point: a
            }
        }
    );
    o.sort((a,l)=>parseInt(a.value, 10) - parseInt(l.value, 10));
    for (let a = 0; a < o.length; a += 1) {
        const {point: l, value: c} = o[a];
        t === "window" ? i.matchMedia(`(min-width: ${c}px)`).matches && (r = l) : c <= n.clientWidth && (r = l)
    }
    return r || "max"
}
var V$ = {
    setBreakpoint: H$,
    getBreakpoint: B$
};
function z$(e, t) {
    const n = [];
    return e.forEach(r=>{
            typeof r == "object" ? Object.keys(r).forEach(i=>{
                    r[i] && n.push(t + i)
                }
            ) : typeof r == "string" && n.push(t + r)
        }
    ),
        n
}
function U$() {
    const e = this
        , {classNames: t, params: n, rtl: r, el: i, device: s} = e
        , o = z$(["initialized", n.direction, {
        "free-mode": e.params.freeMode && n.freeMode.enabled
    }, {
        autoheight: n.autoHeight
    }, {
        rtl: r
    }, {
        grid: n.grid && n.grid.rows > 1
    }, {
        "grid-column": n.grid && n.grid.rows > 1 && n.grid.fill === "column"
    }, {
        android: s.android
    }, {
        ios: s.ios
    }, {
        "css-mode": n.cssMode
    }, {
        centered: n.cssMode && n.centeredSlides
    }, {
        "watch-progress": n.watchSlidesProgress
    }], n.containerModifierClass);
    t.push(...o),
        i.classList.add(...t),
        e.emitContainerClasses()
}
function W$() {
    const e = this
        , {el: t, classNames: n} = e;
    t.classList.remove(...n),
        e.emitContainerClasses()
}
var G$ = {
    addClasses: U$,
    removeClasses: W$
};
function X$() {
    const e = this
        , {isLocked: t, params: n} = e
        , {slidesOffsetBefore: r} = n;
    if (r) {
        const i = e.slides.length - 1
            , s = e.slidesGrid[i] + e.slidesSizesGrid[i] + r * 2;
        e.isLocked = e.size > s
    } else
        e.isLocked = e.snapGrid.length === 1;
    n.allowSlideNext === !0 && (e.allowSlideNext = !e.isLocked),
    n.allowSlidePrev === !0 && (e.allowSlidePrev = !e.isLocked),
    t && t !== e.isLocked && (e.isEnd = !1),
    t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock")
}
var K$ = {
    checkOverflow: X$
}
    , mu = {
    init: !0,
    direction: "horizontal",
    oneWayMovement: !1,
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: !1,
    updateOnWindowResize: !0,
    resizeObserver: !0,
    nested: !1,
    createElements: !1,
    enabled: !0,
    focusableElements: "input, select, option, textarea, button, video, label",
    width: null,
    height: null,
    preventInteractionOnTransition: !1,
    userAgent: null,
    url: null,
    edgeSwipeDetection: !1,
    edgeSwipeThreshold: 20,
    autoHeight: !1,
    setWrapperSize: !1,
    virtualTranslate: !1,
    effect: "slide",
    breakpoints: void 0,
    breakpointsBase: "window",
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: !1,
    centeredSlides: !1,
    centeredSlidesBounds: !1,
    slidesOffsetBefore: 0,
    slidesOffsetAfter: 0,
    normalizeSlideIndex: !0,
    centerInsufficientSlides: !1,
    watchOverflow: !0,
    roundLengths: !1,
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: !0,
    shortSwipes: !0,
    longSwipes: !0,
    longSwipesRatio: .5,
    longSwipesMs: 300,
    followFinger: !0,
    allowTouchMove: !0,
    threshold: 5,
    touchMoveStopPropagation: !1,
    touchStartPreventDefault: !0,
    touchStartForcePreventDefault: !1,
    touchReleaseOnEdges: !1,
    uniqueNavElements: !0,
    resistance: !0,
    resistanceRatio: .85,
    watchSlidesProgress: !1,
    grabCursor: !1,
    preventClicks: !0,
    preventClicksPropagation: !0,
    slideToClickedSlide: !1,
    loop: !1,
    loopedSlides: null,
    loopPreventsSliding: !0,
    rewind: !1,
    allowSlidePrev: !0,
    allowSlideNext: !0,
    swipeHandler: null,
    noSwiping: !0,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    passiveListeners: !0,
    maxBackfaceHiddenSlides: 10,
    containerModifierClass: "swiper-",
    slideClass: "swiper-slide",
    slideActiveClass: "swiper-slide-active",
    slideVisibleClass: "swiper-slide-visible",
    slideNextClass: "swiper-slide-next",
    slidePrevClass: "swiper-slide-prev",
    wrapperClass: "swiper-wrapper",
    lazyPreloaderClass: "swiper-lazy-preloader",
    lazyPreloadPrevNext: 0,
    runCallbacksOnInit: !0,
    _emitClasses: !1
};
function Y$(e, t) {
    return function(r) {
        r === void 0 && (r = {});
        const i = Object.keys(r)[0]
            , s = r[i];
        if (typeof s != "object" || s === null) {
            Zt(t, r);
            return
        }
        if (["navigation", "pagination", "scrollbar"].indexOf(i) >= 0 && e[i] === !0 && (e[i] = {
            auto: !0
        }),
            !(i in e && "enabled"in s)) {
            Zt(t, r);
            return
        }
        e[i] === !0 && (e[i] = {
            enabled: !0
        }),
        typeof e[i] == "object" && !("enabled"in e[i]) && (e[i].enabled = !0),
        e[i] || (e[i] = {
            enabled: !1
        }),
            Zt(t, r)
    }
}
const ql = {
    eventsEmitter: GN,
    update: r$,
    translate: c$,
    transition: p$,
    slide: S$,
    loop: T$,
    grabCursor: k$,
    events: j$,
    breakpoints: V$,
    checkOverflow: K$,
    classes: G$
}
    , Jl = {};
class Jt {
    constructor() {
        let t, n;
        for (var r = arguments.length, i = new Array(r), s = 0; s < r; s++)
            i[s] = arguments[s];
        i.length === 1 && i[0].constructor && Object.prototype.toString.call(i[0]).slice(8, -1) === "Object" ? n = i[0] : [t,n] = i,
        n || (n = {}),
            n = Zt({}, n),
        t && !n.el && (n.el = t);
        const o = Rt();
        if (n.el && typeof n.el == "string" && o.querySelectorAll(n.el).length > 1) {
            const u = [];
            return o.querySelectorAll(n.el).forEach(f=>{
                    const d = Zt({}, n, {
                        el: f
                    });
                    u.push(new Jt(d))
                }
            ),
                u
        }
        const a = this;
        a.__swiper__ = !0,
            a.support = B0(),
            a.device = BN({
                userAgent: n.userAgent
            }),
            a.browser = zN(),
            a.eventsListeners = {},
            a.eventsAnyListeners = [],
            a.modules = [...a.__modules__],
        n.modules && Array.isArray(n.modules) && a.modules.push(...n.modules);
        const l = {};
        a.modules.forEach(u=>{
                u({
                    params: n,
                    swiper: a,
                    extendParams: Y$(n, l),
                    on: a.on.bind(a),
                    once: a.once.bind(a),
                    off: a.off.bind(a),
                    emit: a.emit.bind(a)
                })
            }
        );
        const c = Zt({}, mu, l);
        return a.params = Zt({}, c, Jl, n),
            a.originalParams = Zt({}, a.params),
            a.passedParams = Zt({}, n),
        a.params && a.params.on && Object.keys(a.params.on).forEach(u=>{
                a.on(u, a.params.on[u])
            }
        ),
        a.params && a.params.onAny && a.onAny(a.params.onAny),
            Object.assign(a, {
                enabled: a.params.enabled,
                el: t,
                classNames: [],
                slides: [],
                slidesGrid: [],
                snapGrid: [],
                slidesSizesGrid: [],
                isHorizontal() {
                    return a.params.direction === "horizontal"
                },
                isVertical() {
                    return a.params.direction === "vertical"
                },
                activeIndex: 0,
                realIndex: 0,
                isBeginning: !0,
                isEnd: !1,
                translate: 0,
                previousTranslate: 0,
                progress: 0,
                velocity: 0,
                animating: !1,
                cssOverflowAdjustment() {
                    return Math.trunc(this.translate / 2 ** 23) * 2 ** 23
                },
                allowSlideNext: a.params.allowSlideNext,
                allowSlidePrev: a.params.allowSlidePrev,
                touchEventsData: {
                    isTouched: void 0,
                    isMoved: void 0,
                    allowTouchCallbacks: void 0,
                    touchStartTime: void 0,
                    isScrolling: void 0,
                    currentTranslate: void 0,
                    startTranslate: void 0,
                    allowThresholdMove: void 0,
                    focusableElements: a.params.focusableElements,
                    lastClickTime: 0,
                    clickTimeout: void 0,
                    velocities: [],
                    allowMomentumBounce: void 0,
                    startMoving: void 0,
                    evCache: []
                },
                allowClick: !0,
                allowTouchMove: a.params.allowTouchMove,
                touches: {
                    startX: 0,
                    startY: 0,
                    currentX: 0,
                    currentY: 0,
                    diff: 0
                },
                imagesToLoad: [],
                imagesLoaded: 0
            }),
            a.emit("_swiper"),
        a.params.init && a.init(),
            a
    }
    getSlideIndex(t) {
        const {slidesEl: n, params: r} = this
            , i = xt(n, `.${r.slideClass}, swiper-slide`)
            , s = Xs(i[0]);
        return Xs(t) - s
    }
    getSlideIndexByData(t) {
        return this.getSlideIndex(this.slides.filter(n=>n.getAttribute("data-swiper-slide-index") * 1 === t)[0])
    }
    recalcSlides() {
        const t = this
            , {slidesEl: n, params: r} = t;
        t.slides = xt(n, `.${r.slideClass}, swiper-slide`)
    }
    enable() {
        const t = this;
        t.enabled || (t.enabled = !0,
        t.params.grabCursor && t.setGrabCursor(),
            t.emit("enable"))
    }
    disable() {
        const t = this;
        t.enabled && (t.enabled = !1,
        t.params.grabCursor && t.unsetGrabCursor(),
            t.emit("disable"))
    }
    setProgress(t, n) {
        const r = this;
        t = Math.min(Math.max(t, 0), 1);
        const i = r.minTranslate()
            , o = (r.maxTranslate() - i) * t + i;
        r.translateTo(o, typeof n > "u" ? 0 : n),
            r.updateActiveIndex(),
            r.updateSlidesClasses()
    }
    emitContainerClasses() {
        const t = this;
        if (!t.params._emitClasses || !t.el)
            return;
        const n = t.el.className.split(" ").filter(r=>r.indexOf("swiper") === 0 || r.indexOf(t.params.containerModifierClass) === 0);
        t.emit("_containerClasses", n.join(" "))
    }
    getSlideClasses(t) {
        const n = this;
        return n.destroyed ? "" : t.className.split(" ").filter(r=>r.indexOf("swiper-slide") === 0 || r.indexOf(n.params.slideClass) === 0).join(" ")
    }
    emitSlidesClasses() {
        const t = this;
        if (!t.params._emitClasses || !t.el)
            return;
        const n = [];
        t.slides.forEach(r=>{
                const i = t.getSlideClasses(r);
                n.push({
                    slideEl: r,
                    classNames: i
                }),
                    t.emit("_slideClass", r, i)
            }
        ),
            t.emit("_slideClasses", n)
    }
    slidesPerViewDynamic(t, n) {
        t === void 0 && (t = "current"),
        n === void 0 && (n = !1);
        const r = this
            , {params: i, slides: s, slidesGrid: o, slidesSizesGrid: a, size: l, activeIndex: c} = r;
        let u = 1;
        if (i.centeredSlides) {
            let f = s[c] ? s[c].swiperSlideSize : 0, d;
            for (let h = c + 1; h < s.length; h += 1)
                s[h] && !d && (f += s[h].swiperSlideSize,
                    u += 1,
                f > l && (d = !0));
            for (let h = c - 1; h >= 0; h -= 1)
                s[h] && !d && (f += s[h].swiperSlideSize,
                    u += 1,
                f > l && (d = !0))
        } else if (t === "current")
            for (let f = c + 1; f < s.length; f += 1)
                (n ? o[f] + a[f] - o[c] < l : o[f] - o[c] < l) && (u += 1);
        else
            for (let f = c - 1; f >= 0; f -= 1)
                o[c] - o[f] < l && (u += 1);
        return u
    }
    update() {
        const t = this;
        if (!t || t.destroyed)
            return;
        const {snapGrid: n, params: r} = t;
        r.breakpoints && t.setBreakpoint(),
            [...t.el.querySelectorAll('[loading="lazy"]')].forEach(o=>{
                    o.complete && qo(t, o)
                }
            ),
            t.updateSize(),
            t.updateSlides(),
            t.updateProgress(),
            t.updateSlidesClasses();
        function i() {
            const o = t.rtlTranslate ? t.translate * -1 : t.translate
                , a = Math.min(Math.max(o, t.maxTranslate()), t.minTranslate());
            t.setTranslate(a),
                t.updateActiveIndex(),
                t.updateSlidesClasses()
        }
        let s;
        if (r.freeMode && r.freeMode.enabled && !r.cssMode)
            i(),
            r.autoHeight && t.updateAutoHeight();
        else {
            if ((r.slidesPerView === "auto" || r.slidesPerView > 1) && t.isEnd && !r.centeredSlides) {
                const o = t.virtual && r.virtual.enabled ? t.virtual.slides : t.slides;
                s = t.slideTo(o.length - 1, 0, !1, !0)
            } else
                s = t.slideTo(t.activeIndex, 0, !1, !0);
            s || i()
        }
        r.watchOverflow && n !== t.snapGrid && t.checkOverflow(),
            t.emit("update")
    }
    changeDirection(t, n) {
        n === void 0 && (n = !0);
        const r = this
            , i = r.params.direction;
        return t || (t = i === "horizontal" ? "vertical" : "horizontal"),
        t === i || t !== "horizontal" && t !== "vertical" || (r.el.classList.remove(`${r.params.containerModifierClass}${i}`),
            r.el.classList.add(`${r.params.containerModifierClass}${t}`),
            r.emitContainerClasses(),
            r.params.direction = t,
            r.slides.forEach(s=>{
                    t === "vertical" ? s.style.width = "" : s.style.height = ""
                }
            ),
            r.emit("changeDirection"),
        n && r.update()),
            r
    }
    changeLanguageDirection(t) {
        const n = this;
        n.rtl && t === "rtl" || !n.rtl && t === "ltr" || (n.rtl = t === "rtl",
            n.rtlTranslate = n.params.direction === "horizontal" && n.rtl,
            n.rtl ? (n.el.classList.add(`${n.params.containerModifierClass}rtl`),
                n.el.dir = "rtl") : (n.el.classList.remove(`${n.params.containerModifierClass}rtl`),
                n.el.dir = "ltr"),
            n.update())
    }
    mount(t) {
        const n = this;
        if (n.mounted)
            return !0;
        let r = t || n.params.el;
        if (typeof r == "string" && (r = document.querySelector(r)),
            !r)
            return !1;
        r.swiper = n,
        r.parentNode && r.parentNode.host && r.parentNode.host.nodeName === "SWIPER-CONTAINER" && (n.isElement = !0);
        const i = ()=>`.${(n.params.wrapperClass || "").trim().split(" ").join(".")}`;
        let o = (()=>r && r.shadowRoot && r.shadowRoot.querySelector ? r.shadowRoot.querySelector(i()) : xt(r, i())[0])();
        return !o && n.params.createElements && (o = wn("div", n.params.wrapperClass),
            r.append(o),
            xt(r, `.${n.params.slideClass}`).forEach(a=>{
                    o.append(a)
                }
            )),
            Object.assign(n, {
                el: r,
                wrapperEl: o,
                slidesEl: n.isElement && !r.parentNode.host.slideSlots ? r.parentNode.host : o,
                hostEl: n.isElement ? r.parentNode.host : r,
                mounted: !0,
                rtl: r.dir.toLowerCase() === "rtl" || ur(r, "direction") === "rtl",
                rtlTranslate: n.params.direction === "horizontal" && (r.dir.toLowerCase() === "rtl" || ur(r, "direction") === "rtl"),
                wrongRTL: ur(o, "display") === "-webkit-box"
            }),
            !0
    }
    init(t) {
        const n = this;
        return n.initialized || n.mount(t) === !1 || (n.emit("beforeInit"),
        n.params.breakpoints && n.setBreakpoint(),
            n.addClasses(),
            n.updateSize(),
            n.updateSlides(),
        n.params.watchOverflow && n.checkOverflow(),
        n.params.grabCursor && n.enabled && n.setGrabCursor(),
            n.params.loop && n.virtual && n.params.virtual.enabled ? n.slideTo(n.params.initialSlide + n.virtual.slidesBefore, 0, n.params.runCallbacksOnInit, !1, !0) : n.slideTo(n.params.initialSlide, 0, n.params.runCallbacksOnInit, !1, !0),
        n.params.loop && n.loopCreate(),
            n.attachEvents(),
            [...n.el.querySelectorAll('[loading="lazy"]')].forEach(i=>{
                    i.complete ? qo(n, i) : i.addEventListener("load", s=>{
                            qo(n, s.target)
                        }
                    )
                }
            ),
            hu(n),
            n.initialized = !0,
            hu(n),
            n.emit("init"),
            n.emit("afterInit")),
            n
    }
    destroy(t, n) {
        t === void 0 && (t = !0),
        n === void 0 && (n = !0);
        const r = this
            , {params: i, el: s, wrapperEl: o, slides: a} = r;
        return typeof r.params > "u" || r.destroyed || (r.emit("beforeDestroy"),
            r.initialized = !1,
            r.detachEvents(),
        i.loop && r.loopDestroy(),
        n && (r.removeClasses(),
            s.removeAttribute("style"),
            o.removeAttribute("style"),
        a && a.length && a.forEach(l=>{
                l.classList.remove(i.slideVisibleClass, i.slideActiveClass, i.slideNextClass, i.slidePrevClass),
                    l.removeAttribute("style"),
                    l.removeAttribute("data-swiper-slide-index")
            }
        )),
            r.emit("destroy"),
            Object.keys(r.eventsListeners).forEach(l=>{
                    r.off(l)
                }
            ),
        t !== !1 && (r.el.swiper = null,
            MN(r)),
            r.destroyed = !0),
            null
    }
    static extendDefaults(t) {
        Zt(Jl, t)
    }
    static get extendedDefaults() {
        return Jl
    }
    static get defaults() {
        return mu
    }
    static installModule(t) {
        Jt.prototype.__modules__ || (Jt.prototype.__modules__ = []);
        const n = Jt.prototype.__modules__;
        typeof t == "function" && n.indexOf(t) < 0 && n.push(t)
    }
    static use(t) {
        return Array.isArray(t) ? (t.forEach(n=>Jt.installModule(n)),
            Jt) : (Jt.installModule(t),
            Jt)
    }
}
Object.keys(ql).forEach(e=>{
        Object.keys(ql[e]).forEach(t=>{
                Jt.prototype[t] = ql[e][t]
            }
        )
    }
);
Jt.use([UN, WN]);
function q$(e) {
    let {swiper: t, extendParams: n, on: r, emit: i} = e;
    n({
        virtual: {
            enabled: !1,
            slides: [],
            cache: !0,
            renderSlide: null,
            renderExternal: null,
            renderExternalUpdate: !0,
            addSlidesBefore: 0,
            addSlidesAfter: 0
        }
    });
    let s;
    const o = Rt();
    t.virtual = {
        cache: {},
        from: void 0,
        to: void 0,
        slides: [],
        offset: 0,
        slidesGrid: []
    };
    const a = o.createElement("div");
    function l(y, p) {
        const w = t.params.virtual;
        if (w.cache && t.virtual.cache[p])
            return t.virtual.cache[p];
        let m;
        return w.renderSlide ? (m = w.renderSlide.call(t, y, p),
        typeof m == "string" && (a.innerHTML = m,
            m = a.children[0])) : t.isElement ? m = wn("swiper-slide") : m = wn("div", t.params.slideClass),
            m.setAttribute("data-swiper-slide-index", p),
        w.renderSlide || (m.innerHTML = y),
        w.cache && (t.virtual.cache[p] = m),
            m
    }
    function c(y) {
        const {slidesPerView: p, slidesPerGroup: w, centeredSlides: m, loop: g} = t.params
            , {addSlidesBefore: b, addSlidesAfter: v} = t.params.virtual
            , {from: S, to: _, slides: E, slidesGrid: T, offset: P} = t.virtual;
        t.params.cssMode || t.updateActiveIndex();
        const I = t.activeIndex || 0;
        let L;
        t.rtlTranslate ? L = "right" : L = t.isHorizontal() ? "left" : "top";
        let x, A;
        m ? (x = Math.floor(p / 2) + w + v,
            A = Math.floor(p / 2) + w + b) : (x = p + (w - 1) + v,
            A = (g ? p : w) + b);
        let k = I - A
            , O = I + x;
        g || (k = Math.max(k, 0),
            O = Math.min(O, E.length - 1));
        let N = (t.slidesGrid[k] || 0) - (t.slidesGrid[0] || 0);
        g && I >= A ? (k -= A,
        m || (N += t.slidesGrid[0])) : g && I < A && (k = -A,
        m && (N += t.slidesGrid[0])),
            Object.assign(t.virtual, {
                from: k,
                to: O,
                offset: N,
                slidesGrid: t.slidesGrid,
                slidesBefore: A,
                slidesAfter: x
            });
        function D() {
            t.updateSlides(),
                t.updateProgress(),
                t.updateSlidesClasses(),
                i("virtualUpdate")
        }
        if (S === k && _ === O && !y) {
            t.slidesGrid !== T && N !== P && t.slides.forEach(de=>{
                    de.style[L] = `${N - Math.abs(t.cssOverflowAdjustment())}px`
                }
            ),
                t.updateProgress(),
                i("virtualUpdate");
            return
        }
        if (t.params.virtual.renderExternal) {
            t.params.virtual.renderExternal.call(t, {
                offset: N,
                from: k,
                to: O,
                slides: function() {
                    const z = [];
                    for (let Pe = k; Pe <= O; Pe += 1)
                        z.push(E[Pe]);
                    return z
                }()
            }),
                t.params.virtual.renderExternalUpdate ? D() : i("virtualUpdate");
            return
        }
        const W = []
            , G = []
            , le = de=>{
                let z = de;
                return de < 0 ? z = E.length + de : z >= E.length && (z = z - E.length),
                    z
            }
        ;
        if (y)
            t.slidesEl.querySelectorAll(`.${t.params.slideClass}, swiper-slide`).forEach(de=>{
                    de.remove()
                }
            );
        else
            for (let de = S; de <= _; de += 1)
                if (de < k || de > O) {
                    const z = le(de);
                    t.slidesEl.querySelectorAll(`.${t.params.slideClass}[data-swiper-slide-index="${z}"], swiper-slide[data-swiper-slide-index="${z}"]`).forEach(Pe=>{
                            Pe.remove()
                        }
                    )
                }
        const ge = g ? -E.length : 0
            , ye = g ? E.length * 2 : E.length;
        for (let de = ge; de < ye; de += 1)
            if (de >= k && de <= O) {
                const z = le(de);
                typeof _ > "u" || y ? G.push(z) : (de > _ && G.push(z),
                de < S && W.push(z))
            }
        if (G.forEach(de=>{
                t.slidesEl.append(l(E[de], de))
            }
        ),
            g)
            for (let de = W.length - 1; de >= 0; de -= 1) {
                const z = W[de];
                t.slidesEl.prepend(l(E[z], z))
            }
        else
            W.sort((de,z)=>z - de),
                W.forEach(de=>{
                        t.slidesEl.prepend(l(E[de], de))
                    }
                );
        xt(t.slidesEl, ".swiper-slide, swiper-slide").forEach(de=>{
                de.style[L] = `${N - Math.abs(t.cssOverflowAdjustment())}px`
            }
        ),
            D()
    }
    function u(y) {
        if (typeof y == "object" && "length"in y)
            for (let p = 0; p < y.length; p += 1)
                y[p] && t.virtual.slides.push(y[p]);
        else
            t.virtual.slides.push(y);
        c(!0)
    }
    function f(y) {
        const p = t.activeIndex;
        let w = p + 1
            , m = 1;
        if (Array.isArray(y)) {
            for (let g = 0; g < y.length; g += 1)
                y[g] && t.virtual.slides.unshift(y[g]);
            w = p + y.length,
                m = y.length
        } else
            t.virtual.slides.unshift(y);
        if (t.params.virtual.cache) {
            const g = t.virtual.cache
                , b = {};
            Object.keys(g).forEach(v=>{
                    const S = g[v]
                        , _ = S.getAttribute("data-swiper-slide-index");
                    _ && S.setAttribute("data-swiper-slide-index", parseInt(_, 10) + m),
                        b[parseInt(v, 10) + m] = S
                }
            ),
                t.virtual.cache = b
        }
        c(!0),
            t.slideTo(w, 0)
    }
    function d(y) {
        if (typeof y > "u" || y === null)
            return;
        let p = t.activeIndex;
        if (Array.isArray(y))
            for (let w = y.length - 1; w >= 0; w -= 1)
                t.virtual.slides.splice(y[w], 1),
                t.params.virtual.cache && delete t.virtual.cache[y[w]],
                y[w] < p && (p -= 1),
                    p = Math.max(p, 0);
        else
            t.virtual.slides.splice(y, 1),
            t.params.virtual.cache && delete t.virtual.cache[y],
            y < p && (p -= 1),
                p = Math.max(p, 0);
        c(!0),
            t.slideTo(p, 0)
    }
    function h() {
        t.virtual.slides = [],
        t.params.virtual.cache && (t.virtual.cache = {}),
            c(!0),
            t.slideTo(0, 0)
    }
    r("beforeInit", ()=>{
            if (!t.params.virtual.enabled)
                return;
            let y;
            if (typeof t.passedParams.virtual.slides > "u") {
                const p = [...t.slidesEl.children].filter(w=>w.matches(`.${t.params.slideClass}, swiper-slide`));
                p && p.length && (t.virtual.slides = [...p],
                    y = !0,
                    p.forEach((w,m)=>{
                            w.setAttribute("data-swiper-slide-index", m),
                                t.virtual.cache[m] = w,
                                w.remove()
                        }
                    ))
            }
            y || (t.virtual.slides = t.params.virtual.slides),
                t.classNames.push(`${t.params.containerModifierClass}virtual`),
                t.params.watchSlidesProgress = !0,
                t.originalParams.watchSlidesProgress = !0,
            t.params.initialSlide || c()
        }
    ),
        r("setTranslate", ()=>{
                t.params.virtual.enabled && (t.params.cssMode && !t._immediateVirtual ? (clearTimeout(s),
                    s = setTimeout(()=>{
                            c()
                        }
                        , 100)) : c())
            }
        ),
        r("init update resize", ()=>{
                t.params.virtual.enabled && t.params.cssMode && ps(t.wrapperEl, "--swiper-virtual-size", `${t.virtualSize}px`)
            }
        ),
        Object.assign(t.virtual, {
            appendSlide: u,
            prependSlide: f,
            removeSlide: d,
            removeAllSlides: h,
            update: c
        })
}
function J$(e) {
    let {swiper: t, extendParams: n, on: r, emit: i} = e;
    const s = Rt()
        , o = ot();
    t.keyboard = {
        enabled: !1
    },
        n({
            keyboard: {
                enabled: !1,
                onlyInViewport: !0,
                pageUpDown: !0
            }
        });
    function a(u) {
        if (!t.enabled)
            return;
        const {rtlTranslate: f} = t;
        let d = u;
        d.originalEvent && (d = d.originalEvent);
        const h = d.keyCode || d.charCode
            , y = t.params.keyboard.pageUpDown
            , p = y && h === 33
            , w = y && h === 34
            , m = h === 37
            , g = h === 39
            , b = h === 38
            , v = h === 40;
        if (!t.allowSlideNext && (t.isHorizontal() && g || t.isVertical() && v || w) || !t.allowSlidePrev && (t.isHorizontal() && m || t.isVertical() && b || p))
            return !1;
        if (!(d.shiftKey || d.altKey || d.ctrlKey || d.metaKey) && !(s.activeElement && s.activeElement.nodeName && (s.activeElement.nodeName.toLowerCase() === "input" || s.activeElement.nodeName.toLowerCase() === "textarea"))) {
            if (t.params.keyboard.onlyInViewport && (p || w || m || g || b || v)) {
                let S = !1;
                if (Hr(t.el, `.${t.params.slideClass}, swiper-slide`).length > 0 && Hr(t.el, `.${t.params.slideActiveClass}`).length === 0)
                    return;
                const _ = t.el
                    , E = _.clientWidth
                    , T = _.clientHeight
                    , P = o.innerWidth
                    , I = o.innerHeight
                    , L = Ca(_);
                f && (L.left -= _.scrollLeft);
                const x = [[L.left, L.top], [L.left + E, L.top], [L.left, L.top + T], [L.left + E, L.top + T]];
                for (let A = 0; A < x.length; A += 1) {
                    const k = x[A];
                    if (k[0] >= 0 && k[0] <= P && k[1] >= 0 && k[1] <= I) {
                        if (k[0] === 0 && k[1] === 0)
                            continue;
                        S = !0
                    }
                }
                if (!S)
                    return
            }
            t.isHorizontal() ? ((p || w || m || g) && (d.preventDefault ? d.preventDefault() : d.returnValue = !1),
            ((w || g) && !f || (p || m) && f) && t.slideNext(),
            ((p || m) && !f || (w || g) && f) && t.slidePrev()) : ((p || w || b || v) && (d.preventDefault ? d.preventDefault() : d.returnValue = !1),
            (w || v) && t.slideNext(),
            (p || b) && t.slidePrev()),
                i("keyPress", h)
        }
    }
    function l() {
        t.keyboard.enabled || (s.addEventListener("keydown", a),
            t.keyboard.enabled = !0)
    }
    function c() {
        t.keyboard.enabled && (s.removeEventListener("keydown", a),
            t.keyboard.enabled = !1)
    }
    r("init", ()=>{
            t.params.keyboard.enabled && l()
        }
    ),
        r("destroy", ()=>{
                t.keyboard.enabled && c()
            }
        ),
        Object.assign(t.keyboard, {
            enable: l,
            disable: c
        })
}
function Z$(e) {
    let {swiper: t, extendParams: n, on: r, emit: i} = e;
    const s = ot();
    n({
        mousewheel: {
            enabled: !1,
            releaseOnEdges: !1,
            invert: !1,
            forceToAxis: !1,
            sensitivity: 1,
            eventsTarget: "container",
            thresholdDelta: null,
            thresholdTime: null,
            noMousewheelClass: "swiper-no-mousewheel"
        }
    }),
        t.mousewheel = {
            enabled: !1
        };
    let o, a = un(), l;
    const c = [];
    function u(b) {
        let E = 0
            , T = 0
            , P = 0
            , I = 0;
        return "detail"in b && (T = b.detail),
        "wheelDelta"in b && (T = -b.wheelDelta / 120),
        "wheelDeltaY"in b && (T = -b.wheelDeltaY / 120),
        "wheelDeltaX"in b && (E = -b.wheelDeltaX / 120),
        "axis"in b && b.axis === b.HORIZONTAL_AXIS && (E = T,
            T = 0),
            P = E * 10,
            I = T * 10,
        "deltaY"in b && (I = b.deltaY),
        "deltaX"in b && (P = b.deltaX),
        b.shiftKey && !P && (P = I,
            I = 0),
        (P || I) && b.deltaMode && (b.deltaMode === 1 ? (P *= 40,
            I *= 40) : (P *= 800,
            I *= 800)),
        P && !E && (E = P < 1 ? -1 : 1),
        I && !T && (T = I < 1 ? -1 : 1),
            {
                spinX: E,
                spinY: T,
                pixelX: P,
                pixelY: I
            }
    }
    function f() {
        t.enabled && (t.mouseEntered = !0)
    }
    function d() {
        t.enabled && (t.mouseEntered = !1)
    }
    function h(b) {
        return t.params.mousewheel.thresholdDelta && b.delta < t.params.mousewheel.thresholdDelta || t.params.mousewheel.thresholdTime && un() - a < t.params.mousewheel.thresholdTime ? !1 : b.delta >= 6 && un() - a < 60 ? !0 : (b.direction < 0 ? (!t.isEnd || t.params.loop) && !t.animating && (t.slideNext(),
            i("scroll", b.raw)) : (!t.isBeginning || t.params.loop) && !t.animating && (t.slidePrev(),
            i("scroll", b.raw)),
            a = new s.Date().getTime(),
            !1)
    }
    function y(b) {
        const v = t.params.mousewheel;
        if (b.direction < 0) {
            if (t.isEnd && !t.params.loop && v.releaseOnEdges)
                return !0
        } else if (t.isBeginning && !t.params.loop && v.releaseOnEdges)
            return !0;
        return !1
    }
    function p(b) {
        let v = b
            , S = !0;
        if (!t.enabled || b.target.closest(`.${t.params.mousewheel.noMousewheelClass}`))
            return;
        const _ = t.params.mousewheel;
        t.params.cssMode && v.preventDefault();
        let E = t.el;
        t.params.mousewheel.eventsTarget !== "container" && (E = document.querySelector(t.params.mousewheel.eventsTarget));
        const T = E && E.contains(v.target);
        if (!t.mouseEntered && !T && !_.releaseOnEdges)
            return !0;
        v.originalEvent && (v = v.originalEvent);
        let P = 0;
        const I = t.rtlTranslate ? -1 : 1
            , L = u(v);
        if (_.forceToAxis)
            if (t.isHorizontal())
                if (Math.abs(L.pixelX) > Math.abs(L.pixelY))
                    P = -L.pixelX * I;
                else
                    return !0;
            else if (Math.abs(L.pixelY) > Math.abs(L.pixelX))
                P = -L.pixelY;
            else
                return !0;
        else
            P = Math.abs(L.pixelX) > Math.abs(L.pixelY) ? -L.pixelX * I : -L.pixelY;
        if (P === 0)
            return !0;
        _.invert && (P = -P);
        let x = t.getTranslate() + P * _.sensitivity;
        if (x >= t.minTranslate() && (x = t.minTranslate()),
        x <= t.maxTranslate() && (x = t.maxTranslate()),
            S = t.params.loop ? !0 : !(x === t.minTranslate() || x === t.maxTranslate()),
        S && t.params.nested && v.stopPropagation(),
        !t.params.freeMode || !t.params.freeMode.enabled) {
            const A = {
                time: un(),
                delta: Math.abs(P),
                direction: Math.sign(P),
                raw: b
            };
            c.length >= 2 && c.shift();
            const k = c.length ? c[c.length - 1] : void 0;
            if (c.push(A),
                k ? (A.direction !== k.direction || A.delta > k.delta || A.time > k.time + 150) && h(A) : h(A),
                y(A))
                return !0
        } else {
            const A = {
                time: un(),
                delta: Math.abs(P),
                direction: Math.sign(P)
            }
                , k = l && A.time < l.time + 500 && A.delta <= l.delta && A.direction === l.direction;
            if (!k) {
                l = void 0;
                let O = t.getTranslate() + P * _.sensitivity;
                const N = t.isBeginning
                    , D = t.isEnd;
                if (O >= t.minTranslate() && (O = t.minTranslate()),
                O <= t.maxTranslate() && (O = t.maxTranslate()),
                    t.setTransition(0),
                    t.setTranslate(O),
                    t.updateProgress(),
                    t.updateActiveIndex(),
                    t.updateSlidesClasses(),
                (!N && t.isBeginning || !D && t.isEnd) && t.updateSlidesClasses(),
                t.params.loop && t.loopFix({
                    direction: A.direction < 0 ? "next" : "prev",
                    byMousewheel: !0
                }),
                    t.params.freeMode.sticky) {
                    clearTimeout(o),
                        o = void 0,
                    c.length >= 15 && c.shift();
                    const W = c.length ? c[c.length - 1] : void 0
                        , G = c[0];
                    if (c.push(A),
                    W && (A.delta > W.delta || A.direction !== W.direction))
                        c.splice(0);
                    else if (c.length >= 15 && A.time - G.time < 500 && G.delta - A.delta >= 1 && A.delta <= 6) {
                        const le = P > 0 ? .8 : .2;
                        l = A,
                            c.splice(0),
                            o = Kr(()=>{
                                    t.slideToClosest(t.params.speed, !0, void 0, le)
                                }
                                , 0)
                    }
                    o || (o = Kr(()=>{
                            l = A,
                                c.splice(0),
                                t.slideToClosest(t.params.speed, !0, void 0, .5)
                        }
                        , 500))
                }
                if (k || i("scroll", v),
                t.params.autoplay && t.params.autoplayDisableOnInteraction && t.autoplay.stop(),
                _.releaseOnEdges && (O === t.minTranslate() || O === t.maxTranslate()))
                    return !0
            }
        }
        return v.preventDefault ? v.preventDefault() : v.returnValue = !1,
            !1
    }
    function w(b) {
        let v = t.el;
        t.params.mousewheel.eventsTarget !== "container" && (v = document.querySelector(t.params.mousewheel.eventsTarget)),
            v[b]("mouseenter", f),
            v[b]("mouseleave", d),
            v[b]("wheel", p)
    }
    function m() {
        return t.params.cssMode ? (t.wrapperEl.removeEventListener("wheel", p),
            !0) : t.mousewheel.enabled ? !1 : (w("addEventListener"),
            t.mousewheel.enabled = !0,
            !0)
    }
    function g() {
        return t.params.cssMode ? (t.wrapperEl.addEventListener(event, p),
            !0) : t.mousewheel.enabled ? (w("removeEventListener"),
            t.mousewheel.enabled = !1,
            !0) : !1
    }
    r("init", ()=>{
            !t.params.mousewheel.enabled && t.params.cssMode && g(),
            t.params.mousewheel.enabled && m()
        }
    ),
        r("destroy", ()=>{
                t.params.cssMode && m(),
                t.mousewheel.enabled && g()
            }
        ),
        Object.assign(t.mousewheel, {
            enable: m,
            disable: g
        })
}
function Uf(e, t, n, r) {
    return e.params.createElements && Object.keys(r).forEach(i=>{
            if (!n[i] && n.auto === !0) {
                let s = xt(e.el, `.${r[i]}`)[0];
                s || (s = wn("div", r[i]),
                    s.className = r[i],
                    e.el.append(s)),
                    n[i] = s,
                    t[i] = s
            }
        }
    ),
        n
}
function Q$(e) {
    let {swiper: t, extendParams: n, on: r, emit: i} = e;
    n({
        navigation: {
            nextEl: null,
            prevEl: null,
            hideOnClick: !1,
            disabledClass: "swiper-button-disabled",
            hiddenClass: "swiper-button-hidden",
            lockClass: "swiper-button-lock",
            navigationDisabledClass: "swiper-navigation-disabled"
        }
    }),
        t.navigation = {
            nextEl: null,
            prevEl: null
        };
    const s = p=>(Array.isArray(p) ? p : [p]).filter(w=>!!w);
    function o(p) {
        let w;
        return p && typeof p == "string" && t.isElement && (w = t.el.querySelector(p),
            w) ? w : (p && (typeof p == "string" && (w = [...document.querySelectorAll(p)]),
        t.params.uniqueNavElements && typeof p == "string" && w.length > 1 && t.el.querySelectorAll(p).length === 1 && (w = t.el.querySelector(p))),
            p && !w ? p : w)
    }
    function a(p, w) {
        const m = t.params.navigation;
        p = s(p),
            p.forEach(g=>{
                    g && (g.classList[w ? "add" : "remove"](...m.disabledClass.split(" ")),
                    g.tagName === "BUTTON" && (g.disabled = w),
                    t.params.watchOverflow && t.enabled && g.classList[t.isLocked ? "add" : "remove"](m.lockClass))
                }
            )
    }
    function l() {
        const {nextEl: p, prevEl: w} = t.navigation;
        if (t.params.loop) {
            a(w, !1),
                a(p, !1);
            return
        }
        a(w, t.isBeginning && !t.params.rewind),
            a(p, t.isEnd && !t.params.rewind)
    }
    function c(p) {
        p.preventDefault(),
        !(t.isBeginning && !t.params.loop && !t.params.rewind) && (t.slidePrev(),
            i("navigationPrev"))
    }
    function u(p) {
        p.preventDefault(),
        !(t.isEnd && !t.params.loop && !t.params.rewind) && (t.slideNext(),
            i("navigationNext"))
    }
    function f() {
        const p = t.params.navigation;
        if (t.params.navigation = Uf(t, t.originalParams.navigation, t.params.navigation, {
            nextEl: "swiper-button-next",
            prevEl: "swiper-button-prev"
        }),
            !(p.nextEl || p.prevEl))
            return;
        let w = o(p.nextEl)
            , m = o(p.prevEl);
        Object.assign(t.navigation, {
            nextEl: w,
            prevEl: m
        }),
            w = s(w),
            m = s(m);
        const g = (b,v)=>{
                b && b.addEventListener("click", v === "next" ? u : c),
                !t.enabled && b && b.classList.add(...p.lockClass.split(" "))
            }
        ;
        w.forEach(b=>g(b, "next")),
            m.forEach(b=>g(b, "prev"))
    }
    function d() {
        let {nextEl: p, prevEl: w} = t.navigation;
        p = s(p),
            w = s(w);
        const m = (g,b)=>{
                g.removeEventListener("click", b === "next" ? u : c),
                    g.classList.remove(...t.params.navigation.disabledClass.split(" "))
            }
        ;
        p.forEach(g=>m(g, "next")),
            w.forEach(g=>m(g, "prev"))
    }
    r("init", ()=>{
            t.params.navigation.enabled === !1 ? y() : (f(),
                l())
        }
    ),
        r("toEdge fromEdge lock unlock", ()=>{
                l()
            }
        ),
        r("destroy", ()=>{
                d()
            }
        ),
        r("enable disable", ()=>{
                let {nextEl: p, prevEl: w} = t.navigation;
                p = s(p),
                    w = s(w),
                    [...p, ...w].filter(m=>!!m).forEach(m=>m.classList[t.enabled ? "remove" : "add"](t.params.navigation.lockClass))
            }
        ),
        r("click", (p,w)=>{
                let {nextEl: m, prevEl: g} = t.navigation;
                m = s(m),
                    g = s(g);
                const b = w.target;
                if (t.params.navigation.hideOnClick && !g.includes(b) && !m.includes(b)) {
                    if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === b || t.pagination.el.contains(b)))
                        return;
                    let v;
                    m.length ? v = m[0].classList.contains(t.params.navigation.hiddenClass) : g.length && (v = g[0].classList.contains(t.params.navigation.hiddenClass)),
                        i(v === !0 ? "navigationShow" : "navigationHide"),
                        [...m, ...g].filter(S=>!!S).forEach(S=>S.classList.toggle(t.params.navigation.hiddenClass))
                }
            }
        );
    const h = ()=>{
            t.el.classList.remove(...t.params.navigation.navigationDisabledClass.split(" ")),
                f(),
                l()
        }
        , y = ()=>{
            t.el.classList.add(...t.params.navigation.navigationDisabledClass.split(" ")),
                d()
        }
    ;
    Object.assign(t.navigation, {
        enable: h,
        disable: y,
        update: l,
        init: f,
        destroy: d
    })
}
function cr(e) {
    return e === void 0 && (e = ""),
        `.${e.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}`
}
function e2(e) {
    let {swiper: t, extendParams: n, on: r, emit: i} = e;
    const s = "swiper-pagination";
    n({
        pagination: {
            el: null,
            bulletElement: "span",
            clickable: !1,
            hideOnClick: !1,
            renderBullet: null,
            renderProgressbar: null,
            renderFraction: null,
            renderCustom: null,
            progressbarOpposite: !1,
            type: "bullets",
            dynamicBullets: !1,
            dynamicMainBullets: 1,
            formatFractionCurrent: g=>g,
            formatFractionTotal: g=>g,
            bulletClass: `${s}-bullet`,
            bulletActiveClass: `${s}-bullet-active`,
            modifierClass: `${s}-`,
            currentClass: `${s}-current`,
            totalClass: `${s}-total`,
            hiddenClass: `${s}-hidden`,
            progressbarFillClass: `${s}-progressbar-fill`,
            progressbarOppositeClass: `${s}-progressbar-opposite`,
            clickableClass: `${s}-clickable`,
            lockClass: `${s}-lock`,
            horizontalClass: `${s}-horizontal`,
            verticalClass: `${s}-vertical`,
            paginationDisabledClass: `${s}-disabled`
        }
    }),
        t.pagination = {
            el: null,
            bullets: []
        };
    let o, a = 0;
    const l = g=>(Array.isArray(g) ? g : [g]).filter(b=>!!b);
    function c() {
        return !t.params.pagination.el || !t.pagination.el || Array.isArray(t.pagination.el) && t.pagination.el.length === 0
    }
    function u(g, b) {
        const {bulletActiveClass: v} = t.params.pagination;
        g && (g = g[`${b === "prev" ? "previous" : "next"}ElementSibling`],
        g && (g.classList.add(`${v}-${b}`),
            g = g[`${b === "prev" ? "previous" : "next"}ElementSibling`],
        g && g.classList.add(`${v}-${b}-${b}`)))
    }
    function f(g) {
        const b = g.target.closest(cr(t.params.pagination.bulletClass));
        if (!b)
            return;
        g.preventDefault();
        const v = Xs(b) * t.params.slidesPerGroup;
        if (t.params.loop) {
            if (t.realIndex === v)
                return;
            const S = t.getSlideIndexByData(v)
                , _ = t.getSlideIndexByData(t.realIndex);
            S > t.slides.length - t.loopedSlides && t.loopFix({
                direction: S > _ ? "next" : "prev",
                activeSlideIndex: S,
                slideTo: !1
            }),
                t.slideToLoop(v)
        } else
            t.slideTo(v)
    }
    function d() {
        const g = t.rtl
            , b = t.params.pagination;
        if (c())
            return;
        let v = t.pagination.el;
        v = l(v);
        let S, _;
        const E = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length
            , T = t.params.loop ? Math.ceil(E / t.params.slidesPerGroup) : t.snapGrid.length;
        if (t.params.loop ? (_ = t.previousRealIndex || 0,
            S = t.params.slidesPerGroup > 1 ? Math.floor(t.realIndex / t.params.slidesPerGroup) : t.realIndex) : typeof t.snapIndex < "u" ? (S = t.snapIndex,
            _ = t.previousSnapIndex) : (_ = t.previousIndex || 0,
            S = t.activeIndex || 0),
        b.type === "bullets" && t.pagination.bullets && t.pagination.bullets.length > 0) {
            const P = t.pagination.bullets;
            let I, L, x;
            if (b.dynamicBullets && (o = pu(P[0], t.isHorizontal() ? "width" : "height", !0),
                v.forEach(A=>{
                        A.style[t.isHorizontal() ? "width" : "height"] = `${o * (b.dynamicMainBullets + 4)}px`
                    }
                ),
            b.dynamicMainBullets > 1 && _ !== void 0 && (a += S - (_ || 0),
                a > b.dynamicMainBullets - 1 ? a = b.dynamicMainBullets - 1 : a < 0 && (a = 0)),
                I = Math.max(S - a, 0),
                L = I + (Math.min(P.length, b.dynamicMainBullets) - 1),
                x = (L + I) / 2),
                P.forEach(A=>{
                        const k = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(O=>`${b.bulletActiveClass}${O}`)].map(O=>typeof O == "string" && O.includes(" ") ? O.split(" ") : O).flat();
                        A.classList.remove(...k)
                    }
                ),
            v.length > 1)
                P.forEach(A=>{
                        const k = Xs(A);
                        k === S ? A.classList.add(...b.bulletActiveClass.split(" ")) : t.isElement && A.setAttribute("part", "bullet"),
                        b.dynamicBullets && (k >= I && k <= L && A.classList.add(...`${b.bulletActiveClass}-main`.split(" ")),
                        k === I && u(A, "prev"),
                        k === L && u(A, "next"))
                    }
                );
            else {
                const A = P[S];
                if (A && A.classList.add(...b.bulletActiveClass.split(" ")),
                t.isElement && P.forEach((k,O)=>{
                        k.setAttribute("part", O === S ? "bullet-active" : "bullet")
                    }
                ),
                    b.dynamicBullets) {
                    const k = P[I]
                        , O = P[L];
                    for (let N = I; N <= L; N += 1)
                        P[N] && P[N].classList.add(...`${b.bulletActiveClass}-main`.split(" "));
                    u(k, "prev"),
                        u(O, "next")
                }
            }
            if (b.dynamicBullets) {
                const A = Math.min(P.length, b.dynamicMainBullets + 4)
                    , k = (o * A - o) / 2 - x * o
                    , O = g ? "right" : "left";
                P.forEach(N=>{
                        N.style[t.isHorizontal() ? O : "top"] = `${k}px`
                    }
                )
            }
        }
        v.forEach((P,I)=>{
                if (b.type === "fraction" && (P.querySelectorAll(cr(b.currentClass)).forEach(L=>{
                        L.textContent = b.formatFractionCurrent(S + 1)
                    }
                ),
                    P.querySelectorAll(cr(b.totalClass)).forEach(L=>{
                            L.textContent = b.formatFractionTotal(T)
                        }
                    )),
                b.type === "progressbar") {
                    let L;
                    b.progressbarOpposite ? L = t.isHorizontal() ? "vertical" : "horizontal" : L = t.isHorizontal() ? "horizontal" : "vertical";
                    const x = (S + 1) / T;
                    let A = 1
                        , k = 1;
                    L === "horizontal" ? A = x : k = x,
                        P.querySelectorAll(cr(b.progressbarFillClass)).forEach(O=>{
                                O.style.transform = `translate3d(0,0,0) scaleX(${A}) scaleY(${k})`,
                                    O.style.transitionDuration = `${t.params.speed}ms`
                            }
                        )
                }
                b.type === "custom" && b.renderCustom ? (P.innerHTML = b.renderCustom(t, S + 1, T),
                I === 0 && i("paginationRender", P)) : (I === 0 && i("paginationRender", P),
                    i("paginationUpdate", P)),
                t.params.watchOverflow && t.enabled && P.classList[t.isLocked ? "add" : "remove"](b.lockClass)
            }
        )
    }
    function h() {
        const g = t.params.pagination;
        if (c())
            return;
        const b = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length;
        let v = t.pagination.el;
        v = l(v);
        let S = "";
        if (g.type === "bullets") {
            let _ = t.params.loop ? Math.ceil(b / t.params.slidesPerGroup) : t.snapGrid.length;
            t.params.freeMode && t.params.freeMode.enabled && _ > b && (_ = b);
            for (let E = 0; E < _; E += 1)
                g.renderBullet ? S += g.renderBullet.call(t, E, g.bulletClass) : S += `<${g.bulletElement} ${t.isElement ? 'part="bullet"' : ""} class="${g.bulletClass}"></${g.bulletElement}>`
        }
        g.type === "fraction" && (g.renderFraction ? S = g.renderFraction.call(t, g.currentClass, g.totalClass) : S = `<span class="${g.currentClass}"></span> / <span class="${g.totalClass}"></span>`),
        g.type === "progressbar" && (g.renderProgressbar ? S = g.renderProgressbar.call(t, g.progressbarFillClass) : S = `<span class="${g.progressbarFillClass}"></span>`),
            t.pagination.bullets = [],
            v.forEach(_=>{
                    g.type !== "custom" && (_.innerHTML = S || ""),
                    g.type === "bullets" && t.pagination.bullets.push(..._.querySelectorAll(cr(g.bulletClass)))
                }
            ),
        g.type !== "custom" && i("paginationRender", v[0])
    }
    function y() {
        t.params.pagination = Uf(t, t.originalParams.pagination, t.params.pagination, {
            el: "swiper-pagination"
        });
        const g = t.params.pagination;
        if (!g.el)
            return;
        let b;
        typeof g.el == "string" && t.isElement && (b = t.el.querySelector(g.el)),
        !b && typeof g.el == "string" && (b = [...document.querySelectorAll(g.el)]),
        b || (b = g.el),
        !(!b || b.length === 0) && (t.params.uniqueNavElements && typeof g.el == "string" && Array.isArray(b) && b.length > 1 && (b = [...t.el.querySelectorAll(g.el)],
        b.length > 1 && (b = b.filter(v=>Hr(v, ".swiper")[0] === t.el)[0])),
        Array.isArray(b) && b.length === 1 && (b = b[0]),
            Object.assign(t.pagination, {
                el: b
            }),
            b = l(b),
            b.forEach(v=>{
                    g.type === "bullets" && g.clickable && v.classList.add(g.clickableClass),
                        v.classList.add(g.modifierClass + g.type),
                        v.classList.add(t.isHorizontal() ? g.horizontalClass : g.verticalClass),
                    g.type === "bullets" && g.dynamicBullets && (v.classList.add(`${g.modifierClass}${g.type}-dynamic`),
                        a = 0,
                    g.dynamicMainBullets < 1 && (g.dynamicMainBullets = 1)),
                    g.type === "progressbar" && g.progressbarOpposite && v.classList.add(g.progressbarOppositeClass),
                    g.clickable && v.addEventListener("click", f),
                    t.enabled || v.classList.add(g.lockClass)
                }
            ))
    }
    function p() {
        const g = t.params.pagination;
        if (c())
            return;
        let b = t.pagination.el;
        b && (b = l(b),
            b.forEach(v=>{
                    v.classList.remove(g.hiddenClass),
                        v.classList.remove(g.modifierClass + g.type),
                        v.classList.remove(t.isHorizontal() ? g.horizontalClass : g.verticalClass),
                    g.clickable && v.removeEventListener("click", f)
                }
            )),
        t.pagination.bullets && t.pagination.bullets.forEach(v=>v.classList.remove(...g.bulletActiveClass.split(" ")))
    }
    r("changeDirection", ()=>{
            if (!t.pagination || !t.pagination.el)
                return;
            const g = t.params.pagination;
            let {el: b} = t.pagination;
            b = l(b),
                b.forEach(v=>{
                        v.classList.remove(g.horizontalClass, g.verticalClass),
                            v.classList.add(t.isHorizontal() ? g.horizontalClass : g.verticalClass)
                    }
                )
        }
    ),
        r("init", ()=>{
                t.params.pagination.enabled === !1 ? m() : (y(),
                    h(),
                    d())
            }
        ),
        r("activeIndexChange", ()=>{
                typeof t.snapIndex > "u" && d()
            }
        ),
        r("snapIndexChange", ()=>{
                d()
            }
        ),
        r("snapGridLengthChange", ()=>{
                h(),
                    d()
            }
        ),
        r("destroy", ()=>{
                p()
            }
        ),
        r("enable disable", ()=>{
                let {el: g} = t.pagination;
                g && (g = l(g),
                    g.forEach(b=>b.classList[t.enabled ? "remove" : "add"](t.params.pagination.lockClass)))
            }
        ),
        r("lock unlock", ()=>{
                d()
            }
        ),
        r("click", (g,b)=>{
                const v = b.target
                    , S = l(t.pagination.el);
                if (t.params.pagination.el && t.params.pagination.hideOnClick && S && S.length > 0 && !v.classList.contains(t.params.pagination.bulletClass)) {
                    if (t.navigation && (t.navigation.nextEl && v === t.navigation.nextEl || t.navigation.prevEl && v === t.navigation.prevEl))
                        return;
                    const _ = S[0].classList.contains(t.params.pagination.hiddenClass);
                    i(_ === !0 ? "paginationShow" : "paginationHide"),
                        S.forEach(E=>E.classList.toggle(t.params.pagination.hiddenClass))
                }
            }
        );
    const w = ()=>{
            t.el.classList.remove(t.params.pagination.paginationDisabledClass);
            let {el: g} = t.pagination;
            g && (g = l(g),
                g.forEach(b=>b.classList.remove(t.params.pagination.paginationDisabledClass))),
                y(),
                h(),
                d()
        }
        , m = ()=>{
            t.el.classList.add(t.params.pagination.paginationDisabledClass);
            let {el: g} = t.pagination;
            g && (g = l(g),
                g.forEach(b=>b.classList.add(t.params.pagination.paginationDisabledClass))),
                p()
        }
    ;
    Object.assign(t.pagination, {
        enable: w,
        disable: m,
        render: h,
        update: d,
        init: y,
        destroy: p
    })
}
function t2(e) {
    let {swiper: t, extendParams: n, on: r, emit: i} = e;
    const s = Rt();
    let o = !1, a = null, l = null, c, u, f, d;
    n({
        scrollbar: {
            el: null,
            dragSize: "auto",
            hide: !1,
            draggable: !1,
            snapOnRelease: !0,
            lockClass: "swiper-scrollbar-lock",
            dragClass: "swiper-scrollbar-drag",
            scrollbarDisabledClass: "swiper-scrollbar-disabled",
            horizontalClass: "swiper-scrollbar-horizontal",
            verticalClass: "swiper-scrollbar-vertical"
        }
    }),
        t.scrollbar = {
            el: null,
            dragEl: null
        };
    function h() {
        if (!t.params.scrollbar.el || !t.scrollbar.el)
            return;
        const {scrollbar: x, rtlTranslate: A} = t
            , {dragEl: k, el: O} = x
            , N = t.params.scrollbar
            , D = t.params.loop ? t.progressLoop : t.progress;
        let W = u
            , G = (f - u) * D;
        A ? (G = -G,
            G > 0 ? (W = u - G,
                G = 0) : -G + u > f && (W = f + G)) : G < 0 ? (W = u + G,
            G = 0) : G + u > f && (W = f - G),
            t.isHorizontal() ? (k.style.transform = `translate3d(${G}px, 0, 0)`,
                k.style.width = `${W}px`) : (k.style.transform = `translate3d(0px, ${G}px, 0)`,
                k.style.height = `${W}px`),
        N.hide && (clearTimeout(a),
            O.style.opacity = 1,
            a = setTimeout(()=>{
                    O.style.opacity = 0,
                        O.style.transitionDuration = "400ms"
                }
                , 1e3))
    }
    function y(x) {
        !t.params.scrollbar.el || !t.scrollbar.el || (t.scrollbar.dragEl.style.transitionDuration = `${x}ms`)
    }
    function p() {
        if (!t.params.scrollbar.el || !t.scrollbar.el)
            return;
        const {scrollbar: x} = t
            , {dragEl: A, el: k} = x;
        A.style.width = "",
            A.style.height = "",
            f = t.isHorizontal() ? k.offsetWidth : k.offsetHeight,
            d = t.size / (t.virtualSize + t.params.slidesOffsetBefore - (t.params.centeredSlides ? t.snapGrid[0] : 0)),
            t.params.scrollbar.dragSize === "auto" ? u = f * d : u = parseInt(t.params.scrollbar.dragSize, 10),
            t.isHorizontal() ? A.style.width = `${u}px` : A.style.height = `${u}px`,
            d >= 1 ? k.style.display = "none" : k.style.display = "",
        t.params.scrollbar.hide && (k.style.opacity = 0),
        t.params.watchOverflow && t.enabled && x.el.classList[t.isLocked ? "add" : "remove"](t.params.scrollbar.lockClass)
    }
    function w(x) {
        return t.isHorizontal() ? x.clientX : x.clientY
    }
    function m(x) {
        const {scrollbar: A, rtlTranslate: k} = t
            , {el: O} = A;
        let N;
        N = (w(x) - Ca(O)[t.isHorizontal() ? "left" : "top"] - (c !== null ? c : u / 2)) / (f - u),
            N = Math.max(Math.min(N, 1), 0),
        k && (N = 1 - N);
        const D = t.minTranslate() + (t.maxTranslate() - t.minTranslate()) * N;
        t.updateProgress(D),
            t.setTranslate(D),
            t.updateActiveIndex(),
            t.updateSlidesClasses()
    }
    function g(x) {
        const A = t.params.scrollbar
            , {scrollbar: k, wrapperEl: O} = t
            , {el: N, dragEl: D} = k;
        o = !0,
            c = x.target === D ? w(x) - x.target.getBoundingClientRect()[t.isHorizontal() ? "left" : "top"] : null,
            x.preventDefault(),
            x.stopPropagation(),
            O.style.transitionDuration = "100ms",
            D.style.transitionDuration = "100ms",
            m(x),
            clearTimeout(l),
            N.style.transitionDuration = "0ms",
        A.hide && (N.style.opacity = 1),
        t.params.cssMode && (t.wrapperEl.style["scroll-snap-type"] = "none"),
            i("scrollbarDragStart", x)
    }
    function b(x) {
        const {scrollbar: A, wrapperEl: k} = t
            , {el: O, dragEl: N} = A;
        o && (x.preventDefault ? x.preventDefault() : x.returnValue = !1,
            m(x),
            k.style.transitionDuration = "0ms",
            O.style.transitionDuration = "0ms",
            N.style.transitionDuration = "0ms",
            i("scrollbarDragMove", x))
    }
    function v(x) {
        const A = t.params.scrollbar
            , {scrollbar: k, wrapperEl: O} = t
            , {el: N} = k;
        o && (o = !1,
        t.params.cssMode && (t.wrapperEl.style["scroll-snap-type"] = "",
            O.style.transitionDuration = ""),
        A.hide && (clearTimeout(l),
            l = Kr(()=>{
                    N.style.opacity = 0,
                        N.style.transitionDuration = "400ms"
                }
                , 1e3)),
            i("scrollbarDragEnd", x),
        A.snapOnRelease && t.slideToClosest())
    }
    function S(x) {
        const {scrollbar: A, params: k} = t
            , O = A.el;
        if (!O)
            return;
        const N = O
            , D = k.passiveListeners ? {
            passive: !1,
            capture: !1
        } : !1
            , W = k.passiveListeners ? {
            passive: !0,
            capture: !1
        } : !1;
        if (!N)
            return;
        const G = x === "on" ? "addEventListener" : "removeEventListener";
        N[G]("pointerdown", g, D),
            s[G]("pointermove", b, D),
            s[G]("pointerup", v, W)
    }
    function _() {
        !t.params.scrollbar.el || !t.scrollbar.el || S("on")
    }
    function E() {
        !t.params.scrollbar.el || !t.scrollbar.el || S("off")
    }
    function T() {
        const {scrollbar: x, el: A} = t;
        t.params.scrollbar = Uf(t, t.originalParams.scrollbar, t.params.scrollbar, {
            el: "swiper-scrollbar"
        });
        const k = t.params.scrollbar;
        if (!k.el)
            return;
        let O;
        typeof k.el == "string" && t.isElement && (O = t.el.querySelector(k.el)),
            !O && typeof k.el == "string" ? O = s.querySelectorAll(k.el) : O || (O = k.el),
        t.params.uniqueNavElements && typeof k.el == "string" && O.length > 1 && A.querySelectorAll(k.el).length === 1 && (O = A.querySelector(k.el)),
        O.length > 0 && (O = O[0]),
            O.classList.add(t.isHorizontal() ? k.horizontalClass : k.verticalClass);
        let N;
        O && (N = O.querySelector(`.${t.params.scrollbar.dragClass}`),
        N || (N = wn("div", t.params.scrollbar.dragClass),
            O.append(N))),
            Object.assign(x, {
                el: O,
                dragEl: N
            }),
        k.draggable && _(),
        O && O.classList[t.enabled ? "remove" : "add"](t.params.scrollbar.lockClass)
    }
    function P() {
        const x = t.params.scrollbar
            , A = t.scrollbar.el;
        A && A.classList.remove(t.isHorizontal() ? x.horizontalClass : x.verticalClass),
            E()
    }
    r("init", ()=>{
            t.params.scrollbar.enabled === !1 ? L() : (T(),
                p(),
                h())
        }
    ),
        r("update resize observerUpdate lock unlock", ()=>{
                p()
            }
        ),
        r("setTranslate", ()=>{
                h()
            }
        ),
        r("setTransition", (x,A)=>{
                y(A)
            }
        ),
        r("enable disable", ()=>{
                const {el: x} = t.scrollbar;
                x && x.classList[t.enabled ? "remove" : "add"](t.params.scrollbar.lockClass)
            }
        ),
        r("destroy", ()=>{
                P()
            }
        );
    const I = ()=>{
            t.el.classList.remove(t.params.scrollbar.scrollbarDisabledClass),
            t.scrollbar.el && t.scrollbar.el.classList.remove(t.params.scrollbar.scrollbarDisabledClass),
                T(),
                p(),
                h()
        }
        , L = ()=>{
            t.el.classList.add(t.params.scrollbar.scrollbarDisabledClass),
            t.scrollbar.el && t.scrollbar.el.classList.add(t.params.scrollbar.scrollbarDisabledClass),
                P()
        }
    ;
    Object.assign(t.scrollbar, {
        enable: I,
        disable: L,
        updateSize: p,
        setTranslate: h,
        init: T,
        destroy: P
    })
}
function n2(e) {
    let {swiper: t, extendParams: n, on: r} = e;
    n({
        parallax: {
            enabled: !1
        }
    });
    const i = (a,l)=>{
        const {rtl: c} = t
            , u = c ? -1 : 1
            , f = a.getAttribute("data-swiper-parallax") || "0";
        let d = a.getAttribute("data-swiper-parallax-x")
            , h = a.getAttribute("data-swiper-parallax-y");
        const y = a.getAttribute("data-swiper-parallax-scale")
            , p = a.getAttribute("data-swiper-parallax-opacity")
            , w = a.getAttribute("data-swiper-parallax-rotate");
        if (d || h ? (d = d || "0",
            h = h || "0") : t.isHorizontal() ? (d = f,
            h = "0") : (h = f,
            d = "0"),
            d.indexOf("%") >= 0 ? d = `${parseInt(d, 10) * l * u}%` : d = `${d * l * u}px`,
            h.indexOf("%") >= 0 ? h = `${parseInt(h, 10) * l}%` : h = `${h * l}px`,
        typeof p < "u" && p !== null) {
            const g = p - (p - 1) * (1 - Math.abs(l));
            a.style.opacity = g
        }
        let m = `translate3d(${d}, ${h}, 0px)`;
        if (typeof y < "u" && y !== null) {
            const g = y - (y - 1) * (1 - Math.abs(l));
            m += ` scale(${g})`
        }
        if (w && typeof w < "u" && w !== null) {
            const g = w * l * -1;
            m += ` rotate(${g}deg)`
        }
        a.style.transform = m
    }
        , s = ()=>{
        const {el: a, slides: l, progress: c, snapGrid: u} = t;
        xt(a, "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").forEach(f=>{
                i(f, c)
            }
        ),
            l.forEach((f,d)=>{
                    let h = f.progress;
                    t.params.slidesPerGroup > 1 && t.params.slidesPerView !== "auto" && (h += Math.ceil(d / 2) - c * (u.length - 1)),
                        h = Math.min(Math.max(h, -1), 1),
                        f.querySelectorAll("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale], [data-swiper-parallax-rotate]").forEach(y=>{
                                i(y, h)
                            }
                        )
                }
            )
    }
        , o = function(a) {
        a === void 0 && (a = t.params.speed);
        const {el: l} = t;
        l.querySelectorAll("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").forEach(c=>{
                let u = parseInt(c.getAttribute("data-swiper-parallax-duration"), 10) || a;
                a === 0 && (u = 0),
                    c.style.transitionDuration = `${u}ms`
            }
        )
    };
    r("beforeInit", ()=>{
            t.params.parallax.enabled && (t.params.watchSlidesProgress = !0,
                t.originalParams.watchSlidesProgress = !0)
        }
    ),
        r("init", ()=>{
                t.params.parallax.enabled && s()
            }
        ),
        r("setTranslate", ()=>{
                t.params.parallax.enabled && s()
            }
        ),
        r("setTransition", (a,l)=>{
                t.params.parallax.enabled && o(l)
            }
        )
}
function r2(e) {
    let {swiper: t, extendParams: n, on: r, emit: i} = e;
    const s = ot();
    n({
        zoom: {
            enabled: !1,
            maxRatio: 3,
            minRatio: 1,
            toggle: !0,
            containerClass: "swiper-zoom-container",
            zoomedSlideClass: "swiper-slide-zoomed"
        }
    }),
        t.zoom = {
            enabled: !1
        };
    let o = 1, a = !1, l, c;
    const u = []
        , f = {
        originX: 0,
        originY: 0,
        slideEl: void 0,
        slideWidth: void 0,
        slideHeight: void 0,
        imageEl: void 0,
        imageWrapEl: void 0,
        maxRatio: 3
    }
        , d = {
        isTouched: void 0,
        isMoved: void 0,
        currentX: void 0,
        currentY: void 0,
        minX: void 0,
        minY: void 0,
        maxX: void 0,
        maxY: void 0,
        width: void 0,
        height: void 0,
        startX: void 0,
        startY: void 0,
        touchesStart: {},
        touchesCurrent: {}
    }
        , h = {
        x: void 0,
        y: void 0,
        prevPositionX: void 0,
        prevPositionY: void 0,
        prevTime: void 0
    };
    let y = 1;
    Object.defineProperty(t.zoom, "scale", {
        get() {
            return y
        },
        set(D) {
            if (y !== D) {
                const W = f.imageEl
                    , G = f.slideEl;
                i("zoomChange", D, W, G)
            }
            y = D
        }
    });
    function p() {
        if (u.length < 2)
            return 1;
        const D = u[0].pageX
            , W = u[0].pageY
            , G = u[1].pageX
            , le = u[1].pageY;
        return Math.sqrt((G - D) ** 2 + (le - W) ** 2)
    }
    function w() {
        if (u.length < 2)
            return {
                x: null,
                y: null
            };
        const D = f.imageEl.getBoundingClientRect();
        return [(u[0].pageX + (u[1].pageX - u[0].pageX) / 2 - D.x) / o, (u[0].pageY + (u[1].pageY - u[0].pageY) / 2 - D.y) / o]
    }
    function m() {
        return t.isElement ? "swiper-slide" : `.${t.params.slideClass}`
    }
    function g(D) {
        const W = m();
        return !!(D.target.matches(W) || t.slides.filter(G=>G.contains(D.target)).length > 0)
    }
    function b(D) {
        const W = `.${t.params.zoom.containerClass}`;
        return !!(D.target.matches(W) || [...t.hostEl.querySelectorAll(W)].filter(G=>G.contains(D.target)).length > 0)
    }
    function v(D) {
        if (D.pointerType === "mouse" && u.splice(0, u.length),
            !g(D))
            return;
        const W = t.params.zoom;
        if (l = !1,
            c = !1,
            u.push(D),
            !(u.length < 2)) {
            if (l = !0,
                f.scaleStart = p(),
                !f.slideEl) {
                f.slideEl = D.target.closest(`.${t.params.slideClass}, swiper-slide`),
                f.slideEl || (f.slideEl = t.slides[t.activeIndex]);
                let G = f.slideEl.querySelector(`.${W.containerClass}`);
                if (G && (G = G.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]),
                    f.imageEl = G,
                    G ? f.imageWrapEl = Hr(f.imageEl, `.${W.containerClass}`)[0] : f.imageWrapEl = void 0,
                    !f.imageWrapEl) {
                    f.imageEl = void 0;
                    return
                }
                f.maxRatio = f.imageWrapEl.getAttribute("data-swiper-zoom") || W.maxRatio
            }
            if (f.imageEl) {
                const [G,le] = w();
                f.originX = G,
                    f.originY = le,
                    f.imageEl.style.transitionDuration = "0ms"
            }
            a = !0
        }
    }
    function S(D) {
        if (!g(D))
            return;
        const W = t.params.zoom
            , G = t.zoom
            , le = u.findIndex(ge=>ge.pointerId === D.pointerId);
        le >= 0 && (u[le] = D),
        !(u.length < 2) && (c = !0,
            f.scaleMove = p(),
        f.imageEl && (G.scale = f.scaleMove / f.scaleStart * o,
        G.scale > f.maxRatio && (G.scale = f.maxRatio - 1 + (G.scale - f.maxRatio + 1) ** .5),
        G.scale < W.minRatio && (G.scale = W.minRatio + 1 - (W.minRatio - G.scale + 1) ** .5),
            f.imageEl.style.transform = `translate3d(0,0,0) scale(${G.scale})`))
    }
    function _(D) {
        if (!g(D) || D.pointerType === "mouse" && D.type === "pointerout")
            return;
        const W = t.params.zoom
            , G = t.zoom
            , le = u.findIndex(ge=>ge.pointerId === D.pointerId);
        le >= 0 && u.splice(le, 1),
        !(!l || !c) && (l = !1,
            c = !1,
        f.imageEl && (G.scale = Math.max(Math.min(G.scale, f.maxRatio), W.minRatio),
            f.imageEl.style.transitionDuration = `${t.params.speed}ms`,
            f.imageEl.style.transform = `translate3d(0,0,0) scale(${G.scale})`,
            o = G.scale,
            a = !1,
            G.scale > 1 && f.slideEl ? f.slideEl.classList.add(`${W.zoomedSlideClass}`) : G.scale <= 1 && f.slideEl && f.slideEl.classList.remove(`${W.zoomedSlideClass}`),
        G.scale === 1 && (f.originX = 0,
            f.originY = 0,
            f.slideEl = void 0)))
    }
    function E(D) {
        const W = t.device;
        if (!f.imageEl || d.isTouched)
            return;
        W.android && D.cancelable && D.preventDefault(),
            d.isTouched = !0;
        const G = u.length > 0 ? u[0] : D;
        d.touchesStart.x = G.pageX,
            d.touchesStart.y = G.pageY
    }
    function T(D) {
        if (!g(D) || !b(D))
            return;
        const W = t.zoom;
        if (!f.imageEl || !d.isTouched || !f.slideEl)
            return;
        d.isMoved || (d.width = f.imageEl.offsetWidth,
            d.height = f.imageEl.offsetHeight,
            d.startX = du(f.imageWrapEl, "x") || 0,
            d.startY = du(f.imageWrapEl, "y") || 0,
            f.slideWidth = f.slideEl.offsetWidth,
            f.slideHeight = f.slideEl.offsetHeight,
            f.imageWrapEl.style.transitionDuration = "0ms");
        const G = d.width * W.scale
            , le = d.height * W.scale;
        if (G < f.slideWidth && le < f.slideHeight)
            return;
        if (d.minX = Math.min(f.slideWidth / 2 - G / 2, 0),
            d.maxX = -d.minX,
            d.minY = Math.min(f.slideHeight / 2 - le / 2, 0),
            d.maxY = -d.minY,
            d.touchesCurrent.x = u.length > 0 ? u[0].pageX : D.pageX,
            d.touchesCurrent.y = u.length > 0 ? u[0].pageY : D.pageY,
        Math.max(Math.abs(d.touchesCurrent.x - d.touchesStart.x), Math.abs(d.touchesCurrent.y - d.touchesStart.y)) > 5 && (t.allowClick = !1),
        !d.isMoved && !a) {
            if (t.isHorizontal() && (Math.floor(d.minX) === Math.floor(d.startX) && d.touchesCurrent.x < d.touchesStart.x || Math.floor(d.maxX) === Math.floor(d.startX) && d.touchesCurrent.x > d.touchesStart.x)) {
                d.isTouched = !1;
                return
            }
            if (!t.isHorizontal() && (Math.floor(d.minY) === Math.floor(d.startY) && d.touchesCurrent.y < d.touchesStart.y || Math.floor(d.maxY) === Math.floor(d.startY) && d.touchesCurrent.y > d.touchesStart.y)) {
                d.isTouched = !1;
                return
            }
        }
        D.cancelable && D.preventDefault(),
            D.stopPropagation(),
            d.isMoved = !0;
        const ye = (W.scale - o) / (f.maxRatio - t.params.zoom.minRatio)
            , {originX: de, originY: z} = f;
        d.currentX = d.touchesCurrent.x - d.touchesStart.x + d.startX + ye * (d.width - de * 2),
            d.currentY = d.touchesCurrent.y - d.touchesStart.y + d.startY + ye * (d.height - z * 2),
        d.currentX < d.minX && (d.currentX = d.minX + 1 - (d.minX - d.currentX + 1) ** .8),
        d.currentX > d.maxX && (d.currentX = d.maxX - 1 + (d.currentX - d.maxX + 1) ** .8),
        d.currentY < d.minY && (d.currentY = d.minY + 1 - (d.minY - d.currentY + 1) ** .8),
        d.currentY > d.maxY && (d.currentY = d.maxY - 1 + (d.currentY - d.maxY + 1) ** .8),
        h.prevPositionX || (h.prevPositionX = d.touchesCurrent.x),
        h.prevPositionY || (h.prevPositionY = d.touchesCurrent.y),
        h.prevTime || (h.prevTime = Date.now()),
            h.x = (d.touchesCurrent.x - h.prevPositionX) / (Date.now() - h.prevTime) / 2,
            h.y = (d.touchesCurrent.y - h.prevPositionY) / (Date.now() - h.prevTime) / 2,
        Math.abs(d.touchesCurrent.x - h.prevPositionX) < 2 && (h.x = 0),
        Math.abs(d.touchesCurrent.y - h.prevPositionY) < 2 && (h.y = 0),
            h.prevPositionX = d.touchesCurrent.x,
            h.prevPositionY = d.touchesCurrent.y,
            h.prevTime = Date.now(),
            f.imageWrapEl.style.transform = `translate3d(${d.currentX}px, ${d.currentY}px,0)`
    }
    function P() {
        const D = t.zoom;
        if (!f.imageEl)
            return;
        if (!d.isTouched || !d.isMoved) {
            d.isTouched = !1,
                d.isMoved = !1;
            return
        }
        d.isTouched = !1,
            d.isMoved = !1;
        let W = 300
            , G = 300;
        const le = h.x * W
            , ge = d.currentX + le
            , ye = h.y * G
            , de = d.currentY + ye;
        h.x !== 0 && (W = Math.abs((ge - d.currentX) / h.x)),
        h.y !== 0 && (G = Math.abs((de - d.currentY) / h.y));
        const z = Math.max(W, G);
        d.currentX = ge,
            d.currentY = de;
        const Pe = d.width * D.scale
            , _e = d.height * D.scale;
        d.minX = Math.min(f.slideWidth / 2 - Pe / 2, 0),
            d.maxX = -d.minX,
            d.minY = Math.min(f.slideHeight / 2 - _e / 2, 0),
            d.maxY = -d.minY,
            d.currentX = Math.max(Math.min(d.currentX, d.maxX), d.minX),
            d.currentY = Math.max(Math.min(d.currentY, d.maxY), d.minY),
            f.imageWrapEl.style.transitionDuration = `${z}ms`,
            f.imageWrapEl.style.transform = `translate3d(${d.currentX}px, ${d.currentY}px,0)`
    }
    function I() {
        const D = t.zoom;
        f.slideEl && t.activeIndex !== t.slides.indexOf(f.slideEl) && (f.imageEl && (f.imageEl.style.transform = "translate3d(0,0,0) scale(1)"),
        f.imageWrapEl && (f.imageWrapEl.style.transform = "translate3d(0,0,0)"),
            f.slideEl.classList.remove(`${t.params.zoom.zoomedSlideClass}`),
            D.scale = 1,
            o = 1,
            f.slideEl = void 0,
            f.imageEl = void 0,
            f.imageWrapEl = void 0,
            f.originX = 0,
            f.originY = 0)
    }
    function L(D) {
        const W = t.zoom
            , G = t.params.zoom;
        if (!f.slideEl) {
            D && D.target && (f.slideEl = D.target.closest(`.${t.params.slideClass}, swiper-slide`)),
            f.slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? f.slideEl = xt(t.slidesEl, `.${t.params.slideActiveClass}`)[0] : f.slideEl = t.slides[t.activeIndex]);
            let ie = f.slideEl.querySelector(`.${G.containerClass}`);
            ie && (ie = ie.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]),
                f.imageEl = ie,
                ie ? f.imageWrapEl = Hr(f.imageEl, `.${G.containerClass}`)[0] : f.imageWrapEl = void 0
        }
        if (!f.imageEl || !f.imageWrapEl)
            return;
        t.params.cssMode && (t.wrapperEl.style.overflow = "hidden",
            t.wrapperEl.style.touchAction = "none"),
            f.slideEl.classList.add(`${G.zoomedSlideClass}`);
        let le, ge, ye, de, z, Pe, _e, J, ne, ee, ce, Ce, M, C, R, F, V, Y;
        typeof d.touchesStart.x > "u" && D ? (le = D.pageX,
            ge = D.pageY) : (le = d.touchesStart.x,
            ge = d.touchesStart.y);
        const re = typeof D == "number" ? D : null;
        o === 1 && re && (le = void 0,
            ge = void 0),
            W.scale = re || f.imageWrapEl.getAttribute("data-swiper-zoom") || G.maxRatio,
            o = re || f.imageWrapEl.getAttribute("data-swiper-zoom") || G.maxRatio,
            D && !(o === 1 && re) ? (V = f.slideEl.offsetWidth,
                Y = f.slideEl.offsetHeight,
                ye = Ca(f.slideEl).left + s.scrollX,
                de = Ca(f.slideEl).top + s.scrollY,
                z = ye + V / 2 - le,
                Pe = de + Y / 2 - ge,
                ne = f.imageEl.offsetWidth,
                ee = f.imageEl.offsetHeight,
                ce = ne * W.scale,
                Ce = ee * W.scale,
                M = Math.min(V / 2 - ce / 2, 0),
                C = Math.min(Y / 2 - Ce / 2, 0),
                R = -M,
                F = -C,
                _e = z * W.scale,
                J = Pe * W.scale,
            _e < M && (_e = M),
            _e > R && (_e = R),
            J < C && (J = C),
            J > F && (J = F)) : (_e = 0,
                J = 0),
        re && W.scale === 1 && (f.originX = 0,
            f.originY = 0),
            f.imageWrapEl.style.transitionDuration = "300ms",
            f.imageWrapEl.style.transform = `translate3d(${_e}px, ${J}px,0)`,
            f.imageEl.style.transitionDuration = "300ms",
            f.imageEl.style.transform = `translate3d(0,0,0) scale(${W.scale})`
    }
    function x() {
        const D = t.zoom
            , W = t.params.zoom;
        if (!f.slideEl) {
            t.params.virtual && t.params.virtual.enabled && t.virtual ? f.slideEl = xt(t.slidesEl, `.${t.params.slideActiveClass}`)[0] : f.slideEl = t.slides[t.activeIndex];
            let G = f.slideEl.querySelector(`.${W.containerClass}`);
            G && (G = G.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]),
                f.imageEl = G,
                G ? f.imageWrapEl = Hr(f.imageEl, `.${W.containerClass}`)[0] : f.imageWrapEl = void 0
        }
        !f.imageEl || !f.imageWrapEl || (t.params.cssMode && (t.wrapperEl.style.overflow = "",
            t.wrapperEl.style.touchAction = ""),
            D.scale = 1,
            o = 1,
            f.imageWrapEl.style.transitionDuration = "300ms",
            f.imageWrapEl.style.transform = "translate3d(0,0,0)",
            f.imageEl.style.transitionDuration = "300ms",
            f.imageEl.style.transform = "translate3d(0,0,0) scale(1)",
            f.slideEl.classList.remove(`${W.zoomedSlideClass}`),
            f.slideEl = void 0,
            f.originX = 0,
            f.originY = 0)
    }
    function A(D) {
        const W = t.zoom;
        W.scale && W.scale !== 1 ? x() : L(D)
    }
    function k() {
        const D = t.params.passiveListeners ? {
            passive: !0,
            capture: !1
        } : !1
            , W = t.params.passiveListeners ? {
            passive: !1,
            capture: !0
        } : !0;
        return {
            passiveListener: D,
            activeListenerWithCapture: W
        }
    }
    function O() {
        const D = t.zoom;
        if (D.enabled)
            return;
        D.enabled = !0;
        const {passiveListener: W, activeListenerWithCapture: G} = k();
        t.wrapperEl.addEventListener("pointerdown", v, W),
            t.wrapperEl.addEventListener("pointermove", S, G),
            ["pointerup", "pointercancel", "pointerout"].forEach(le=>{
                    t.wrapperEl.addEventListener(le, _, W)
                }
            ),
            t.wrapperEl.addEventListener("pointermove", T, G)
    }
    function N() {
        const D = t.zoom;
        if (!D.enabled)
            return;
        D.enabled = !1;
        const {passiveListener: W, activeListenerWithCapture: G} = k();
        t.wrapperEl.removeEventListener("pointerdown", v, W),
            t.wrapperEl.removeEventListener("pointermove", S, G),
            ["pointerup", "pointercancel", "pointerout"].forEach(le=>{
                    t.wrapperEl.removeEventListener(le, _, W)
                }
            ),
            t.wrapperEl.removeEventListener("pointermove", T, G)
    }
    r("init", ()=>{
            t.params.zoom.enabled && O()
        }
    ),
        r("destroy", ()=>{
                N()
            }
        ),
        r("touchStart", (D,W)=>{
                t.zoom.enabled && E(W)
            }
        ),
        r("touchEnd", (D,W)=>{
                t.zoom.enabled && P()
            }
        ),
        r("doubleTap", (D,W)=>{
                !t.animating && t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && A(W)
            }
        ),
        r("transitionEnd", ()=>{
                t.zoom.enabled && t.params.zoom.enabled && I()
            }
        ),
        r("slideChange", ()=>{
                t.zoom.enabled && t.params.zoom.enabled && t.params.cssMode && I()
            }
        ),
        Object.assign(t.zoom, {
            enable: O,
            disable: N,
            in: L,
            out: x,
            toggle: A
        })
}
function i2(e) {
    let {swiper: t, extendParams: n, on: r} = e;
    n({
        controller: {
            control: void 0,
            inverse: !1,
            by: "slide"
        }
    }),
        t.controller = {
            control: void 0
        };
    function i(c, u) {
        const f = function() {
            let p, w, m;
            return (g,b)=>{
                for (w = -1,
                         p = g.length; p - w > 1; )
                    m = p + w >> 1,
                        g[m] <= b ? w = m : p = m;
                return p
            }
        }();
        this.x = c,
            this.y = u,
            this.lastIndex = c.length - 1;
        let d, h;
        return this.interpolate = function(p) {
            return p ? (h = f(this.x, p),
                d = h - 1,
            (p - this.x[d]) * (this.y[h] - this.y[d]) / (this.x[h] - this.x[d]) + this.y[d]) : 0
        }
            ,
            this
    }
    function s(c) {
        t.controller.spline = t.params.loop ? new i(t.slidesGrid,c.slidesGrid) : new i(t.snapGrid,c.snapGrid)
    }
    function o(c, u) {
        const f = t.controller.control;
        let d, h;
        const y = t.constructor;
        function p(w) {
            if (w.destroyed)
                return;
            const m = t.rtlTranslate ? -t.translate : t.translate;
            t.params.controller.by === "slide" && (s(w),
                h = -t.controller.spline.interpolate(-m)),
            (!h || t.params.controller.by === "container") && (d = (w.maxTranslate() - w.minTranslate()) / (t.maxTranslate() - t.minTranslate()),
            (Number.isNaN(d) || !Number.isFinite(d)) && (d = 1),
                h = (m - t.minTranslate()) * d + w.minTranslate()),
            t.params.controller.inverse && (h = w.maxTranslate() - h),
                w.updateProgress(h),
                w.setTranslate(h, t),
                w.updateActiveIndex(),
                w.updateSlidesClasses()
        }
        if (Array.isArray(f))
            for (let w = 0; w < f.length; w += 1)
                f[w] !== u && f[w]instanceof y && p(f[w]);
        else
            f instanceof y && u !== f && p(f)
    }
    function a(c, u) {
        const f = t.constructor
            , d = t.controller.control;
        let h;
        function y(p) {
            p.destroyed || (p.setTransition(c, t),
            c !== 0 && (p.transitionStart(),
            p.params.autoHeight && Kr(()=>{
                    p.updateAutoHeight()
                }
            ),
                Ts(p.wrapperEl, ()=>{
                        d && p.transitionEnd()
                    }
                )))
        }
        if (Array.isArray(d))
            for (h = 0; h < d.length; h += 1)
                d[h] !== u && d[h]instanceof f && y(d[h]);
        else
            d instanceof f && u !== d && y(d)
    }
    function l() {
        t.controller.control && t.controller.spline && (t.controller.spline = void 0,
            delete t.controller.spline)
    }
    r("beforeInit", ()=>{
            if (typeof window < "u" && (typeof t.params.controller.control == "string" || t.params.controller.control instanceof HTMLElement)) {
                const c = document.querySelector(t.params.controller.control);
                if (c && c.swiper)
                    t.controller.control = c.swiper;
                else if (c) {
                    const u = f=>{
                            t.controller.control = f.detail[0],
                                t.update(),
                                c.removeEventListener("init", u)
                        }
                    ;
                    c.addEventListener("init", u)
                }
                return
            }
            t.controller.control = t.params.controller.control
        }
    ),
        r("update", ()=>{
                l()
            }
        ),
        r("resize", ()=>{
                l()
            }
        ),
        r("observerUpdate", ()=>{
                l()
            }
        ),
        r("setTranslate", (c,u,f)=>{
                !t.controller.control || t.controller.control.destroyed || t.controller.setTranslate(u, f)
            }
        ),
        r("setTransition", (c,u,f)=>{
                !t.controller.control || t.controller.control.destroyed || t.controller.setTransition(u, f)
            }
        ),
        Object.assign(t.controller, {
            setTranslate: o,
            setTransition: a
        })
}
function s2(e) {
    let {swiper: t, extendParams: n, on: r} = e;
    n({
        a11y: {
            enabled: !0,
            notificationClass: "swiper-notification",
            prevSlideMessage: "Previous slide",
            nextSlideMessage: "Next slide",
            firstSlideMessage: "This is the first slide",
            lastSlideMessage: "This is the last slide",
            paginationBulletMessage: "Go to slide {{index}}",
            slideLabelMessage: "{{index}} / {{slidesLength}}",
            containerMessage: null,
            containerRoleDescriptionMessage: null,
            itemRoleDescriptionMessage: null,
            slideRole: "group",
            id: null
        }
    }),
        t.a11y = {
            clicked: !1
        };
    let i = null;
    function s(k) {
        const O = i;
        O.length !== 0 && (O.innerHTML = "",
            O.innerHTML = k)
    }
    const o = k=>(Array.isArray(k) ? k : [k]).filter(O=>!!O);
    function a(k) {
        k === void 0 && (k = 16);
        const O = ()=>Math.round(16 * Math.random()).toString(16);
        return "x".repeat(k).replace(/x/g, O)
    }
    function l(k) {
        k = o(k),
            k.forEach(O=>{
                    O.setAttribute("tabIndex", "0")
                }
            )
    }
    function c(k) {
        k = o(k),
            k.forEach(O=>{
                    O.setAttribute("tabIndex", "-1")
                }
            )
    }
    function u(k, O) {
        k = o(k),
            k.forEach(N=>{
                    N.setAttribute("role", O)
                }
            )
    }
    function f(k, O) {
        k = o(k),
            k.forEach(N=>{
                    N.setAttribute("aria-roledescription", O)
                }
            )
    }
    function d(k, O) {
        k = o(k),
            k.forEach(N=>{
                    N.setAttribute("aria-controls", O)
                }
            )
    }
    function h(k, O) {
        k = o(k),
            k.forEach(N=>{
                    N.setAttribute("aria-label", O)
                }
            )
    }
    function y(k, O) {
        k = o(k),
            k.forEach(N=>{
                    N.setAttribute("id", O)
                }
            )
    }
    function p(k, O) {
        k = o(k),
            k.forEach(N=>{
                    N.setAttribute("aria-live", O)
                }
            )
    }
    function w(k) {
        k = o(k),
            k.forEach(O=>{
                    O.setAttribute("aria-disabled", !0)
                }
            )
    }
    function m(k) {
        k = o(k),
            k.forEach(O=>{
                    O.setAttribute("aria-disabled", !1)
                }
            )
    }
    function g(k) {
        if (k.keyCode !== 13 && k.keyCode !== 32)
            return;
        const O = t.params.a11y
            , N = k.target;
        t.pagination && t.pagination.el && (N === t.pagination.el || t.pagination.el.contains(k.target)) && !k.target.matches(cr(t.params.pagination.bulletClass)) || (t.navigation && t.navigation.nextEl && N === t.navigation.nextEl && (t.isEnd && !t.params.loop || t.slideNext(),
            t.isEnd ? s(O.lastSlideMessage) : s(O.nextSlideMessage)),
        t.navigation && t.navigation.prevEl && N === t.navigation.prevEl && (t.isBeginning && !t.params.loop || t.slidePrev(),
            t.isBeginning ? s(O.firstSlideMessage) : s(O.prevSlideMessage)),
        t.pagination && N.matches(cr(t.params.pagination.bulletClass)) && N.click())
    }
    function b() {
        if (t.params.loop || t.params.rewind || !t.navigation)
            return;
        const {nextEl: k, prevEl: O} = t.navigation;
        O && (t.isBeginning ? (w(O),
            c(O)) : (m(O),
            l(O))),
        k && (t.isEnd ? (w(k),
            c(k)) : (m(k),
            l(k)))
    }
    function v() {
        return t.pagination && t.pagination.bullets && t.pagination.bullets.length
    }
    function S() {
        return v() && t.params.pagination.clickable
    }
    function _() {
        const k = t.params.a11y;
        v() && t.pagination.bullets.forEach(O=>{
                t.params.pagination.clickable && (l(O),
                t.params.pagination.renderBullet || (u(O, "button"),
                    h(O, k.paginationBulletMessage.replace(/\{\{index\}\}/, Xs(O) + 1)))),
                    O.matches(cr(t.params.pagination.bulletActiveClass)) ? O.setAttribute("aria-current", "true") : O.removeAttribute("aria-current")
            }
        )
    }
    const E = (k,O,N)=>{
            l(k),
            k.tagName !== "BUTTON" && (u(k, "button"),
                k.addEventListener("keydown", g)),
                h(k, N),
                d(k, O)
        }
        , T = ()=>{
            t.a11y.clicked = !0
        }
        , P = ()=>{
            requestAnimationFrame(()=>{
                    requestAnimationFrame(()=>{
                            t.destroyed || (t.a11y.clicked = !1)
                        }
                    )
                }
            )
        }
        , I = k=>{
            if (t.a11y.clicked)
                return;
            const O = k.target.closest(`.${t.params.slideClass}, swiper-slide`);
            if (!O || !t.slides.includes(O))
                return;
            const N = t.slides.indexOf(O) === t.activeIndex
                , D = t.params.watchSlidesProgress && t.visibleSlides && t.visibleSlides.includes(O);
            N || D || k.sourceCapabilities && k.sourceCapabilities.firesTouchEvents || (t.isHorizontal() ? t.el.scrollLeft = 0 : t.el.scrollTop = 0,
                t.slideTo(t.slides.indexOf(O), 0))
        }
        , L = ()=>{
            const k = t.params.a11y;
            k.itemRoleDescriptionMessage && f(t.slides, k.itemRoleDescriptionMessage),
            k.slideRole && u(t.slides, k.slideRole);
            const O = t.slides.length;
            k.slideLabelMessage && t.slides.forEach((N,D)=>{
                    const W = t.params.loop ? parseInt(N.getAttribute("data-swiper-slide-index"), 10) : D
                        , G = k.slideLabelMessage.replace(/\{\{index\}\}/, W + 1).replace(/\{\{slidesLength\}\}/, O);
                    h(N, G)
                }
            )
        }
        , x = ()=>{
            const k = t.params.a11y;
            t.el.append(i);
            const O = t.el;
            k.containerRoleDescriptionMessage && f(O, k.containerRoleDescriptionMessage),
            k.containerMessage && h(O, k.containerMessage);
            const N = t.wrapperEl
                , D = k.id || N.getAttribute("id") || `swiper-wrapper-${a(16)}`
                , W = t.params.autoplay && t.params.autoplay.enabled ? "off" : "polite";
            y(N, D),
                p(N, W),
                L();
            let {nextEl: G, prevEl: le} = t.navigation ? t.navigation : {};
            G = o(G),
                le = o(le),
            G && G.forEach(ge=>E(ge, D, k.nextSlideMessage)),
            le && le.forEach(ge=>E(ge, D, k.prevSlideMessage)),
            S() && (Array.isArray(t.pagination.el) ? t.pagination.el : [t.pagination.el]).forEach(ye=>{
                    ye.addEventListener("keydown", g)
                }
            ),
                t.el.addEventListener("focus", I, !0),
                t.el.addEventListener("pointerdown", T, !0),
                t.el.addEventListener("pointerup", P, !0)
        }
    ;
    function A() {
        i && i.remove();
        let {nextEl: k, prevEl: O} = t.navigation ? t.navigation : {};
        k = o(k),
            O = o(O),
        k && k.forEach(N=>N.removeEventListener("keydown", g)),
        O && O.forEach(N=>N.removeEventListener("keydown", g)),
        S() && (Array.isArray(t.pagination.el) ? t.pagination.el : [t.pagination.el]).forEach(D=>{
                D.removeEventListener("keydown", g)
            }
        ),
            t.el.removeEventListener("focus", I, !0),
            t.el.removeEventListener("pointerdown", T, !0),
            t.el.removeEventListener("pointerup", P, !0)
    }
    r("beforeInit", ()=>{
            i = wn("span", t.params.a11y.notificationClass),
                i.setAttribute("aria-live", "assertive"),
                i.setAttribute("aria-atomic", "true")
        }
    ),
        r("afterInit", ()=>{
                t.params.a11y.enabled && x()
            }
        ),
        r("slidesLengthChange snapGridLengthChange slidesGridLengthChange", ()=>{
                t.params.a11y.enabled && L()
            }
        ),
        r("fromEdge toEdge afterInit lock unlock", ()=>{
                t.params.a11y.enabled && b()
            }
        ),
        r("paginationUpdate", ()=>{
                t.params.a11y.enabled && _()
            }
        ),
        r("destroy", ()=>{
                t.params.a11y.enabled && A()
            }
        )
}
function o2(e) {
    let {swiper: t, extendParams: n, on: r} = e;
    n({
        history: {
            enabled: !1,
            root: "",
            replaceState: !1,
            key: "slides",
            keepQuery: !1
        }
    });
    let i = !1
        , s = {};
    const o = h=>h.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, "")
        , a = h=>{
            const y = ot();
            let p;
            h ? p = new URL(h) : p = y.location;
            const w = p.pathname.slice(1).split("/").filter(v=>v !== "")
                , m = w.length
                , g = w[m - 2]
                , b = w[m - 1];
            return {
                key: g,
                value: b
            }
        }
        , l = (h,y)=>{
            const p = ot();
            if (!i || !t.params.history.enabled)
                return;
            let w;
            t.params.url ? w = new URL(t.params.url) : w = p.location;
            const m = t.slides[y];
            let g = o(m.getAttribute("data-history"));
            if (t.params.history.root.length > 0) {
                let v = t.params.history.root;
                v[v.length - 1] === "/" && (v = v.slice(0, v.length - 1)),
                    g = `${v}/${h ? `${h}/` : ""}${g}`
            } else
                w.pathname.includes(h) || (g = `${h ? `${h}/` : ""}${g}`);
            t.params.history.keepQuery && (g += w.search);
            const b = p.history.state;
            b && b.value === g || (t.params.history.replaceState ? p.history.replaceState({
                value: g
            }, null, g) : p.history.pushState({
                value: g
            }, null, g))
        }
        , c = (h,y,p)=>{
            if (y)
                for (let w = 0, m = t.slides.length; w < m; w += 1) {
                    const g = t.slides[w];
                    if (o(g.getAttribute("data-history")) === y) {
                        const v = t.getSlideIndex(g);
                        t.slideTo(v, h, p)
                    }
                }
            else
                t.slideTo(0, h, p)
        }
        , u = ()=>{
            s = a(t.params.url),
                c(t.params.speed, s.value, !1)
        }
        , f = ()=>{
            const h = ot();
            if (t.params.history) {
                if (!h.history || !h.history.pushState) {
                    t.params.history.enabled = !1,
                        t.params.hashNavigation.enabled = !0;
                    return
                }
                if (i = !0,
                    s = a(t.params.url),
                !s.key && !s.value) {
                    t.params.history.replaceState || h.addEventListener("popstate", u);
                    return
                }
                c(0, s.value, t.params.runCallbacksOnInit),
                t.params.history.replaceState || h.addEventListener("popstate", u)
            }
        }
        , d = ()=>{
            const h = ot();
            t.params.history.replaceState || h.removeEventListener("popstate", u)
        }
    ;
    r("init", ()=>{
            t.params.history.enabled && f()
        }
    ),
        r("destroy", ()=>{
                t.params.history.enabled && d()
            }
        ),
        r("transitionEnd _freeModeNoMomentumRelease", ()=>{
                i && l(t.params.history.key, t.activeIndex)
            }
        ),
        r("slideChange", ()=>{
                i && t.params.cssMode && l(t.params.history.key, t.activeIndex)
            }
        )
}
function a2(e) {
    let {swiper: t, extendParams: n, emit: r, on: i} = e
        , s = !1;
    const o = Rt()
        , a = ot();
    n({
        hashNavigation: {
            enabled: !1,
            replaceState: !1,
            watchState: !1,
            getSlideIndex(d, h) {
                if (t.virtual && t.params.virtual.enabled) {
                    const y = t.slides.filter(w=>w.getAttribute("data-hash") === h)[0];
                    return y ? parseInt(y.getAttribute("data-swiper-slide-index"), 10) : 0
                }
                return t.getSlideIndex(xt(t.slidesEl, `.${t.params.slideClass}[data-hash="${h}"], swiper-slide[data-hash="${h}"]`)[0])
            }
        }
    });
    const l = ()=>{
            r("hashChange");
            const d = o.location.hash.replace("#", "")
                , h = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${t.activeIndex}"]`) : t.slides[t.activeIndex]
                , y = h ? h.getAttribute("data-hash") : "";
            if (d !== y) {
                const p = t.params.hashNavigation.getSlideIndex(t, d);
                if (typeof p > "u" || Number.isNaN(p))
                    return;
                t.slideTo(p)
            }
        }
        , c = ()=>{
            if (!s || !t.params.hashNavigation.enabled)
                return;
            const d = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${t.activeIndex}"]`) : t.slides[t.activeIndex]
                , h = d ? d.getAttribute("data-hash") || d.getAttribute("data-history") : "";
            t.params.hashNavigation.replaceState && a.history && a.history.replaceState ? (a.history.replaceState(null, null, `#${h}` || ""),
                r("hashSet")) : (o.location.hash = h || "",
                r("hashSet"))
        }
        , u = ()=>{
            if (!t.params.hashNavigation.enabled || t.params.history && t.params.history.enabled)
                return;
            s = !0;
            const d = o.location.hash.replace("#", "");
            if (d) {
                const y = t.params.hashNavigation.getSlideIndex(t, d);
                t.slideTo(y || 0, 0, t.params.runCallbacksOnInit, !0)
            }
            t.params.hashNavigation.watchState && a.addEventListener("hashchange", l)
        }
        , f = ()=>{
            t.params.hashNavigation.watchState && a.removeEventListener("hashchange", l)
        }
    ;
    i("init", ()=>{
            t.params.hashNavigation.enabled && u()
        }
    ),
        i("destroy", ()=>{
                t.params.hashNavigation.enabled && f()
            }
        ),
        i("transitionEnd _freeModeNoMomentumRelease", ()=>{
                s && c()
            }
        ),
        i("slideChange", ()=>{
                s && t.params.cssMode && c()
            }
        )
}
function l2(e) {
    let {swiper: t, extendParams: n, on: r, emit: i, params: s} = e;
    t.autoplay = {
        running: !1,
        paused: !1,
        timeLeft: 0
    },
        n({
            autoplay: {
                enabled: !1,
                delay: 3e3,
                waitForTransition: !0,
                disableOnInteraction: !0,
                stopOnLastSlide: !1,
                reverseDirection: !1,
                pauseOnMouseEnter: !1
            }
        });
    let o, a, l = s && s.autoplay ? s.autoplay.delay : 3e3, c = s && s.autoplay ? s.autoplay.delay : 3e3, u, f = new Date().getTime, d, h, y, p, w, m;
    function g(D) {
        !t || t.destroyed || !t.wrapperEl || D.target === t.wrapperEl && (t.wrapperEl.removeEventListener("transitionend", g),
            P())
    }
    const b = ()=>{
            if (t.destroyed || !t.autoplay.running)
                return;
            t.autoplay.paused ? d = !0 : d && (c = u,
                d = !1);
            const D = t.autoplay.paused ? u : f + c - new Date().getTime();
            t.autoplay.timeLeft = D,
                i("autoplayTimeLeft", D, D / l),
                a = requestAnimationFrame(()=>{
                        b()
                    }
                )
        }
        , v = ()=>{
            let D;
            return t.virtual && t.params.virtual.enabled ? D = t.slides.filter(G=>G.classList.contains("swiper-slide-active"))[0] : D = t.slides[t.activeIndex],
                D ? parseInt(D.getAttribute("data-swiper-autoplay"), 10) : void 0
        }
        , S = D=>{
            if (t.destroyed || !t.autoplay.running)
                return;
            cancelAnimationFrame(a),
                b();
            let W = typeof D > "u" ? t.params.autoplay.delay : D;
            l = t.params.autoplay.delay,
                c = t.params.autoplay.delay;
            const G = v();
            !Number.isNaN(G) && G > 0 && typeof D > "u" && (W = G,
                l = G,
                c = G),
                u = W;
            const le = t.params.speed
                , ge = ()=>{
                    !t || t.destroyed || (t.params.autoplay.reverseDirection ? !t.isBeginning || t.params.loop || t.params.rewind ? (t.slidePrev(le, !0, !0),
                        i("autoplay")) : t.params.autoplay.stopOnLastSlide || (t.slideTo(t.slides.length - 1, le, !0, !0),
                        i("autoplay")) : !t.isEnd || t.params.loop || t.params.rewind ? (t.slideNext(le, !0, !0),
                        i("autoplay")) : t.params.autoplay.stopOnLastSlide || (t.slideTo(0, le, !0, !0),
                        i("autoplay")),
                    t.params.cssMode && (f = new Date().getTime(),
                        requestAnimationFrame(()=>{
                                S()
                            }
                        )))
                }
            ;
            return W > 0 ? (clearTimeout(o),
                o = setTimeout(()=>{
                        ge()
                    }
                    , W)) : requestAnimationFrame(()=>{
                    ge()
                }
            ),
                W
        }
        , _ = ()=>{
            t.autoplay.running = !0,
                S(),
                i("autoplayStart")
        }
        , E = ()=>{
            t.autoplay.running = !1,
                clearTimeout(o),
                cancelAnimationFrame(a),
                i("autoplayStop")
        }
        , T = (D,W)=>{
            if (t.destroyed || !t.autoplay.running)
                return;
            clearTimeout(o),
            D || (m = !0);
            const G = ()=>{
                    i("autoplayPause"),
                        t.params.autoplay.waitForTransition ? t.wrapperEl.addEventListener("transitionend", g) : P()
                }
            ;
            if (t.autoplay.paused = !0,
                W) {
                w && (u = t.params.autoplay.delay),
                    w = !1,
                    G();
                return
            }
            u = (u || t.params.autoplay.delay) - (new Date().getTime() - f),
            !(t.isEnd && u < 0 && !t.params.loop) && (u < 0 && (u = 0),
                G())
        }
        , P = ()=>{
            t.isEnd && u < 0 && !t.params.loop || t.destroyed || !t.autoplay.running || (f = new Date().getTime(),
                m ? (m = !1,
                    S(u)) : S(),
                t.autoplay.paused = !1,
                i("autoplayResume"))
        }
        , I = ()=>{
            if (t.destroyed || !t.autoplay.running)
                return;
            const D = Rt();
            D.visibilityState === "hidden" && (m = !0,
                T(!0)),
            D.visibilityState === "visible" && P()
        }
        , L = D=>{
            D.pointerType === "mouse" && (m = !0,
                T(!0))
        }
        , x = D=>{
            D.pointerType === "mouse" && t.autoplay.paused && P()
        }
        , A = ()=>{
            t.params.autoplay.pauseOnMouseEnter && (t.el.addEventListener("pointerenter", L),
                t.el.addEventListener("pointerleave", x))
        }
        , k = ()=>{
            t.el.removeEventListener("pointerenter", L),
                t.el.removeEventListener("pointerleave", x)
        }
        , O = ()=>{
            Rt().addEventListener("visibilitychange", I)
        }
        , N = ()=>{
            Rt().removeEventListener("visibilitychange", I)
        }
    ;
    r("init", ()=>{
            t.params.autoplay.enabled && (A(),
                O(),
                f = new Date().getTime(),
                _())
        }
    ),
        r("destroy", ()=>{
                k(),
                    N(),
                t.autoplay.running && E()
            }
        ),
        r("beforeTransitionStart", (D,W,G)=>{
                t.destroyed || !t.autoplay.running || (G || !t.params.autoplay.disableOnInteraction ? T(!0, !0) : E())
            }
        ),
        r("sliderFirstMove", ()=>{
                if (!(t.destroyed || !t.autoplay.running)) {
                    if (t.params.autoplay.disableOnInteraction) {
                        E();
                        return
                    }
                    h = !0,
                        y = !1,
                        m = !1,
                        p = setTimeout(()=>{
                                m = !0,
                                    y = !0,
                                    T(!0)
                            }
                            , 200)
                }
            }
        ),
        r("touchEnd", ()=>{
                if (!(t.destroyed || !t.autoplay.running || !h)) {
                    if (clearTimeout(p),
                        clearTimeout(o),
                        t.params.autoplay.disableOnInteraction) {
                        y = !1,
                            h = !1;
                        return
                    }
                    y && t.params.cssMode && P(),
                        y = !1,
                        h = !1
                }
            }
        ),
        r("slideChange", ()=>{
                t.destroyed || !t.autoplay.running || (w = !0)
            }
        ),
        Object.assign(t.autoplay, {
            start: _,
            stop: E,
            pause: T,
            resume: P
        })
}
function c2(e) {
    let {swiper: t, extendParams: n, on: r} = e;
    n({
        thumbs: {
            swiper: null,
            multipleActiveThumbs: !0,
            autoScrollOffset: 0,
            slideThumbActiveClass: "swiper-slide-thumb-active",
            thumbsContainerClass: "swiper-thumbs"
        }
    });
    let i = !1
        , s = !1;
    t.thumbs = {
        swiper: null
    };
    function o() {
        const c = t.thumbs.swiper;
        if (!c || c.destroyed)
            return;
        const u = c.clickedIndex
            , f = c.clickedSlide;
        if (f && f.classList.contains(t.params.thumbs.slideThumbActiveClass) || typeof u > "u" || u === null)
            return;
        let d;
        c.params.loop ? d = parseInt(c.clickedSlide.getAttribute("data-swiper-slide-index"), 10) : d = u,
            t.params.loop ? t.slideToLoop(d) : t.slideTo(d)
    }
    function a() {
        const {thumbs: c} = t.params;
        if (i)
            return !1;
        i = !0;
        const u = t.constructor;
        if (c.swiper instanceof u)
            t.thumbs.swiper = c.swiper,
                Object.assign(t.thumbs.swiper.originalParams, {
                    watchSlidesProgress: !0,
                    slideToClickedSlide: !1
                }),
                Object.assign(t.thumbs.swiper.params, {
                    watchSlidesProgress: !0,
                    slideToClickedSlide: !1
                }),
                t.thumbs.swiper.update();
        else if (ds(c.swiper)) {
            const f = Object.assign({}, c.swiper);
            Object.assign(f, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1
            }),
                t.thumbs.swiper = new u(f),
                s = !0
        }
        return t.thumbs.swiper.el.classList.add(t.params.thumbs.thumbsContainerClass),
            t.thumbs.swiper.on("tap", o),
            !0
    }
    function l(c) {
        const u = t.thumbs.swiper;
        if (!u || u.destroyed)
            return;
        const f = u.params.slidesPerView === "auto" ? u.slidesPerViewDynamic() : u.params.slidesPerView;
        let d = 1;
        const h = t.params.thumbs.slideThumbActiveClass;
        if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (d = t.params.slidesPerView),
        t.params.thumbs.multipleActiveThumbs || (d = 1),
            d = Math.floor(d),
            u.slides.forEach(w=>w.classList.remove(h)),
        u.params.loop || u.params.virtual && u.params.virtual.enabled)
            for (let w = 0; w < d; w += 1)
                xt(u.slidesEl, `[data-swiper-slide-index="${t.realIndex + w}"]`).forEach(m=>{
                        m.classList.add(h)
                    }
                );
        else
            for (let w = 0; w < d; w += 1)
                u.slides[t.realIndex + w] && u.slides[t.realIndex + w].classList.add(h);
        const y = t.params.thumbs.autoScrollOffset
            , p = y && !u.params.loop;
        if (t.realIndex !== u.realIndex || p) {
            const w = u.activeIndex;
            let m, g;
            if (u.params.loop) {
                const b = u.slides.filter(v=>v.getAttribute("data-swiper-slide-index") === `${t.realIndex}`)[0];
                m = u.slides.indexOf(b),
                    g = t.activeIndex > t.previousIndex ? "next" : "prev"
            } else
                m = t.realIndex,
                    g = m > t.previousIndex ? "next" : "prev";
            p && (m += g === "next" ? y : -1 * y),
            u.visibleSlidesIndexes && u.visibleSlidesIndexes.indexOf(m) < 0 && (u.params.centeredSlides ? m > w ? m = m - Math.floor(f / 2) + 1 : m = m + Math.floor(f / 2) - 1 : m > w && u.params.slidesPerGroup,
                u.slideTo(m, c ? 0 : void 0))
        }
    }
    r("beforeInit", ()=>{
            const {thumbs: c} = t.params;
            if (!(!c || !c.swiper))
                if (typeof c.swiper == "string" || c.swiper instanceof HTMLElement) {
                    const u = Rt()
                        , f = ()=>{
                            const h = typeof c.swiper == "string" ? u.querySelector(c.swiper) : c.swiper;
                            if (h && h.swiper)
                                c.swiper = h.swiper,
                                    a(),
                                    l(!0);
                            else if (h) {
                                const y = p=>{
                                        c.swiper = p.detail[0],
                                            h.removeEventListener("init", y),
                                            a(),
                                            l(!0),
                                            c.swiper.update(),
                                            t.update()
                                    }
                                ;
                                h.addEventListener("init", y)
                            }
                            return h
                        }
                        , d = ()=>{
                            if (t.destroyed)
                                return;
                            f() || requestAnimationFrame(d)
                        }
                    ;
                    requestAnimationFrame(d)
                } else
                    a(),
                        l(!0)
        }
    ),
        r("slideChange update resize observerUpdate", ()=>{
                l()
            }
        ),
        r("setTransition", (c,u)=>{
                const f = t.thumbs.swiper;
                !f || f.destroyed || f.setTransition(u)
            }
        ),
        r("beforeDestroy", ()=>{
                const c = t.thumbs.swiper;
                !c || c.destroyed || s && c.destroy()
            }
        ),
        Object.assign(t.thumbs, {
            init: a,
            update: l
        })
}
function u2(e) {
    let {swiper: t, extendParams: n, emit: r, once: i} = e;
    n({
        freeMode: {
            enabled: !1,
            momentum: !0,
            momentumRatio: 1,
            momentumBounce: !0,
            momentumBounceRatio: 1,
            momentumVelocityRatio: 1,
            sticky: !1,
            minimumVelocity: .02
        }
    });
    function s() {
        if (t.params.cssMode)
            return;
        const l = t.getTranslate();
        t.setTranslate(l),
            t.setTransition(0),
            t.touchEventsData.velocities.length = 0,
            t.freeMode.onTouchEnd({
                currentPos: t.rtl ? t.translate : -t.translate
            })
    }
    function o() {
        if (t.params.cssMode)
            return;
        const {touchEventsData: l, touches: c} = t;
        l.velocities.length === 0 && l.velocities.push({
            position: c[t.isHorizontal() ? "startX" : "startY"],
            time: l.touchStartTime
        }),
            l.velocities.push({
                position: c[t.isHorizontal() ? "currentX" : "currentY"],
                time: un()
            })
    }
    function a(l) {
        let {currentPos: c} = l;
        if (t.params.cssMode)
            return;
        const {params: u, wrapperEl: f, rtlTranslate: d, snapGrid: h, touchEventsData: y} = t
            , w = un() - y.touchStartTime;
        if (c < -t.minTranslate()) {
            t.slideTo(t.activeIndex);
            return
        }
        if (c > -t.maxTranslate()) {
            t.slides.length < h.length ? t.slideTo(h.length - 1) : t.slideTo(t.slides.length - 1);
            return
        }
        if (u.freeMode.momentum) {
            if (y.velocities.length > 1) {
                const T = y.velocities.pop()
                    , P = y.velocities.pop()
                    , I = T.position - P.position
                    , L = T.time - P.time;
                t.velocity = I / L,
                    t.velocity /= 2,
                Math.abs(t.velocity) < u.freeMode.minimumVelocity && (t.velocity = 0),
                (L > 150 || un() - T.time > 300) && (t.velocity = 0)
            } else
                t.velocity = 0;
            t.velocity *= u.freeMode.momentumVelocityRatio,
                y.velocities.length = 0;
            let m = 1e3 * u.freeMode.momentumRatio;
            const g = t.velocity * m;
            let b = t.translate + g;
            d && (b = -b);
            let v = !1, S;
            const _ = Math.abs(t.velocity) * 20 * u.freeMode.momentumBounceRatio;
            let E;
            if (b < t.maxTranslate())
                u.freeMode.momentumBounce ? (b + t.maxTranslate() < -_ && (b = t.maxTranslate() - _),
                    S = t.maxTranslate(),
                    v = !0,
                    y.allowMomentumBounce = !0) : b = t.maxTranslate(),
                u.loop && u.centeredSlides && (E = !0);
            else if (b > t.minTranslate())
                u.freeMode.momentumBounce ? (b - t.minTranslate() > _ && (b = t.minTranslate() + _),
                    S = t.minTranslate(),
                    v = !0,
                    y.allowMomentumBounce = !0) : b = t.minTranslate(),
                u.loop && u.centeredSlides && (E = !0);
            else if (u.freeMode.sticky) {
                let T;
                for (let P = 0; P < h.length; P += 1)
                    if (h[P] > -b) {
                        T = P;
                        break
                    }
                Math.abs(h[T] - b) < Math.abs(h[T - 1] - b) || t.swipeDirection === "next" ? b = h[T] : b = h[T - 1],
                    b = -b
            }
            if (E && i("transitionEnd", ()=>{
                    t.loopFix()
                }
            ),
            t.velocity !== 0) {
                if (d ? m = Math.abs((-b - t.translate) / t.velocity) : m = Math.abs((b - t.translate) / t.velocity),
                    u.freeMode.sticky) {
                    const T = Math.abs((d ? -b : b) - t.translate)
                        , P = t.slidesSizesGrid[t.activeIndex];
                    T < P ? m = u.speed : T < 2 * P ? m = u.speed * 1.5 : m = u.speed * 2.5
                }
            } else if (u.freeMode.sticky) {
                t.slideToClosest();
                return
            }
            u.freeMode.momentumBounce && v ? (t.updateProgress(S),
                t.setTransition(m),
                t.setTranslate(b),
                t.transitionStart(!0, t.swipeDirection),
                t.animating = !0,
                Ts(f, ()=>{
                        !t || t.destroyed || !y.allowMomentumBounce || (r("momentumBounce"),
                            t.setTransition(u.speed),
                            setTimeout(()=>{
                                    t.setTranslate(S),
                                        Ts(f, ()=>{
                                                !t || t.destroyed || t.transitionEnd()
                                            }
                                        )
                                }
                                , 0))
                    }
                )) : t.velocity ? (r("_freeModeNoMomentumRelease"),
                t.updateProgress(b),
                t.setTransition(m),
                t.setTranslate(b),
                t.transitionStart(!0, t.swipeDirection),
            t.animating || (t.animating = !0,
                Ts(f, ()=>{
                        !t || t.destroyed || t.transitionEnd()
                    }
                ))) : t.updateProgress(b),
                t.updateActiveIndex(),
                t.updateSlidesClasses()
        } else if (u.freeMode.sticky) {
            t.slideToClosest();
            return
        } else
            u.freeMode && r("_freeModeNoMomentumRelease");
        (!u.freeMode.momentum || w >= u.longSwipesMs) && (t.updateProgress(),
            t.updateActiveIndex(),
            t.updateSlidesClasses())
    }
    Object.assign(t, {
        freeMode: {
            onTouchStart: s,
            onTouchMove: o,
            onTouchEnd: a
        }
    })
}
function f2(e) {
    let {swiper: t, extendParams: n} = e;
    n({
        grid: {
            rows: 1,
            fill: "column"
        }
    });
    let r, i, s;
    const o = ()=>{
            let u = t.params.spaceBetween;
            return typeof u == "string" && u.indexOf("%") >= 0 ? u = parseFloat(u.replace("%", "")) / 100 * t.size : typeof u == "string" && (u = parseFloat(u)),
                u
        }
        , a = u=>{
            const {slidesPerView: f} = t.params
                , {rows: d, fill: h} = t.params.grid;
            s = Math.floor(u / d),
                Math.floor(u / d) === u / d ? r = u : r = Math.ceil(u / d) * d,
            f !== "auto" && h === "row" && (r = Math.max(r, f * d)),
                i = r / d
        }
        , l = (u,f,d,h)=>{
            const {slidesPerGroup: y} = t.params
                , p = o()
                , {rows: w, fill: m} = t.params.grid;
            let g, b, v;
            if (m === "row" && y > 1) {
                const S = Math.floor(u / (y * w))
                    , _ = u - w * y * S
                    , E = S === 0 ? y : Math.min(Math.ceil((d - S * w * y) / w), y);
                v = Math.floor(_ / E),
                    b = _ - v * E + S * y,
                    g = b + v * r / w,
                    f.style.order = g
            } else
                m === "column" ? (b = Math.floor(u / w),
                    v = u - b * w,
                (b > s || b === s && v === w - 1) && (v += 1,
                v >= w && (v = 0,
                    b += 1))) : (v = Math.floor(u / i),
                    b = u - v * i);
            f.row = v,
                f.column = b,
                f.style[h("margin-top")] = v !== 0 ? p && `${p}px` : ""
        }
        , c = (u,f,d)=>{
            const {centeredSlides: h, roundLengths: y} = t.params
                , p = o()
                , {rows: w} = t.params.grid;
            if (t.virtualSize = (u + p) * r,
                t.virtualSize = Math.ceil(t.virtualSize / w) - p,
                t.wrapperEl.style[d("width")] = `${t.virtualSize + p}px`,
                h) {
                const m = [];
                for (let g = 0; g < f.length; g += 1) {
                    let b = f[g];
                    y && (b = Math.floor(b)),
                    f[g] < t.virtualSize + f[0] && m.push(b)
                }
                f.splice(0, f.length),
                    f.push(...m)
            }
        }
    ;
    t.grid = {
        initSlides: a,
        updateSlide: l,
        updateWrapperSize: c
    }
}
function d2(e) {
    const t = this
        , {params: n, slidesEl: r} = t;
    n.loop && t.loopDestroy();
    const i = s=>{
            if (typeof s == "string") {
                const o = document.createElement("div");
                o.innerHTML = s,
                    r.append(o.children[0]),
                    o.innerHTML = ""
            } else
                r.append(s)
        }
    ;
    if (typeof e == "object" && "length"in e)
        for (let s = 0; s < e.length; s += 1)
            e[s] && i(e[s]);
    else
        i(e);
    t.recalcSlides(),
    n.loop && t.loopCreate(),
    (!n.observer || t.isElement) && t.update()
}
function p2(e) {
    const t = this
        , {params: n, activeIndex: r, slidesEl: i} = t;
    n.loop && t.loopDestroy();
    let s = r + 1;
    const o = a=>{
            if (typeof a == "string") {
                const l = document.createElement("div");
                l.innerHTML = a,
                    i.prepend(l.children[0]),
                    l.innerHTML = ""
            } else
                i.prepend(a)
        }
    ;
    if (typeof e == "object" && "length"in e) {
        for (let a = 0; a < e.length; a += 1)
            e[a] && o(e[a]);
        s = r + e.length
    } else
        o(e);
    t.recalcSlides(),
    n.loop && t.loopCreate(),
    (!n.observer || t.isElement) && t.update(),
        t.slideTo(s, 0, !1)
}
function h2(e, t) {
    const n = this
        , {params: r, activeIndex: i, slidesEl: s} = n;
    let o = i;
    r.loop && (o -= n.loopedSlides,
        n.loopDestroy(),
        n.recalcSlides());
    const a = n.slides.length;
    if (e <= 0) {
        n.prependSlide(t);
        return
    }
    if (e >= a) {
        n.appendSlide(t);
        return
    }
    let l = o > e ? o + 1 : o;
    const c = [];
    for (let u = a - 1; u >= e; u -= 1) {
        const f = n.slides[u];
        f.remove(),
            c.unshift(f)
    }
    if (typeof t == "object" && "length"in t) {
        for (let u = 0; u < t.length; u += 1)
            t[u] && s.append(t[u]);
        l = o > e ? o + t.length : o
    } else
        s.append(t);
    for (let u = 0; u < c.length; u += 1)
        s.append(c[u]);
    n.recalcSlides(),
    r.loop && n.loopCreate(),
    (!r.observer || n.isElement) && n.update(),
        r.loop ? n.slideTo(l + n.loopedSlides, 0, !1) : n.slideTo(l, 0, !1)
}
function m2(e) {
    const t = this
        , {params: n, activeIndex: r} = t;
    let i = r;
    n.loop && (i -= t.loopedSlides,
        t.loopDestroy());
    let s = i, o;
    if (typeof e == "object" && "length"in e) {
        for (let a = 0; a < e.length; a += 1)
            o = e[a],
            t.slides[o] && t.slides[o].remove(),
            o < s && (s -= 1);
        s = Math.max(s, 0)
    } else
        o = e,
        t.slides[o] && t.slides[o].remove(),
        o < s && (s -= 1),
            s = Math.max(s, 0);
    t.recalcSlides(),
    n.loop && t.loopCreate(),
    (!n.observer || t.isElement) && t.update(),
        n.loop ? t.slideTo(s + t.loopedSlides, 0, !1) : t.slideTo(s, 0, !1)
}
function g2() {
    const e = this
        , t = [];
    for (let n = 0; n < e.slides.length; n += 1)
        t.push(n);
    e.removeSlide(t)
}
function v2(e) {
    let {swiper: t} = e;
    Object.assign(t, {
        appendSlide: d2.bind(t),
        prependSlide: p2.bind(t),
        addSlide: h2.bind(t),
        removeSlide: m2.bind(t),
        removeAllSlides: g2.bind(t)
    })
}
function Yi(e) {
    const {effect: t, swiper: n, on: r, setTranslate: i, setTransition: s, overwriteParams: o, perspective: a, recreateShadows: l, getEffectParams: c} = e;
    r("beforeInit", ()=>{
            if (n.params.effect !== t)
                return;
            n.classNames.push(`${n.params.containerModifierClass}${t}`),
            a && a() && n.classNames.push(`${n.params.containerModifierClass}3d`);
            const f = o ? o() : {};
            Object.assign(n.params, f),
                Object.assign(n.originalParams, f)
        }
    ),
        r("setTranslate", ()=>{
                n.params.effect === t && i()
            }
        ),
        r("setTransition", (f,d)=>{
                n.params.effect === t && s(d)
            }
        ),
        r("transitionEnd", ()=>{
                if (n.params.effect === t && l) {
                    if (!c || !c().slideShadows)
                        return;
                    n.slides.forEach(f=>{
                            f.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(d=>d.remove())
                        }
                    ),
                        l()
                }
            }
        );
    let u;
    r("virtualUpdate", ()=>{
            n.params.effect === t && (n.slides.length || (u = !0),
                requestAnimationFrame(()=>{
                        u && n.slides && n.slides.length && (i(),
                            u = !1)
                    }
                ))
        }
    )
}
function ao(e, t) {
    const n = ii(t);
    return n !== t && (n.style.backfaceVisibility = "hidden",
        n.style["-webkit-backface-visibility"] = "hidden"),
        n
}
function pl(e) {
    let {swiper: t, duration: n, transformElements: r, allSlides: i} = e;
    const {activeIndex: s} = t
        , o = a=>a.parentElement ? a.parentElement : t.slides.filter(c=>c.shadowRoot && c.shadowRoot === a.parentNode)[0];
    if (t.params.virtualTranslate && n !== 0) {
        let a = !1, l;
        i ? l = r : l = r.filter(c=>{
                const u = c.classList.contains("swiper-slide-transform") ? o(c) : c;
                return t.getSlideIndex(u) === s
            }
        ),
            l.forEach(c=>{
                    Ts(c, ()=>{
                            if (a || !t || t.destroyed)
                                return;
                            a = !0,
                                t.animating = !1;
                            const u = new window.CustomEvent("transitionend",{
                                bubbles: !0,
                                cancelable: !0
                            });
                            t.wrapperEl.dispatchEvent(u)
                        }
                    )
                }
            )
    }
}
function y2(e) {
    let {swiper: t, extendParams: n, on: r} = e;
    n({
        fadeEffect: {
            crossFade: !1
        }
    }),
        Yi({
            effect: "fade",
            swiper: t,
            on: r,
            setTranslate: ()=>{
                const {slides: o} = t
                    , a = t.params.fadeEffect;
                for (let l = 0; l < o.length; l += 1) {
                    const c = t.slides[l];
                    let f = -c.swiperSlideOffset;
                    t.params.virtualTranslate || (f -= t.translate);
                    let d = 0;
                    t.isHorizontal() || (d = f,
                        f = 0);
                    const h = t.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(c.progress), 0) : 1 + Math.min(Math.max(c.progress, -1), 0)
                        , y = ao(a, c);
                    y.style.opacity = h,
                        y.style.transform = `translate3d(${f}px, ${d}px, 0px)`
                }
            }
            ,
            setTransition: o=>{
                const a = t.slides.map(l=>ii(l));
                a.forEach(l=>{
                        l.style.transitionDuration = `${o}ms`
                    }
                ),
                    pl({
                        swiper: t,
                        duration: o,
                        transformElements: a,
                        allSlides: !0
                    })
            }
            ,
            overwriteParams: ()=>({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: !0,
                spaceBetween: 0,
                virtualTranslate: !t.params.cssMode
            })
        })
}
function b2(e) {
    let {swiper: t, extendParams: n, on: r} = e;
    n({
        cubeEffect: {
            slideShadows: !0,
            shadow: !0,
            shadowOffset: 20,
            shadowScale: .94
        }
    });
    const i = (l,c,u)=>{
            let f = u ? l.querySelector(".swiper-slide-shadow-left") : l.querySelector(".swiper-slide-shadow-top")
                , d = u ? l.querySelector(".swiper-slide-shadow-right") : l.querySelector(".swiper-slide-shadow-bottom");
            f || (f = wn("div", `swiper-slide-shadow-cube swiper-slide-shadow-${u ? "left" : "top"}`.split(" ")),
                l.append(f)),
            d || (d = wn("div", `swiper-slide-shadow-cube swiper-slide-shadow-${u ? "right" : "bottom"}`.split(" ")),
                l.append(d)),
            f && (f.style.opacity = Math.max(-c, 0)),
            d && (d.style.opacity = Math.max(c, 0))
        }
    ;
    Yi({
        effect: "cube",
        swiper: t,
        on: r,
        setTranslate: ()=>{
            const {el: l, wrapperEl: c, slides: u, width: f, height: d, rtlTranslate: h, size: y, browser: p} = t
                , w = t.params.cubeEffect
                , m = t.isHorizontal()
                , g = t.virtual && t.params.virtual.enabled;
            let b = 0, v;
            w.shadow && (m ? (v = t.wrapperEl.querySelector(".swiper-cube-shadow"),
            v || (v = wn("div", "swiper-cube-shadow"),
                t.wrapperEl.append(v)),
                v.style.height = `${f}px`) : (v = l.querySelector(".swiper-cube-shadow"),
            v || (v = wn("div", "swiper-cube-shadow"),
                l.append(v))));
            for (let _ = 0; _ < u.length; _ += 1) {
                const E = u[_];
                let T = _;
                g && (T = parseInt(E.getAttribute("data-swiper-slide-index"), 10));
                let P = T * 90
                    , I = Math.floor(P / 360);
                h && (P = -P,
                    I = Math.floor(-P / 360));
                const L = Math.max(Math.min(E.progress, 1), -1);
                let x = 0
                    , A = 0
                    , k = 0;
                T % 4 === 0 ? (x = -I * 4 * y,
                    k = 0) : (T - 1) % 4 === 0 ? (x = 0,
                    k = -I * 4 * y) : (T - 2) % 4 === 0 ? (x = y + I * 4 * y,
                    k = y) : (T - 3) % 4 === 0 && (x = -y,
                    k = 3 * y + y * 4 * I),
                h && (x = -x),
                m || (A = x,
                    x = 0);
                const O = `rotateX(${m ? 0 : -P}deg) rotateY(${m ? P : 0}deg) translate3d(${x}px, ${A}px, ${k}px)`;
                L <= 1 && L > -1 && (b = T * 90 + L * 90,
                h && (b = -T * 90 - L * 90)),
                    E.style.transform = O,
                w.slideShadows && i(E, L, m)
            }
            if (c.style.transformOrigin = `50% 50% -${y / 2}px`,
                c.style["-webkit-transform-origin"] = `50% 50% -${y / 2}px`,
                w.shadow)
                if (m)
                    v.style.transform = `translate3d(0px, ${f / 2 + w.shadowOffset}px, ${-f / 2}px) rotateX(90deg) rotateZ(0deg) scale(${w.shadowScale})`;
                else {
                    const _ = Math.abs(b) - Math.floor(Math.abs(b) / 90) * 90
                        , E = 1.5 - (Math.sin(_ * 2 * Math.PI / 360) / 2 + Math.cos(_ * 2 * Math.PI / 360) / 2)
                        , T = w.shadowScale
                        , P = w.shadowScale / E
                        , I = w.shadowOffset;
                    v.style.transform = `scale3d(${T}, 1, ${P}) translate3d(0px, ${d / 2 + I}px, ${-d / 2 / P}px) rotateX(-90deg)`
                }
            const S = (p.isSafari || p.isWebView) && p.needPerspectiveFix ? -y / 2 : 0;
            c.style.transform = `translate3d(0px,0,${S}px) rotateX(${t.isHorizontal() ? 0 : b}deg) rotateY(${t.isHorizontal() ? -b : 0}deg)`,
                c.style.setProperty("--swiper-cube-translate-z", `${S}px`)
        }
        ,
        setTransition: l=>{
            const {el: c, slides: u} = t;
            if (u.forEach(f=>{
                    f.style.transitionDuration = `${l}ms`,
                        f.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(d=>{
                                d.style.transitionDuration = `${l}ms`
                            }
                        )
                }
            ),
            t.params.cubeEffect.shadow && !t.isHorizontal()) {
                const f = c.querySelector(".swiper-cube-shadow");
                f && (f.style.transitionDuration = `${l}ms`)
            }
        }
        ,
        recreateShadows: ()=>{
            const l = t.isHorizontal();
            t.slides.forEach(c=>{
                    const u = Math.max(Math.min(c.progress, 1), -1);
                    i(c, u, l)
                }
            )
        }
        ,
        getEffectParams: ()=>t.params.cubeEffect,
        perspective: ()=>!0,
        overwriteParams: ()=>({
            slidesPerView: 1,
            slidesPerGroup: 1,
            watchSlidesProgress: !0,
            resistanceRatio: 0,
            spaceBetween: 0,
            centeredSlides: !1,
            virtualTranslate: !0
        })
    })
}
function Hi(e, t, n) {
    const r = `swiper-slide-shadow ${n ? `-${n}` : ""}${e ? ` swiper-slide-shadow-${e}` : ""}`
        , i = ii(t);
    let s = i.querySelector(`.${r.split(" ").join(".")}`);
    return s || (s = wn("div", r.split(" ")),
        i.append(s)),
        s
}
function w2(e) {
    let {swiper: t, extendParams: n, on: r} = e;
    n({
        flipEffect: {
            slideShadows: !0,
            limitRotation: !0
        }
    });
    const i = (l,c)=>{
            let u = t.isHorizontal() ? l.querySelector(".swiper-slide-shadow-left") : l.querySelector(".swiper-slide-shadow-top")
                , f = t.isHorizontal() ? l.querySelector(".swiper-slide-shadow-right") : l.querySelector(".swiper-slide-shadow-bottom");
            u || (u = Hi("flip", l, t.isHorizontal() ? "left" : "top")),
            f || (f = Hi("flip", l, t.isHorizontal() ? "right" : "bottom")),
            u && (u.style.opacity = Math.max(-c, 0)),
            f && (f.style.opacity = Math.max(c, 0))
        }
    ;
    Yi({
        effect: "flip",
        swiper: t,
        on: r,
        setTranslate: ()=>{
            const {slides: l, rtlTranslate: c} = t
                , u = t.params.flipEffect;
            for (let f = 0; f < l.length; f += 1) {
                const d = l[f];
                let h = d.progress;
                t.params.flipEffect.limitRotation && (h = Math.max(Math.min(d.progress, 1), -1));
                const y = d.swiperSlideOffset;
                let w = -180 * h
                    , m = 0
                    , g = t.params.cssMode ? -y - t.translate : -y
                    , b = 0;
                t.isHorizontal() ? c && (w = -w) : (b = g,
                    g = 0,
                    m = -w,
                    w = 0),
                    d.style.zIndex = -Math.abs(Math.round(h)) + l.length,
                u.slideShadows && i(d, h);
                const v = `translate3d(${g}px, ${b}px, 0px) rotateX(${m}deg) rotateY(${w}deg)`
                    , S = ao(u, d);
                S.style.transform = v
            }
        }
        ,
        setTransition: l=>{
            const c = t.slides.map(u=>ii(u));
            c.forEach(u=>{
                    u.style.transitionDuration = `${l}ms`,
                        u.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(f=>{
                                f.style.transitionDuration = `${l}ms`
                            }
                        )
                }
            ),
                pl({
                    swiper: t,
                    duration: l,
                    transformElements: c
                })
        }
        ,
        recreateShadows: ()=>{
            t.params.flipEffect,
                t.slides.forEach(l=>{
                        let c = l.progress;
                        t.params.flipEffect.limitRotation && (c = Math.max(Math.min(l.progress, 1), -1)),
                            i(l, c)
                    }
                )
        }
        ,
        getEffectParams: ()=>t.params.flipEffect,
        perspective: ()=>!0,
        overwriteParams: ()=>({
            slidesPerView: 1,
            slidesPerGroup: 1,
            watchSlidesProgress: !0,
            spaceBetween: 0,
            virtualTranslate: !t.params.cssMode
        })
    })
}
function S2(e) {
    let {swiper: t, extendParams: n, on: r} = e;
    n({
        coverflowEffect: {
            rotate: 50,
            stretch: 0,
            depth: 100,
            scale: 1,
            modifier: 1,
            slideShadows: !0
        }
    }),
        Yi({
            effect: "coverflow",
            swiper: t,
            on: r,
            setTranslate: ()=>{
                const {width: o, height: a, slides: l, slidesSizesGrid: c} = t
                    , u = t.params.coverflowEffect
                    , f = t.isHorizontal()
                    , d = t.translate
                    , h = f ? -d + o / 2 : -d + a / 2
                    , y = f ? u.rotate : -u.rotate
                    , p = u.depth;
                for (let w = 0, m = l.length; w < m; w += 1) {
                    const g = l[w]
                        , b = c[w]
                        , v = g.swiperSlideOffset
                        , S = (h - v - b / 2) / b
                        , _ = typeof u.modifier == "function" ? u.modifier(S) : S * u.modifier;
                    let E = f ? y * _ : 0
                        , T = f ? 0 : y * _
                        , P = -p * Math.abs(_)
                        , I = u.stretch;
                    typeof I == "string" && I.indexOf("%") !== -1 && (I = parseFloat(u.stretch) / 100 * b);
                    let L = f ? 0 : I * _
                        , x = f ? I * _ : 0
                        , A = 1 - (1 - u.scale) * Math.abs(_);
                    Math.abs(x) < .001 && (x = 0),
                    Math.abs(L) < .001 && (L = 0),
                    Math.abs(P) < .001 && (P = 0),
                    Math.abs(E) < .001 && (E = 0),
                    Math.abs(T) < .001 && (T = 0),
                    Math.abs(A) < .001 && (A = 0);
                    const k = `translate3d(${x}px,${L}px,${P}px)  rotateX(${T}deg) rotateY(${E}deg) scale(${A})`
                        , O = ao(u, g);
                    if (O.style.transform = k,
                        g.style.zIndex = -Math.abs(Math.round(_)) + 1,
                        u.slideShadows) {
                        let N = f ? g.querySelector(".swiper-slide-shadow-left") : g.querySelector(".swiper-slide-shadow-top")
                            , D = f ? g.querySelector(".swiper-slide-shadow-right") : g.querySelector(".swiper-slide-shadow-bottom");
                        N || (N = Hi("coverflow", g, f ? "left" : "top")),
                        D || (D = Hi("coverflow", g, f ? "right" : "bottom")),
                        N && (N.style.opacity = _ > 0 ? _ : 0),
                        D && (D.style.opacity = -_ > 0 ? -_ : 0)
                    }
                }
            }
            ,
            setTransition: o=>{
                t.slides.map(l=>ii(l)).forEach(l=>{
                        l.style.transitionDuration = `${o}ms`,
                            l.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(c=>{
                                    c.style.transitionDuration = `${o}ms`
                                }
                            )
                    }
                )
            }
            ,
            perspective: ()=>!0,
            overwriteParams: ()=>({
                watchSlidesProgress: !0
            })
        })
}
function _2(e) {
    let {swiper: t, extendParams: n, on: r} = e;
    n({
        creativeEffect: {
            limitProgress: 1,
            shadowPerProgress: !1,
            progressMultiplier: 1,
            perspective: !0,
            prev: {
                translate: [0, 0, 0],
                rotate: [0, 0, 0],
                opacity: 1,
                scale: 1
            },
            next: {
                translate: [0, 0, 0],
                rotate: [0, 0, 0],
                opacity: 1,
                scale: 1
            }
        }
    });
    const i = a=>typeof a == "string" ? a : `${a}px`;
    Yi({
        effect: "creative",
        swiper: t,
        on: r,
        setTranslate: ()=>{
            const {slides: a, wrapperEl: l, slidesSizesGrid: c} = t
                , u = t.params.creativeEffect
                , {progressMultiplier: f} = u
                , d = t.params.centeredSlides;
            if (d) {
                const h = c[0] / 2 - t.params.slidesOffsetBefore || 0;
                l.style.transform = `translateX(calc(50% - ${h}px))`
            }
            for (let h = 0; h < a.length; h += 1) {
                const y = a[h]
                    , p = y.progress
                    , w = Math.min(Math.max(y.progress, -u.limitProgress), u.limitProgress);
                let m = w;
                d || (m = Math.min(Math.max(y.originalProgress, -u.limitProgress), u.limitProgress));
                const g = y.swiperSlideOffset
                    , b = [t.params.cssMode ? -g - t.translate : -g, 0, 0]
                    , v = [0, 0, 0];
                let S = !1;
                t.isHorizontal() || (b[1] = b[0],
                    b[0] = 0);
                let _ = {
                    translate: [0, 0, 0],
                    rotate: [0, 0, 0],
                    scale: 1,
                    opacity: 1
                };
                w < 0 ? (_ = u.next,
                    S = !0) : w > 0 && (_ = u.prev,
                    S = !0),
                    b.forEach((A,k)=>{
                            b[k] = `calc(${A}px + (${i(_.translate[k])} * ${Math.abs(w * f)}))`
                        }
                    ),
                    v.forEach((A,k)=>{
                            v[k] = _.rotate[k] * Math.abs(w * f)
                        }
                    ),
                    y.style.zIndex = -Math.abs(Math.round(p)) + a.length;
                const E = b.join(", ")
                    , T = `rotateX(${v[0]}deg) rotateY(${v[1]}deg) rotateZ(${v[2]}deg)`
                    , P = m < 0 ? `scale(${1 + (1 - _.scale) * m * f})` : `scale(${1 - (1 - _.scale) * m * f})`
                    , I = m < 0 ? 1 + (1 - _.opacity) * m * f : 1 - (1 - _.opacity) * m * f
                    , L = `translate3d(${E}) ${T} ${P}`;
                if (S && _.shadow || !S) {
                    let A = y.querySelector(".swiper-slide-shadow");
                    if (!A && _.shadow && (A = Hi("creative", y)),
                        A) {
                        const k = u.shadowPerProgress ? w * (1 / u.limitProgress) : w;
                        A.style.opacity = Math.min(Math.max(Math.abs(k), 0), 1)
                    }
                }
                const x = ao(u, y);
                x.style.transform = L,
                    x.style.opacity = I,
                _.origin && (x.style.transformOrigin = _.origin)
            }
        }
        ,
        setTransition: a=>{
            const l = t.slides.map(c=>ii(c));
            l.forEach(c=>{
                    c.style.transitionDuration = `${a}ms`,
                        c.querySelectorAll(".swiper-slide-shadow").forEach(u=>{
                                u.style.transitionDuration = `${a}ms`
                            }
                        )
                }
            ),
                pl({
                    swiper: t,
                    duration: a,
                    transformElements: l,
                    allSlides: !0
                })
        }
        ,
        perspective: ()=>t.params.creativeEffect.perspective,
        overwriteParams: ()=>({
            watchSlidesProgress: !0,
            virtualTranslate: !t.params.cssMode
        })
    })
}
function E2(e) {
    let {swiper: t, extendParams: n, on: r} = e;
    n({
        cardsEffect: {
            slideShadows: !0,
            rotate: !0,
            perSlideRotate: 2,
            perSlideOffset: 8
        }
    }),
        Yi({
            effect: "cards",
            swiper: t,
            on: r,
            setTranslate: ()=>{
                const {slides: o, activeIndex: a, rtlTranslate: l} = t
                    , c = t.params.cardsEffect
                    , {startTranslate: u, isTouched: f} = t.touchEventsData
                    , d = l ? -t.translate : t.translate;
                for (let h = 0; h < o.length; h += 1) {
                    const y = o[h]
                        , p = y.progress
                        , w = Math.min(Math.max(p, -4), 4);
                    let m = y.swiperSlideOffset;
                    t.params.centeredSlides && !t.params.cssMode && (t.wrapperEl.style.transform = `translateX(${t.minTranslate()}px)`),
                    t.params.centeredSlides && t.params.cssMode && (m -= o[0].swiperSlideOffset);
                    let g = t.params.cssMode ? -m - t.translate : -m
                        , b = 0;
                    const v = -100 * Math.abs(w);
                    let S = 1
                        , _ = -c.perSlideRotate * w
                        , E = c.perSlideOffset - Math.abs(w) * .75;
                    const T = t.virtual && t.params.virtual.enabled ? t.virtual.from + h : h
                        , P = (T === a || T === a - 1) && w > 0 && w < 1 && (f || t.params.cssMode) && d < u
                        , I = (T === a || T === a + 1) && w < 0 && w > -1 && (f || t.params.cssMode) && d > u;
                    if (P || I) {
                        const k = (1 - Math.abs((Math.abs(w) - .5) / .5)) ** .5;
                        _ += -28 * w * k,
                            S += -.5 * k,
                            E += 96 * k,
                            b = `${-25 * k * Math.abs(w)}%`
                    }
                    if (w < 0 ? g = `calc(${g}px ${l ? "-" : "+"} (${E * Math.abs(w)}%))` : w > 0 ? g = `calc(${g}px ${l ? "-" : "+"} (-${E * Math.abs(w)}%))` : g = `${g}px`,
                        !t.isHorizontal()) {
                        const k = b;
                        b = g,
                            g = k
                    }
                    const L = w < 0 ? `${1 + (1 - S) * w}` : `${1 - (1 - S) * w}`
                        , x = `
        translate3d(${g}, ${b}, ${v}px)
        rotateZ(${c.rotate ? l ? -_ : _ : 0}deg)
        scale(${L})
      `;
                    if (c.slideShadows) {
                        let k = y.querySelector(".swiper-slide-shadow");
                        k || (k = Hi("cards", y)),
                        k && (k.style.opacity = Math.min(Math.max((Math.abs(w) - .5) / .5, 0), 1))
                    }
                    y.style.zIndex = -Math.abs(Math.round(p)) + o.length;
                    const A = ao(c, y);
                    A.style.transform = x
                }
            }
            ,
            setTransition: o=>{
                const a = t.slides.map(l=>ii(l));
                a.forEach(l=>{
                        l.style.transitionDuration = `${o}ms`,
                            l.querySelectorAll(".swiper-slide-shadow").forEach(c=>{
                                    c.style.transitionDuration = `${o}ms`
                                }
                            )
                    }
                ),
                    pl({
                        swiper: t,
                        duration: o,
                        transformElements: a
                    })
            }
            ,
            perspective: ()=>!0,
            overwriteParams: ()=>({
                watchSlidesProgress: !0,
                virtualTranslate: !t.params.cssMode
            })
        })
}
const C2 = [q$, J$, Z$, Q$, e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2, f2, v2, y2, b2, w2, S2, _2, E2];
Jt.use(C2);
const hl = ["eventsPrefix", "injectStyles", "injectStylesUrls", "modules", "init", "_direction", "oneWayMovement", "touchEventsTarget", "initialSlide", "_speed", "cssMode", "updateOnWindowResize", "resizeObserver", "nested", "focusableElements", "_enabled", "_width", "_height", "preventInteractionOnTransition", "userAgent", "url", "_edgeSwipeDetection", "_edgeSwipeThreshold", "_freeMode", "_autoHeight", "setWrapperSize", "virtualTranslate", "_effect", "breakpoints", "_spaceBetween", "_slidesPerView", "maxBackfaceHiddenSlides", "_grid", "_slidesPerGroup", "_slidesPerGroupSkip", "_slidesPerGroupAuto", "_centeredSlides", "_centeredSlidesBounds", "_slidesOffsetBefore", "_slidesOffsetAfter", "normalizeSlideIndex", "_centerInsufficientSlides", "_watchOverflow", "roundLengths", "touchRatio", "touchAngle", "simulateTouch", "_shortSwipes", "_longSwipes", "longSwipesRatio", "longSwipesMs", "_followFinger", "allowTouchMove", "_threshold", "touchMoveStopPropagation", "touchStartPreventDefault", "touchStartForcePreventDefault", "touchReleaseOnEdges", "uniqueNavElements", "_resistance", "_resistanceRatio", "_watchSlidesProgress", "_grabCursor", "preventClicks", "preventClicksPropagation", "_slideToClickedSlide", "_loop", "loopedSlides", "loopPreventsSliding", "_rewind", "_allowSlidePrev", "_allowSlideNext", "_swipeHandler", "_noSwiping", "noSwipingClass", "noSwipingSelector", "passiveListeners", "containerModifierClass", "slideClass", "slideActiveClass", "slideVisibleClass", "slideNextClass", "slidePrevClass", "wrapperClass", "lazyPreloaderClass", "lazyPreloadPrevNext", "runCallbacksOnInit", "observer", "observeParents", "observeSlideChildren", "a11y", "_autoplay", "_controller", "coverflowEffect", "cubeEffect", "fadeEffect", "flipEffect", "creativeEffect", "cardsEffect", "hashNavigation", "history", "keyboard", "mousewheel", "_navigation", "_pagination", "parallax", "_scrollbar", "_thumbs", "virtual", "zoom", "control"];
function Ta(e) {
    return typeof e == "object" && e !== null && e.constructor && Object.prototype.toString.call(e).slice(8, -1) === "Object"
}
function xa(e, t) {
    const n = ["__proto__", "constructor", "prototype"];
    Object.keys(t).filter(r=>n.indexOf(r) < 0).forEach(r=>{
            typeof e[r] > "u" ? e[r] = t[r] : Ta(t[r]) && Ta(e[r]) && Object.keys(t[r]).length > 0 ? t[r].__swiper__ ? e[r] = t[r] : xa(e[r], t[r]) : e[r] = t[r]
        }
    )
}
function T2(e) {
    return e === void 0 && (e = {}),
    e.navigation && typeof e.navigation.nextEl > "u" && typeof e.navigation.prevEl > "u"
}
function x2(e) {
    return e === void 0 && (e = {}),
    e.pagination && typeof e.pagination.el > "u"
}
function P2(e) {
    return e === void 0 && (e = {}),
    e.scrollbar && typeof e.scrollbar.el > "u"
}
function Jo(e) {
    return e === void 0 && (e = ""),
        e.replace(/-[a-z]/g, t=>t.toUpperCase().replace("-", ""))
}
function k2(e) {
    let {swiper: t, slides: n, passedParams: r, changedParams: i, nextEl: s, prevEl: o, scrollbarEl: a, paginationEl: l} = e;
    const c = i.filter(P=>P !== "children" && P !== "direction" && P !== "wrapperClass")
        , {params: u, pagination: f, navigation: d, scrollbar: h, virtual: y, thumbs: p} = t;
    let w, m, g, b, v, S, _, E;
    i.includes("thumbs") && r.thumbs && r.thumbs.swiper && u.thumbs && !u.thumbs.swiper && (w = !0),
    i.includes("controller") && r.controller && r.controller.control && u.controller && !u.controller.control && (m = !0),
    i.includes("pagination") && r.pagination && (r.pagination.el || l) && (u.pagination || u.pagination === !1) && f && !f.el && (g = !0),
    i.includes("scrollbar") && r.scrollbar && (r.scrollbar.el || a) && (u.scrollbar || u.scrollbar === !1) && h && !h.el && (b = !0),
    i.includes("navigation") && r.navigation && (r.navigation.prevEl || o) && (r.navigation.nextEl || s) && (u.navigation || u.navigation === !1) && d && !d.prevEl && !d.nextEl && (v = !0);
    const T = P=>{
            t[P] && (t[P].destroy(),
                P === "navigation" ? (t.isElement && (t[P].prevEl.remove(),
                    t[P].nextEl.remove()),
                    u[P].prevEl = void 0,
                    u[P].nextEl = void 0,
                    t[P].prevEl = void 0,
                    t[P].nextEl = void 0) : (t.isElement && t[P].el.remove(),
                    u[P].el = void 0,
                    t[P].el = void 0))
        }
    ;
    i.includes("loop") && t.isElement && (u.loop && !r.loop ? S = !0 : !u.loop && r.loop ? _ = !0 : E = !0),
        c.forEach(P=>{
                if (Ta(u[P]) && Ta(r[P]))
                    xa(u[P], r[P]),
                    (P === "navigation" || P === "pagination" || P === "scrollbar") && "enabled"in r[P] && !r[P].enabled && T(P);
                else {
                    const I = r[P];
                    (I === !0 || I === !1) && (P === "navigation" || P === "pagination" || P === "scrollbar") ? I === !1 && T(P) : u[P] = r[P]
                }
            }
        ),
    c.includes("controller") && !m && t.controller && t.controller.control && u.controller && u.controller.control && (t.controller.control = u.controller.control),
    i.includes("children") && n && y && u.virtual.enabled && (y.slides = n,
        y.update(!0)),
    i.includes("children") && n && u.loop && (E = !0),
    w && p.init() && p.update(!0),
    m && (t.controller.control = u.controller.control),
    g && (t.isElement && (!l || typeof l == "string") && (l = document.createElement("div"),
        l.classList.add("swiper-pagination"),
        t.el.appendChild(l)),
    l && (u.pagination.el = l),
        f.init(),
        f.render(),
        f.update()),
    b && (t.isElement && (!a || typeof a == "string") && (a = document.createElement("div"),
        a.classList.add("swiper-scrollbar"),
        t.el.appendChild(a)),
    a && (u.scrollbar.el = a),
        h.init(),
        h.updateSize(),
        h.setTranslate()),
    v && (t.isElement && ((!s || typeof s == "string") && (s = document.createElement("div"),
        s.classList.add("swiper-button-next"),
        s.innerHTML = t.hostEl.nextButtonSvg,
        t.el.appendChild(s)),
    (!o || typeof o == "string") && (o = document.createElement("div"),
        o.classList.add("swiper-button-prev"),
        s.innerHTML = t.hostEl.prevButtonSvg,
        t.el.appendChild(o))),
    s && (u.navigation.nextEl = s),
    o && (u.navigation.prevEl = o),
        d.init(),
        d.update()),
    i.includes("allowSlideNext") && (t.allowSlideNext = r.allowSlideNext),
    i.includes("allowSlidePrev") && (t.allowSlidePrev = r.allowSlidePrev),
    i.includes("direction") && t.changeDirection(r.direction, !1),
    (S || E) && t.loopDestroy(),
    (_ || E) && t.loopCreate(),
        t.update()
}
const Sm = e=>{
    if (parseFloat(e) === Number(e))
        return Number(e);
    if (e === "true" || e === "")
        return !0;
    if (e === "false")
        return !1;
    if (e === "null")
        return null;
    if (e !== "undefined") {
        if (typeof e == "string" && e.includes("{") && e.includes("}") && e.includes('"')) {
            let t;
            try {
                t = JSON.parse(e)
            } catch {
                t = e
            }
            return t
        }
        return e
    }
}
    , _m = ["a11y", "autoplay", "controller", "cards-effect", "coverflow-effect", "creative-effect", "cube-effect", "fade-effect", "flip-effect", "free-mode", "grid", "hash-navigation", "history", "keyboard", "mousewheel", "navigation", "pagination", "parallax", "scrollbar", "thumbs", "virtual", "zoom"];
function Em(e, t, n) {
    const r = {}
        , i = {};
    xa(r, mu);
    const s = [...hl, "on"]
        , o = s.map(l=>l.replace(/_/, ""));
    s.forEach(l=>{
            l = l.replace("_", ""),
            typeof e[l] < "u" && (i[l] = e[l])
        }
    );
    const a = [...e.attributes];
    return typeof t == "string" && typeof n < "u" && a.push({
        name: t,
        value: n
    }),
        a.forEach(l=>{
                const c = _m.filter(u=>l.name.indexOf(`${u}-`) === 0)[0];
                if (c) {
                    const u = Jo(c)
                        , f = Jo(l.name.split(`${c}-`)[1]);
                    typeof i[u] > "u" && (i[u] = {}),
                    i[u] === !0 && (i[u] = {
                        enabled: !0
                    }),
                        i[u][f] = Sm(l.value)
                } else {
                    const u = Jo(l.name);
                    if (!o.includes(u))
                        return;
                    const f = Sm(l.value);
                    i[u] && _m.includes(l.name) ? (i[u].constructor !== Object && (i[u] = {}),
                        i[u].enabled = f) : i[u] = f
                }
            }
        ),
        xa(r, i),
        r.navigation ? r.navigation = {
            prevEl: ".swiper-button-prev",
            nextEl: ".swiper-button-next",
            ...r.navigation !== !0 ? r.navigation : {}
        } : r.navigation === !1 && delete r.navigation,
        r.scrollbar ? r.scrollbar = {
            el: ".swiper-scrollbar",
            ...r.scrollbar !== !0 ? r.scrollbar : {}
        } : r.scrollbar === !1 && delete r.scrollbar,
        r.pagination ? r.pagination = {
            el: ".swiper-pagination",
            ...r.pagination !== !0 ? r.pagination : {}
        } : r.pagination === !1 && delete r.pagination,
        {
            params: r,
            passedParams: i
        }
}
const R2 = ":host{--swiper-theme-color:#007aff}:host{position:relative;display:block;margin-left:auto;margin-right:auto;z-index:1}.swiper{width:100%;height:100%;margin-left:auto;margin-right:auto;position:relative;overflow:hidden;overflow:clip;list-style:none;padding:0;z-index:1;display:block}.swiper-vertical>.swiper-wrapper{flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:flex;transition-property:transform;transition-timing-function:var(--swiper-wrapper-transition-timing-function,initial);box-sizing:content-box}.swiper-android ::slotted(swiper-slide),.swiper-ios ::slotted(swiper-slide),.swiper-wrapper{transform:translate3d(0px,0,0)}.swiper-horizontal{touch-action:pan-y}.swiper-vertical{touch-action:pan-x}::slotted(swiper-slide){flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform;display:block}::slotted(.swiper-slide-invisible-blank){visibility:hidden}.swiper-autoheight,.swiper-autoheight ::slotted(swiper-slide){height:auto}.swiper-autoheight .swiper-wrapper{align-items:flex-start;transition-property:transform,height}.swiper-backface-hidden ::slotted(swiper-slide){transform:translateZ(0);-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-3d.swiper-css-mode .swiper-wrapper{perspective:1200px}.swiper-3d .swiper-wrapper{transform-style:preserve-3d}.swiper-3d{perspective:1200px}.swiper-3d .swiper-cube-shadow,.swiper-3d ::slotted(swiper-slide){transform-style:preserve-3d}.swiper-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-css-mode ::slotted(swiper-slide){scroll-snap-align:start start}.swiper-css-mode.swiper-horizontal>.swiper-wrapper{scroll-snap-type:x mandatory}.swiper-css-mode.swiper-vertical>.swiper-wrapper{scroll-snap-type:y mandatory}.swiper-css-mode.swiper-free-mode>.swiper-wrapper{scroll-snap-type:none}.swiper-css-mode.swiper-free-mode ::slotted(swiper-slide){scroll-snap-align:none}.swiper-css-mode.swiper-centered>.swiper-wrapper::before{content:'';flex-shrink:0;order:9999}.swiper-css-mode.swiper-centered ::slotted(swiper-slide){scroll-snap-align:center center;scroll-snap-stop:always}.swiper-css-mode.swiper-centered.swiper-horizontal ::slotted(swiper-slide):first-child{margin-inline-start:var(--swiper-centered-offset-before)}.swiper-css-mode.swiper-centered.swiper-horizontal>.swiper-wrapper::before{height:100%;min-height:1px;width:var(--swiper-centered-offset-after)}.swiper-css-mode.swiper-centered.swiper-vertical ::slotted(swiper-slide):first-child{margin-block-start:var(--swiper-centered-offset-before)}.swiper-css-mode.swiper-centered.swiper-vertical>.swiper-wrapper::before{width:100%;min-width:1px;height:var(--swiper-centered-offset-after)}.swiper-virtual ::slotted(swiper-slide){-webkit-backface-visibility:hidden;transform:translateZ(0)}.swiper-virtual.swiper-css-mode .swiper-wrapper::after{content:'';position:absolute;left:0;top:0;pointer-events:none}.swiper-virtual.swiper-css-mode.swiper-horizontal .swiper-wrapper::after{height:1px;width:var(--swiper-virtual-size)}.swiper-virtual.swiper-css-mode.swiper-vertical .swiper-wrapper::after{width:1px;height:var(--swiper-virtual-size)}:host{--swiper-navigation-size:44px}.swiper-button-next,.swiper-button-prev{position:absolute;top:var(--swiper-navigation-top-offset,50%);width:calc(var(--swiper-navigation-size)/ 44 * 27);height:var(--swiper-navigation-size);margin-top:calc(0px - (var(--swiper-navigation-size)/ 2));z-index:10;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--swiper-navigation-color,var(--swiper-theme-color))}.swiper-button-next.swiper-button-disabled,.swiper-button-prev.swiper-button-disabled{opacity:.35;cursor:auto;pointer-events:none}.swiper-button-next.swiper-button-hidden,.swiper-button-prev.swiper-button-hidden{opacity:0;cursor:auto;pointer-events:none}.swiper-navigation-disabled .swiper-button-next,.swiper-navigation-disabled .swiper-button-prev{display:none!important}.swiper-button-next svg,.swiper-button-prev svg{width:100%;height:100%;object-fit:contain;transform-origin:center}.swiper-rtl .swiper-button-next svg,.swiper-rtl .swiper-button-prev svg{transform:rotate(180deg)}.swiper-button-prev,.swiper-rtl .swiper-button-next{left:var(--swiper-navigation-sides-offset,10px);right:auto}.swiper-button-next,.swiper-rtl .swiper-button-prev{right:var(--swiper-navigation-sides-offset,10px);left:auto}.swiper-button-lock{display:none}.swiper-pagination{position:absolute;text-align:center;transition:.3s opacity;transform:translate3d(0,0,0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-pagination-disabled>.swiper-pagination,.swiper-pagination.swiper-pagination-disabled{display:none!important}.swiper-horizontal>.swiper-pagination-bullets,.swiper-pagination-bullets.swiper-pagination-horizontal,.swiper-pagination-custom,.swiper-pagination-fraction{bottom:var(--swiper-pagination-bottom,8px);top:var(--swiper-pagination-top,auto);left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transform:scale(.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{transform:scale(.33)}.swiper-pagination-bullet{width:var(--swiper-pagination-bullet-width,var(--swiper-pagination-bullet-size,8px));height:var(--swiper-pagination-bullet-height,var(--swiper-pagination-bullet-size,8px));display:inline-block;border-radius:var(--swiper-pagination-bullet-border-radius,50%);background:var(--swiper-pagination-bullet-inactive-color,#000);opacity:var(--swiper-pagination-bullet-inactive-opacity, .2)}button.swiper-pagination-bullet{border:none;margin:0;padding:0;box-shadow:none;-webkit-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet:only-child{display:none!important}.swiper-pagination-bullet-active{opacity:var(--swiper-pagination-bullet-opacity, 1);background:var(--swiper-pagination-color,var(--swiper-theme-color))}.swiper-pagination-vertical.swiper-pagination-bullets,.swiper-vertical>.swiper-pagination-bullets{right:var(--swiper-pagination-right,8px);left:var(--swiper-pagination-left,auto);top:50%;transform:translate3d(0px,-50%,0)}.swiper-pagination-vertical.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{margin:var(--swiper-pagination-bullet-vertical-gap,6px) 0;display:block}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;transform:translateY(-50%);width:8px}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;transition:.2s transform,.2s top}.swiper-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 var(--swiper-pagination-bullet-horizontal-gap,4px)}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;transform:translateX(-50%);white-space:nowrap}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s left}.swiper-horizontal.swiper-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s right}.swiper-pagination-fraction{color:var(--swiper-pagination-fraction-color,inherit)}.swiper-pagination-progressbar{background:var(--swiper-pagination-progressbar-bg-color,rgba(0,0,0,.25));position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--swiper-pagination-color,var(--swiper-theme-color));position:absolute;left:0;top:0;width:100%;height:100%;transform:scale(0);transform-origin:left top}.swiper-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{transform-origin:right top}.swiper-horizontal>.swiper-pagination-progressbar,.swiper-pagination-progressbar.swiper-pagination-horizontal,.swiper-pagination-progressbar.swiper-pagination-vertical.swiper-pagination-progressbar-opposite,.swiper-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:100%;height:var(--swiper-pagination-progressbar-size,4px);left:0;top:0}.swiper-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-vertical,.swiper-vertical>.swiper-pagination-progressbar{width:var(--swiper-pagination-progressbar-size,4px);height:100%;left:0;top:0}.swiper-pagination-lock{display:none}.swiper-scrollbar{border-radius:var(--swiper-scrollbar-border-radius,10px);position:relative;-ms-touch-action:none;background:var(--swiper-scrollbar-bg-color,rgba(0,0,0,.1))}.swiper-scrollbar-disabled>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-disabled{display:none!important}.swiper-horizontal>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-horizontal{position:absolute;left:var(--swiper-scrollbar-sides-offset,1%);bottom:var(--swiper-scrollbar-bottom,4px);top:var(--swiper-scrollbar-top,auto);z-index:50;height:var(--swiper-scrollbar-size,4px);width:calc(100% - 2 * var(--swiper-scrollbar-sides-offset,1%))}.swiper-scrollbar.swiper-scrollbar-vertical,.swiper-vertical>.swiper-scrollbar{position:absolute;left:var(--swiper-scrollbar-left,auto);right:var(--swiper-scrollbar-right,4px);top:var(--swiper-scrollbar-sides-offset,1%);z-index:50;width:var(--swiper-scrollbar-size,4px);height:calc(100% - 2 * var(--swiper-scrollbar-sides-offset,1%))}.swiper-scrollbar-drag{height:100%;width:100%;position:relative;background:var(--swiper-scrollbar-drag-bg-color,rgba(0,0,0,.5));border-radius:var(--swiper-scrollbar-border-radius,10px);left:0;top:0}.swiper-scrollbar-cursor-drag{cursor:move}.swiper-scrollbar-lock{display:none}::slotted(.swiper-slide-zoomed){cursor:move;touch-action:none}.swiper .swiper-notification{position:absolute;left:0;top:0;pointer-events:none;opacity:0;z-index:-1000}.swiper-free-mode>.swiper-wrapper{transition-timing-function:ease-out;margin:0 auto}.swiper-grid>.swiper-wrapper{flex-wrap:wrap}.swiper-grid-column>.swiper-wrapper{flex-wrap:wrap;flex-direction:column}.swiper-fade.swiper-free-mode ::slotted(swiper-slide){transition-timing-function:ease-out}.swiper-fade ::slotted(swiper-slide){pointer-events:none;transition-property:opacity}.swiper-fade ::slotted(swiper-slide) ::slotted(swiper-slide){pointer-events:none}.swiper-fade ::slotted(.swiper-slide-active),.swiper-fade ::slotted(.swiper-slide-active) ::slotted(.swiper-slide-active){pointer-events:auto}.swiper-cube{overflow:visible}.swiper-cube ::slotted(swiper-slide){pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1;visibility:hidden;transform-origin:0 0;width:100%;height:100%}.swiper-cube ::slotted(swiper-slide) ::slotted(swiper-slide){pointer-events:none}.swiper-cube.swiper-rtl ::slotted(swiper-slide){transform-origin:100% 0}.swiper-cube ::slotted(.swiper-slide-active),.swiper-cube ::slotted(.swiper-slide-active) ::slotted(.swiper-slide-active){pointer-events:auto}.swiper-cube ::slotted(.swiper-slide-active),.swiper-cube ::slotted(.swiper-slide-next),.swiper-cube ::slotted(.swiper-slide-prev){pointer-events:auto;visibility:visible}.swiper-cube .swiper-cube-shadow{position:absolute;left:0;bottom:0px;width:100%;height:100%;opacity:.6;z-index:0}.swiper-cube .swiper-cube-shadow:before{content:'';background:#000;position:absolute;left:0;top:0;bottom:0;right:0;filter:blur(50px)}.swiper-cube ::slotted(.swiper-slide-next)+::slotted(swiper-slide){pointer-events:auto;visibility:visible}.swiper-flip{overflow:visible}.swiper-flip ::slotted(swiper-slide){pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1}.swiper-flip ::slotted(swiper-slide) ::slotted(swiper-slide){pointer-events:none}.swiper-flip ::slotted(.swiper-slide-active),.swiper-flip ::slotted(.swiper-slide-active) ::slotted(.swiper-slide-active){pointer-events:auto}.swiper-creative ::slotted(swiper-slide){-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden;transition-property:transform,opacity,height}.swiper-cards{overflow:visible}.swiper-cards ::slotted(swiper-slide){transform-origin:center bottom;-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden}"
    , L2 = "::slotted(.swiper-slide-shadow),::slotted(.swiper-slide-shadow-bottom),::slotted(.swiper-slide-shadow-left),::slotted(.swiper-slide-shadow-right),::slotted(.swiper-slide-shadow-top){position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}::slotted(.swiper-slide-shadow){background:rgba(0,0,0,.15)}::slotted(.swiper-slide-shadow-left){background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}::slotted(.swiper-slide-shadow-right){background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}::slotted(.swiper-slide-shadow-top){background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}::slotted(.swiper-slide-shadow-bottom){background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}::slotted(.swiper-lazy-preloader){animation:swiper-preloader-spin 1s infinite linear;width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;transform-origin:50%;box-sizing:border-box;border:4px solid var(--swiper-preloader-color,var(--swiper-theme-color));border-radius:50%;border-top-color:transparent}@keyframes swiper-preloader-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-bottom),::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-left),::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-right),::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-top){z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-bottom),::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-left),::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-right),::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-top){z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}::slotted(.swiper-zoom-container){width:100%;height:100%;display:flex;justify-content:center;align-items:center;text-align:center}::slotted(.swiper-zoom-container)>canvas,::slotted(.swiper-zoom-container)>img,::slotted(.swiper-zoom-container)>svg{max-width:100%;max-height:100%;object-fit:contain}";
class O2 {
}
const U0 = typeof window > "u" || typeof HTMLElement > "u" ? O2 : HTMLElement
    , Cm = `<svg width="11" height="20" viewBox="0 0 11 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0.38296 20.0762C0.111788 19.805 0.111788 19.3654 0.38296 19.0942L9.19758 10.2796L0.38296 1.46497C0.111788 1.19379 0.111788 0.754138 0.38296 0.482966C0.654131 0.211794 1.09379 0.211794 1.36496 0.482966L10.4341 9.55214C10.8359 9.9539 10.8359 10.6053 10.4341 11.007L1.36496 20.0762C1.09379 20.3474 0.654131 20.3474 0.38296 20.0762Z" fill="currentColor"/></svg>
    `
    , W0 = (e,t)=>{
        if (typeof CSSStyleSheet < "u" && e.adoptedStyleSheets) {
            const n = new CSSStyleSheet;
            n.replaceSync(t),
                e.adoptedStyleSheets = [n]
        } else {
            const n = document.createElement("style");
            n.rel = "stylesheet",
                n.textContent = t,
                e.appendChild(n)
        }
    }
;
class G0 extends U0 {
    constructor() {
        super(),
            this.attachShadow({
                mode: "open"
            })
    }
    static get nextButtonSvg() {
        return Cm
    }
    static get prevButtonSvg() {
        return Cm.replace("/></svg>", ' transform-origin="center" transform="rotate(180)"/></svg>')
    }
    cssStyles() {
        return [R2, ...this.injectStyles && Array.isArray(this.injectStyles) ? this.injectStyles : []].join(`
`)
    }
    cssLinks() {
        return this.injectStylesUrls || []
    }
    calcSlideSlots() {
        const t = this.slideSlots || 0
            , n = [...this.querySelectorAll("[slot^=slide-]")].map(r=>parseInt(r.getAttribute("slot").split("slide-")[1], 10));
        if (this.slideSlots = n.length ? Math.max(...n) + 1 : 0,
            !!this.rendered) {
            if (this.slideSlots > t)
                for (let r = t; r < this.slideSlots; r += 1) {
                    const i = document.createElement("swiper-slide");
                    i.setAttribute("part", `slide slide-${r + 1}`);
                    const s = document.createElement("slot");
                    s.setAttribute("name", `slide-${r + 1}`),
                        i.appendChild(s),
                        this.shadowRoot.querySelector(".swiper-wrapper").appendChild(i)
                }
            else if (this.slideSlots < t) {
                const r = this.swiper.slides;
                for (let i = r.length - 1; i >= 0; i -= 1)
                    i > this.slideSlots && r[i].remove()
            }
        }
    }
    render() {
        if (this.rendered)
            return;
        this.calcSlideSlots();
        let t = this.cssStyles();
        this.slideSlots > 0 && (t = t.replace(/::slotted\(([a-z-0-9.]*)\)/g, "$1")),
        t.length && W0(this.shadowRoot, t),
            this.cssLinks().forEach(r=>{
                    if (this.shadowRoot.querySelector(`link[href="${r}"]`))
                        return;
                    const s = document.createElement("link");
                    s.rel = "stylesheet",
                        s.href = r,
                        this.shadowRoot.appendChild(s)
                }
            );
        const n = document.createElement("div");
        n.classList.add("swiper"),
            n.part = "container",
            n.innerHTML = `
      <slot name="container-start"></slot>
      <div class="swiper-wrapper" part="wrapper">
        <slot></slot>
        ${Array.from({
                length: this.slideSlots
            }).map((r,i)=>`
        <swiper-slide part="slide slide-${i}">
          <slot name="slide-${i}"></slot>
        </swiper-slide>
        `).join("")}
      </div>
      <slot name="container-end"></slot>
      ${T2(this.passedParams) ? `
        <div part="button-prev" class="swiper-button-prev">${this.constructor.prevButtonSvg}</div>
        <div part="button-next" class="swiper-button-next">${this.constructor.nextButtonSvg}</div>
      ` : ""}
      ${x2(this.passedParams) ? `
        <div part="pagination" class="swiper-pagination"></div>
      ` : ""}
      ${P2(this.passedParams) ? `
        <div part="scrollbar" class="swiper-scrollbar"></div>
      ` : ""}
    `,
            this.shadowRoot.appendChild(n),
            this.rendered = !0
    }
    initialize() {
        var t = this;
        if (this.initialized)
            return;
        this.initialized = !0;
        const {params: n, passedParams: r} = Em(this);
        this.swiperParams = n,
            this.passedParams = r,
            delete this.swiperParams.init,
            this.render(),
            this.swiper = new Jt(this.shadowRoot.querySelector(".swiper"),{
                ...n.virtual ? {} : {
                    observer: !0,
                    observeSlideChildren: this.slideSlots > 0
                },
                ...n,
                touchEventsTarget: "container",
                onAny: function(i) {
                    i === "observerUpdate" && t.calcSlideSlots();
                    const s = n.eventsPrefix ? `${n.eventsPrefix}${i.toLowerCase()}` : i.toLowerCase();
                    for (var o = arguments.length, a = new Array(o > 1 ? o - 1 : 0), l = 1; l < o; l++)
                        a[l - 1] = arguments[l];
                    const c = new CustomEvent(s,{
                        detail: a,
                        bubbles: !0,
                        cancelable: !0
                    });
                    t.dispatchEvent(c)
                }
            })
    }
    connectedCallback() {
        this.initialized && this.nested && this.closest("swiper-slide") && this.closest("swiper-slide").swiperLoopMoveDOM || this.init === !1 || this.getAttribute("init") === "false" || this.initialize()
    }
    disconnectedCallback() {
        this.nested && this.closest("swiper-slide") && this.closest("swiper-slide").swiperLoopMoveDOM || (this.swiper && this.swiper.destroy && this.swiper.destroy(),
            this.initialized = !1)
    }
    updateSwiperOnPropChange(t, n) {
        const {params: r, passedParams: i} = Em(this, t, n);
        this.passedParams = i,
            this.swiperParams = r,
            k2({
                swiper: this.swiper,
                passedParams: this.passedParams,
                changedParams: [Jo(t)],
                ...t === "navigation" && i[t] ? {
                    prevEl: ".swiper-button-prev",
                    nextEl: ".swiper-button-next"
                } : {},
                ...t === "pagination" && i[t] ? {
                    paginationEl: ".swiper-pagination"
                } : {},
                ...t === "scrollbar" && i[t] ? {
                    scrollbarEl: ".swiper-scrollbar"
                } : {}
            })
    }
    attributeChangedCallback(t, n, r) {
        this.initialized && (n === "true" && r === null && (r = !1),
            this.updateSwiperOnPropChange(t, r))
    }
    static get observedAttributes() {
        return hl.filter(n=>n.includes("_")).map(n=>n.replace(/[A-Z]/g, r=>`-${r}`).replace("_", "").toLowerCase())
    }
}
hl.forEach(e=>{
        e !== "init" && (e = e.replace("_", ""),
            Object.defineProperty(G0.prototype, e, {
                configurable: !0,
                get() {
                    return (this.passedParams || {})[e]
                },
                set(t) {
                    this.passedParams || (this.passedParams = {}),
                        this.passedParams[e] = t,
                    this.initialized && this.updateSwiperOnPropChange(e)
                }
            }))
    }
);
class A2 extends U0 {
    constructor() {
        super(),
            this.attachShadow({
                mode: "open"
            })
    }
    render() {
        const t = this.lazy || this.getAttribute("lazy") === "" || this.getAttribute("lazy") === "true";
        if (W0(this.shadowRoot, L2),
            this.shadowRoot.appendChild(document.createElement("slot")),
            t) {
            const n = document.createElement("div");
            n.classList.add("swiper-lazy-preloader"),
                this.appendChild(n)
        }
    }
    initialize() {
        this.render()
    }
    connectedCallback() {
        this.initialize()
    }
}
const I2 = ()=>{
        typeof window > "u" || (window.customElements.get("swiper-container") || window.customElements.define("swiper-container", G0),
        window.customElements.get("swiper-slide") || window.customElements.define("swiper-slide", A2))
    }
;
typeof window < "u" && (window.SwiperElementRegisterParams = e=>{
        hl.push(...e)
    }
);
const M2 = Te("div", {
    class: "absolute left-0 top-0 right-0 bottom-0 w-full h-full bg-black opacity-40"
}, null, -1)
    , D2 = Te("div", {
    class: "chat-bg"
}, null, -1)
    , N2 = {
    class: "w-full h-full flex flex-col gap-6 items-center justify-center select-none pointer-events-none"
}
    , $2 = Te("div", {
    class: "animate-bounce"
}, [Te("img", {
    src: F0,
    class: "h-24 w-24 lg:h-32 lg:w-32 xl:h-48 xl:w-48 object-contain logo animate-spin"
})], -1)
    , F2 = {
    class: "text-2xl lg:text-3xl xl:text-4xl font-semibold text-white flex flex-col gap-2 items-center text-center animate-pulse"
}
    , j2 = {
    class: "tracking-wide whitespace-nowrap"
}
    , H2 = Te("div", {
    class: "text-sm whitespace-nowrap opacity-90"
}, "rulet.tv", -1)
    , B2 = {
    key: 0,
    class: "p-4"
}
    , V2 = {
    key: 0,
    class: "flex items-start justify-start w-full h-full fixed left-0 top-0 pointer-events-none"
}
    , z2 = Te("a", {
    href: "https://rulet.tv",
    class: "text-white text-sm rounded-ee px-4 py-2 bg-red bg-opacity-60 pointer-events-auto"
}, [Te("div", {
    class: "text-sm whitespace-nowrap opacity-90"
}, "DEV | rulet.tv")], -1)
    , U2 = [z2]
    , W2 = {
    class: "title"
}
    , G2 = ["innerHTML"]
    , X2 = ["onClick"]
    , K2 = Xe({
    __name: "app",
    setup(e) {
        I2(),
            $n();
        const t = Cr()
            , {hasAppTrackingTransparency: n} = $0()
            , r = Lf()
            , {initCountry: i} = Yb()
            , {isLoaded: s, load: o, data: a, session: l} = Gs()
            , c = oo()
            , u = Gs();
        Se([l, u.isLoaded, c.token], ()=>{
                u.isLoaded && c.reconnect()
            }
        );
        const f = Gr("session", null);
        Se(l, E=>{
                E !== f.value && (f.value = E)
            }
        ),
            Ve(()=>{
                    f.value && (l.value = f.value)
                }
            ),
        Gn == null || Gn.addListener("appUrlOpen", E=>{
                h(E == null ? void 0 : E.url)
            }
        ),
            (async()=>{
                    const E = await (Gn == null ? void 0 : Gn.getLaunchUrl());
                    E != null && E.url && h(E.url)
                }
            )();
        const h = async E=>{
            if (E) {
                const [T,P,I] = E.split("://").flatMap(L=>L.split("#"));
                switch (P) {
                    case "session":
                        I != null && I.trim() && l.value !== I && (Yo == null || Yo.close(),
                            f.value = I,
                            l.value = I,
                            setTimeout(()=>{
                                    window.location.reload()
                                }
                                , 500));
                        break
                }
            }
        }
            , {t: y} = $n()
            , {isMediaRequested: p, isWaitingForMedia: w, isWaitingForStream: m, isMediaInited: g, cameraAndMicPermissionGranted: b} = ri()
            , v = fe(()=>s.value ? p.value && w.value ? y("loading.camera") : p.value && m.value ? y("loading.cameraStream") : p.value && !b.value ? y("loading.noAccess") : (n.value,
            y("loading.init")) : y("loading.user"))
            , S = fe(()=>r.value && s.value && n.value && (!p.value || g.value || !w.value && b.value && !m.value));
        AN(),
            Ve(()=>{
                    document.body.style.userSelect = "none"
                }
            ),
            Kt(()=>{
                    document.body.style.removeProperty("userSelect")
                }
            );
        const _ = ()=>{
                var E, T;
                c.token.value !== ((E = a.value) == null ? void 0 : E.token) && (c.token.value = (T = a.value) == null ? void 0 : T.token)
            }
        ;
        return Se(a, _),
            Ve(async()=>{
                    var T;
                    await Promise.all([o()]),
                        i((T = a.value) == null ? void 0 : T.country),
                        _()
                }
            ),
            (E,T)=>{
                var O, N;
                const P = ER
                    , I = kR
                    , L = _N
                    , x = hg("notifications")
                    , A = LN
                    , k = ON;
                return Ae(),
                    Qe(nt, null, [Re(I, null, {
                        default: mt(()=>[Re(P)]),
                        _: 1
                    }), Te("div", {
                        class: Pt(["flex items-center justify-center w-full h-full fixed left-0 top-0 main-bg transition-opacity opacity-100 duration-200", {
                            "!opacity-0 !pointer-events-none": we(S)
                        }])
                    }, [M2, D2, Te("div", N2, [$2, Te("div", F2, [Te("div", j2, _n(E.$t("title")), 1), H2]), we(v) ? (Ae(),
                        Qe("div", B2, _n(we(v)), 1)) : Wt("", !0), Re(L)])], 2), (N = (O = we(t)) == null ? void 0 : O.public) != null && N.DEVELOPMENT ? (Ae(),
                        Qe("div", V2, U2)) : Wt("", !0), Re(x, {
                        classes: "p-4",
                        position: "top left"
                    }, {
                        body: mt(D=>[Te("div", {
                            class: Pt(["notification relative", D.item.type])
                        }, [Te("div", W2, _n(D.item.title), 1), Te("div", {
                            innerHTML: D.item.text
                        }, null, 8, G2), Te("button", {
                            onClick: D.close,
                            type: "button",
                            class: "absolute text-white right-2 top-2 leading-1 px-2 py-2 font-semibold hover:ring-3 active:ring-5 transition duration-150 active:bg-blue-100 rounded-md cursor-pointer text-center bg-black bg-opacity-20"
                        }, [Re(we(Ky), {
                            class: "h-5 w-5"
                        })], 8, X2)], 2)]),
                        _: 1
                    }), Re(A), Re(k)], 64)
            }
    }
});
const Y2 = {
    class: "pointer-events-auto flex items-center justify-center w-full h-full min-h-screen fixed left-0 top-0 right-0 bottom-0 main-bg transition-opacity opacity-100 duration-200"
}
    , q2 = Te("div", {
    class: "absolute left-0 top-0 right-0 bottom-0 w-full h-full bg-black opacity-40 pointer-events-none"
}, null, -1)
    , J2 = Te("div", {
    class: "chat-bg pointer-events-none"
}, null, -1)
    , Z2 = {
    class: "w-full h-full flex flex-col gap-6 items-center justify-center select-none"
}
    , Q2 = Te("div", null, [Te("img", {
    src: F0,
    class: "h-12 w-12 lg:h-16 lg:w-16 xl:h-24 xl:w-24 object-contain logo animate-pulse"
})], -1)
    , eF = {
    class: "text-white flex flex-col gap-4 items-center text-center"
}
    , tF = Te("div", {
    class: "whitespace-nowrap opacity-90"
}, "rulet.tv", -1)
    , nF = {
    class: "opacity-90"
}
    , rF = Te("span", {
    class: "flex-1"
}, " OK! ", -1)
    , iF = [rF]
    , sF = {
    __name: "error",
    props: {
        error: Object
    },
    setup(e) {
        const t = ()=>Av({
            redirect: "/"
        });
        return (n,r)=>(Ae(),
            Qe("div", Y2, [q2, J2, Te("div", Z2, [Q2, Te("div", eF, [tF, Te("div", nF, _n(e.error), 1), Te("button", {
                onClick: t,
                class: "flex flex-row justify-center w-full sm:w-64 border border-gray-300 hover:border-gray-500 hover:ring-3 active:border-gray-500 active:ring-5 transition duration-150 active:bg-blue-100 px-3 py-2 rounded-lg cursor-pointer font-semibold"
            }, iF)])])]))
    }
}
    , Tm = {
    __name: "nuxt-root",
    setup(e) {
        const t = ()=>null
            , n = pt()
            , r = n.deferHydration()
            , i = !1;
        Dn(to, of()),
            n.hooks.callHookWith(a=>a.map(l=>l()), "vue:setup");
        const s = qa();
        Du((a,l,c)=>{
                if (n.hooks.callHook("vue:error", a, l, c).catch(u=>console.error("[nuxt] Error in `vue:error` hook", u)),
                CT(a) && (a.fatal || a.unhandled))
                    return n.runWithContext(()=>yi(a)),
                        !1
            }
        );
        const {islandContext: o} = !1;
        return (a,l)=>(Ae(),
            gt(ja, {
                onResolve: we(r)
            }, {
                default: mt(()=>[we(s) ? (Ae(),
                    gt(we(sF), {
                        key: 0,
                        error: we(s)
                    }, null, 8, ["error"])) : we(o) ? (Ae(),
                    gt(we(t), {
                        key: 1,
                        context: we(o)
                    }, null, 8, ["context"])) : we(i) ? (Ae(),
                    gt($u(we(i)), {
                        key: 2
                    })) : (Ae(),
                    gt(we(K2), {
                        key: 3
                    }))]),
                _: 1
            }, 8, ["onResolve"]))
    }
};
globalThis.$fetch || (globalThis.$fetch = JE.create({
    baseURL: QE()
}));
let xm;
{
    let e;
    xm = async function() {
        var s, o;
        if (e)
            return e;
        const r = !!((s = window.__NUXT__) != null && s.serverRendered || ((o = document.getElementById("__NUXT_DATA__")) == null ? void 0 : o.dataset.ssr) === "true") ? av(Tm) : ov(Tm)
            , i = gC({
            vueApp: r
        });
        try {
            await yC(i, bR)
        } catch (a) {
            await i.callHook("app:error", a),
                i.payload.error = i.payload.error || a
        }
        try {
            await i.hooks.callHook("app:created", r),
                await i.hooks.callHook("app:beforeMount", r),
                r.mount("#" + oT),
                await i.hooks.callHook("app:mounted", r),
                await ct()
        } catch (a) {
            await i.callHook("app:error", a),
                i.payload.error = i.payload.error || a
        }
        return r
    }
        ,
        e = xm().catch(t=>{
                console.error("Error while mounting app:", t)
            }
        )
}
export {ct as $, yN as A, YR as B, Re as C, mt as D, gt as E, nt as F, _n as G, io as H, Cr as I, Xy as J, fA as K, At as L, Gr as M, Ky as N, xv as O, mi as P, _v as Q, pF as R, mh as S, ob as T, dL as U, ju as V, Xu as W, ev as X, TS as Y, oa as Z, JA as _, Te as a, dl as a0, Gs as a1, Xi as a2, hF as a3, Ur as a4, Pf as a5, F0 as a6, gN as a7, Eh as a8, Wa as a9, oO as aA, cF as aB, Vt as aC, Lf as aD, ri as aE, mF as aF, h_ as aG, nT as aH, aF as aI, of as aJ, Jr as aK, Hs as aL, pt as aM, oF as aN, Gy as aO, rb as aa, VA as ab, PO as ac, zA as ad, UA as ae, xO as af, BA as ag, oN as ah, Je as ai, $h as aj, Tf as ak, $n as al, cl as am, uF as an, lF as ao, PL as ap, Dl as aq, li as ar, zy as as, EO as at, oo as au, Yb as av, Br as aw, Ku as ax, LR as ay, AN as az, AA as b, Qe as c, Xe as d, fe as e, bA as f, lt as g, Ve as h, vt as i, yt as j, OA as k, cb as l, bt as m, Kt as n, Ae as o, dF as p, we as q, X as r, Wt as s, Of as t, vN as u, Pt as v, Se as w, Wi as x, uS as y, fS as z};
